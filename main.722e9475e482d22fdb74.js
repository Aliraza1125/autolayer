/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 38660:
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ab: () => (/* binding */ ENV_ENVIROMENT),
/* harmony export */   HL: () => (/* binding */ IS_DEV),
/* harmony export */   Lu: () => (/* binding */ airdropUrl),
/* harmony export */   OD: () => (/* binding */ LINEA),
/* harmony export */   Wm: () => (/* binding */ BASE),
/* harmony export */   dF: () => (/* binding */ dataMicroserviceUrl),
/* harmony export */   dO: () => (/* binding */ BINANCE),
/* harmony export */   g: () => (/* binding */ MODE),
/* harmony export */   iY: () => (/* binding */ mainnetArbitrumPro),
/* harmony export */   os: () => (/* binding */ mainnetArbitrumCandidate),
/* harmony export */   u: () => (/* binding */ SCROLL),
/* harmony export */   x1: () => (/* binding */ ARBITRUM),
/* harmony export */   yK: () => (/* binding */ ETHEREUM),
/* harmony export */   zC: () => (/* binding */ OPTIMISM)
          /* harmony export */
});
        const nativeCurrencys = { arbitrum: { name: "Ether", symbol: "ETH", decimals: 18 }, bnb: { name: "BNB", symbol: "BNB", decimals: 18 } }; const ETHEREUM = { chainId: "0x1", chainName: "Ethereum Mainnet", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://rpc.mevblocker.io"], blockExplorerUrls: ["https://etherscan.io/"], tokens: [] }; const ARBITRUM = { chainId: "0xa4b1", chainName: "Arbitrum One", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://arb1.arbitrum.io/rpc"], blockExplorerUrls: ["https://arbiscan.io/"], tokens: [] }; const BINANCE = { chainId: "0x38", chainName: "BNB Smart chain", nativeCurrency: nativeCurrencys.bnb, rpcUrls: ["https://bsc-dataseed.bnbchain.org"], blockExplorerUrls: ["https://bscscan.com/"], tokens: [] }; const LINEA = { chainId: "0xe708", chainName: "Linea", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://1rpc.io/linea"], blockExplorerUrls: ["https://lineascan.build/"], tokens: [] }; const BASE = { chainId: "0x2105", chainName: "Base", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://base-rpc.publicnode.com"], blockExplorerUrls: ["https://basescan.org/"], tokens: [] }; const SCROLL = { chainId: "0x82750", chainName: "Scroll", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://scroll.drpc.org"], blockExplorerUrls: ["https://scrollscan.com/"], tokens: [] }; const MODE = { chainId: "0x868b", chainName: "Mode", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://1rpc.io/mode"], blockExplorerUrls: ["https://modescan.com/"], tokens: [] }; const OPTIMISM = { chainId: "0xa", chainName: "Optimism", nativeCurrency: nativeCurrencys.arbitrum, rpcUrls: ["https://mainnet.optimism.io"], blockExplorerUrls: ["https://optimistic.etherscan.io/"], tokens: [] }; const IS_DEV = ({}).IS_DEVELOP === "true"; const dataMicroserviceUrl = ({}).API_URL || "https://data.autolayer.io"; const airdropUrl = `${dataMicroserviceUrl}/airdrop-tracker`; const ENV_ENVIROMENT = ({}).ENVIRONMENT; const mainnetArbitrumCandidate = { ...ARBITRUM }; const mainnetArbitrumPro = { ...ARBITRUM };

        /***/
}),

/***/ 56285:
/*!*******************************************!*\
  !*** ./src/locales/index.ts + 13 modules ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
          A: () => (/* binding */ locales)
        });

        ;// ./src/locales/en.json
        const en_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"View on {scan}","after-withdrawal-you-receive":"After withdrawal you will receive in your wallet ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Keep track of the status of all LRT airdrops using AutoLayer\'s Airdrop Tracker - monitor each phase, check if claims are open, and access direct links to claim your rewards instantly.","airdrop.title":"Discover AutoLayer Airdrop Tracker","announcement":"announcement","apr":"APR","assets":"Assets","aubnb.banner.text":" The Future of LRTs for the BNB Chain ecosystem.","autolayer-info.points":"AutoLayer points","autolayer-multiplier":"*AutoLayer* multiplier","avs-info-box.incentives":"Incentives","avs-info-box.staked":"Restaked TVL","avs-section.extended":"See *{n}* more","avs-section.hide":"Hide","avs-section.title":"Actively Validated Services","back-to-dashboard":"Back to dashboard","banner-info.title":"How this product generates Yield?","binace-network-notice":"*Note:* LRTs are not officially supported on the BNB Chain; therefore, holding them will not contribute to your EigenLayer or LRT Points. However, it will grant you AutoLayer points.","change-network":"Change network","change-network-to":"Switch your network to ","change-to-arbitrum":"Please switch to the Arbitrum network.","change-to-bsc":"Switch to Binance","color-scheme.dark":"Dark mode","color-scheme.light":"Light mode","coming-soon":"Coming soon","connect-wallet":"Connect Wallet","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Connect Wallet","continue":"Continue","copied-bubble.text":"Copied!","dashboard.autoLayer":"AutoLayer Points","dashboard.bedrock":"Bedrock Points","dashboard.claystack":"ClayStack Points","dashboard.defi-strategies":"DeFi Strategies","dashboard.eigenLayer":"EigenLayer Points","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO Points","dashboard.liquid-strategies":"Restaking Strategies","dashboard.mellow":"Mellow Points","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid Staking","dashboard.other-points":"Other Points","dashboard.primestaked":"Prime Points","dashboard.puffer":"Puffer Points","dashboard.renzo":"Renzo Points","dashboard.select-this-product":"Select this product","dashboard.stake":"Stake","dashboard.swbtc":"Black Pearls Points","dashboard.swell":"Swell Points","dashboard.symbiotic":"Symbiotic Points","dashboard.uni":"Uni Points","dashboard.weeth":"Ether.fi Points","dashboard.your-deposit":"Your Deposit","deposit-more":"Deposit more","deposit-step-approving-token.done":"Token approved.","deposit-step-approving-token.fail":"Token approval error","deposit-step-approving-token.running":"Waiting for token approval","deposit-step-getting-route.done":"Got route for swap.","deposit-step-getting-route.fail":"Error getting route. Try another token.","deposit-step-getting-route.running":"Getting route for swapping...","deposit-step-scan.link":"See transaction on *{scan}*","deposit-step-sending-token.done":"Operation done.","deposit-step-sending-token.fail":"Error swapping","deposit-step-sending-token.running":"Waiting for operation confirmation","deposit-step-signing.done":"Signed.","deposit-step-signing.fail":"Error signing transaction.","deposit-step-signing.running":"Waiting for signing","deposit.tx-points-earned":"With this transaction you have earned","details":"Details","disconnect":"Disconnect","discontinued-notice.text":"Claystack is closing down. Please withdraw your assets and check out their {link} for more details. Thank you!","discontinued-notice.title":"Discontinued Project","email-placeholder":"Enter your email address","error":"Error","error-loading-data":"Error loading data","error-loading-tokens-balance":"Error loading tokens balance","error-loading-your-values":"Error loading your values","error.404-text":"Sorry, the page you requested was not found","expand":"Expand","footer.audited-by":"Audited by","footer.community.announcements":"Announcements","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram Group","footer.community.title":"Community","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"About Us","footer.company.blog":"Blog","footer.company.title":"Company","footer.help.feed-back":"Send Feedback","footer.help.support-docs":"Support Docs","footer.help.talk-support":"Talk to support","footer.help.title":"Help","footer.info.audit":"Audit","footer.info.docs":"Documents","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"Info","footer.legacy":"Legacy Access (Tortle Ninja)","footer.legal.privacy":"Privacy Policy","footer.legal.terms":"Terms of Use","footer.legal.title":"Legal","footer.peckshield":"Check *PeckShield* audit","funds-wallet":"The funds are in your wallet!","go-to-airdrop-checker.link":"here","go-to-airdrop-checker.text":"Check your LAY3R allocation now by clicking {here}.","go-to-position":"Go to the position","how-get-whitelisted":"How to get whitelisted","ido-banner.text":"*$LAY3R IDO* goes live in ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Volume (24h)","landing.hero-banner.text":"Harness the benefits of Ethereum Restaking","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Language","language-selector.title":"Select language","launch-button.default-text":"Launch dapp","launch-button.landing-hero-banner":"Launch AutoLayer","learn-more":"Learn more","left-point.actual-value":"Actual Value","left-point.deposited":"Deposited","left-point.restaking-rewards":"Restaking Rewards","left-point.staking-rewards":"Staking Rewards","left-points-fallback":"Connect *your wallet* to continue.","loading":"Loading...","loyalty-points":"Loyalty Points","max":"Max","meta.airdrop.description":"Keep track of the status of all LRT airdrops using AutoLayer\'s Airdrop Tracker - monitor each phase, check if claims are open, and access direct links to claim your rewards instantly. 🪂","meta.airdrop.title":"Stay ahead with AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB redefines Liquid Restaked Tokens (LRTs) on BNB Chain with top yields and unified liquidity, offering up to 52% APR in $LAY3R rewards! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"The largest restaking marketplace with advanced risk-reward analytics, points management, and structured products.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Earn Bonus AutoLayer Points for both you and your friend with every successful referral!","meta.referrals.title":"Refer Friends and Earn AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"More coming soon","more-info":"More info","network":"Network","network-selector.actual":"Actual Network","network-selector.title":"Change Network","placeholder.token-selector":"Search Token...","pool-token-table.balance":"Balance","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Value","referrals":"Referrals","referrals-header.title":"Referrals","referrals-info-card.title.active-code":"Active Referral Code","referrals-info-card.title.claimable-points":"Claimable Points","referrals-info-card.title.points-earned":"Points Earned","referrals-info-card.title.referrals-traders":"Referrals Traders","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Referral codes are valid only on the current network. If you\'d like your code to work across multiple chains, you\'ll need to create a separate code for each one","referrals.affiliates.header.code":"Referral Code","referrals.affiliates.header.create":"Create","referrals.affiliates.header.title":"Referral’s Code","referrals.affiliates.header.trader":"Referral Traders","referrals.affiliates.header.volume":"Total Volume","referrals.dialog.create.button":"Create code","referrals.dialog.create.description-1":"It looks like you don\'t have a referral code to share.","referrals.dialog.create.description-2":"Create one now and start earning cashback!","referrals.dialog.create.error.claimed":"Referral code already exists","referrals.dialog.create.input.label":"Enter a code","referrals.dialog.create.input.placeholder":"Type your code...","referrals.dialog.create.success":"The code has been created successfully.","referrals.dialog.create.title":"Create referral code","referrals.dialog.error":"An unexpected error has occurred, please try again.","referrals.dialog.insert.button":"Insert referral code","referrals.dialog.insert.description":"Please enter a referral code to benefit from discounts on fees.","referrals.dialog.insert.error.claimed":"Already claimed a code","referrals.dialog.insert.error.not-exists":"Referral code does not exists","referrals.dialog.insert.error.same-owner":"Cannot claim your own code","referrals.dialog.insert.input.label":"Enter a code","referrals.dialog.insert.input.placeholder":"Enter referral code...","referrals.dialog.insert.success":"The code has been entered successfully.","referrals.dialog.insert.title":"Insert referral code","referrals.text":"Invite your friends to trade on AutoLayer and be rewarded with an extra layer of bonuses: Extra AutoLayer Points for you and your friend!","referrals.title":"AutoLayer Referral Program","refferrals-tab-buttons-affiliates":"Affiliates","refferrals-tab-buttons-traders":"Traders","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Your points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL used as collateral","risk-box.dexes":"TVL as liquidity on dexes","select-position":"Select position","select-wallet-modal.connect-wallet":"Connect Wallet","select-wallet-modal.waiting.confirm":"Please confirm the operation on your wallet","select-wallet-modal.waiting.connecting":"Connecting to your wallet","select-wallet-modal.waiting.signing":"Waiting for signature","share-link":"Copy Link","share-link-success":"Copied","share-telegram":"Share on Telegram","share-twitter":"Share on X","stake":"Deposit","stake-banner.description":"Stake your LAY3R to earn up to 35% APY","stake-banner.title":"$LAY3R staking","stake.banner.items.rewards":"Your total rewards","stake.banner.items.total":"Total LAY3R staked","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Your stake","stake.banner.title":"Stake LAY3R and earn rewards","stake.max-available-amount":"Max available amount to stake: ","stake.staking-data.buttons.claim":"Claim Reward","stake.staking-data.buttons.stake":"Stake Reward","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"COMPOUNDING","stake.staking-data.days":"DAYS","stake.staking-data.header.actions":"Actions","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Capacity","stake.staking-data.header.info":"More info","stake.staking-data.header.lock-term":"Lock term","stake.staking-data.header.my-rewards":"My rewards","stake.staking-data.header.my-stake":"My stake","stake.staking-data.header.pools":"Pools","stake.staking-data.title":"Active Pools","stake.staking-dialog.stake.approved.error":"LAY3R approve not completed","stake.staking-dialog.stake.approved.loading":"Waiting for LAY3R approval","stake.staking-dialog.stake.approved.success":"LAY3R approve completed","stake.staking-dialog.stake.confirmation.error":"Confirmation cancelated","stake.staking-dialog.stake.confirmation.loading":"Waiting for confirmation","stake.staking-dialog.stake.confirmation.success":"Confirmation completed","stake.staking-dialog.steps.done-claim":"Your rewards are in your wallet","stake.staking-dialog.steps.done-restake":"Your rewards were restaked","stake.staking-dialog.steps.done-staking":"Your LAY3Rs were staked successfully!","stake.staking-dialog.steps.done-unstaking":"Your LAY3Rs are in your wallet","start-inviting":"Start Inviting","strategies":"Strategies","subscribe":"Subscribe","swap":"Swap","swap-from":"Swap from","token-selector.deposit":"Deposit","token-selector.preview":"Swap estimation","token-selector.withdraw":"Withdraw","withdraw":"Withdraw","your-portfolio":"Your portfolio"}');
        ;// ./src/locales/es.json
        const es_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"Ver en {scan}","after-withdrawal-you-receive":"Después del retiro, recibirás en tu billetera ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Haz seguimiento del estado de todos los LRT airdrops utilizando el AutoLayer Airdrop Tracker: monitorea cada fase, verifica si las reclamaciones están abiertas y accede a enlaces directos para reclamar tus recompensas al instante.","airdrop.title":"Descubre el AutoLayer Airdrop Tracker","announcement":"anuncio","apr":"APR","assets":"Assets","aubnb.banner.text":"El futuro de los LRTs en el ecosistema de BNB chain","autolayer-info.points":"Puntos AutoLayer","autolayer-multiplier":"Multiplicador *AutoLayer*","avs-info-box.incentives":"Incentivos","avs-info-box.staked":"TVL Restaked","avs-section.extended":"Ver *{n}* más","avs-section.hide":"Ocultar","avs-section.title":"Actively Validated Services","back-to-dashboard":"Volver al dashboard","banner-info.title":"¿Cómo genera este producto Yields?","binace-network-notice":"*Note:* Los LRTs no son oficialmente compatibles con la BNB Chain; por lo tanto, tenerlos no contribuirá a tu EigenLayer o LRT points. Sin embargo, te otorgará AutoLayer points.","change-network":"Cambiar red","change-network-to":"Para continuar cambia la red a ","change-to-arbitrum":"Por favor, cambia a la red de Arbitrum.","change-to-bsc":"Cambia a Binance Smart Chain","color-scheme.dark":"Modo oscuro","color-scheme.light":"Modo claro","coming-soon":"Próximamente","connect-wallet":"Conectar cartera","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Conectar cartera","continue":"Continuar","copied-bubble.text":"¡Copiado!","dashboard.autoLayer":"Puntos AutoLayer","dashboard.bedrock":"Puntos BedRock","dashboard.claystack":"Puntos ClayStack","dashboard.defi-strategies":"DeFi Strategies","dashboard.eigenLayer":"Puntos EigenLayer","dashboard.ether":"Puntos Ether.fi","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Puntos Kelp DAO","dashboard.liquid-strategies":"Estrategias de restake","dashboard.mellow":"Puntos Mellow","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid Staking","dashboard.other-points":"Otros puntos","dashboard.primestaked":"Prime Points","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Puntos Renzo","dashboard.select-this-product":"Selecciona este producto","dashboard.stake":"Stake","dashboard.swbtc":"Puntos Black Pearls","dashboard.swell":"Puntos Swell","dashboard.symbiotic":"Puntos Symbiotic","dashboard.uni":"Puntos Uni","dashboard.weeth":"Puntos Ether.fi","dashboard.your-deposit":"Tu depósito","deposit-more":"Depositar más","deposit-step-approving-token.done":"Token aprobado.","deposit-step-approving-token.fail":"Error de aprobación del token","deposit-step-approving-token.running":"Esperando la aprobación del token...","deposit-step-getting-route.done":"Ruta para el swap obtenida.","deposit-step-getting-route.fail":"Error al obtener la ruta. Prueba con otro token.","deposit-step-getting-route.running":"Obteniendo ruta para el swap...","deposit-step-scan.link":"Ver transacción en *{scan}*","deposit-step-sending-token.done":"Operación completada.","deposit-step-sending-token.fail":"Operación completada","deposit-step-sending-token.running":"Esperando confirmación de la operación","deposit-step-signing.done":"Confirmado","deposit-step-signing.fail":"Error confirmando transacción.","deposit-step-signing.running":"Esperando por confirmación","deposit.tx-points-earned":"Con esta transacción has ganado","details":"Detalles","disconnect":"Desconectar","discontinued-notice.text":"Claystack está cerrando. Por favor, retira tus activos y visita su {link} para más detalles. Gracias!","discontinued-notice.title":"Proyecto discontinuado.","email-placeholder":"Introduce tu email","error":"Error","error-loading-data":"Error cargando datos","error-loading-tokens-balance":"Error cargando balance tokens","error-loading-your-values":"Error cargando tus valores","error.404-text":"Lo siento, la página que solicitaste no se encontró","expand":"Expandir","footer.audited-by":"Auditado por","footer.community.announcements":"Anuncios","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"TGrupo de Telegram","footer.community.title":"Comunidad","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"Sobre Nosotros","footer.company.blog":"Blog","footer.company.title":"Compañía","footer.help.feed-back":"Enviar comentarios","footer.help.support-docs":"Documentación de Soporte","footer.help.talk-support":"Hablar con Soporte","footer.help.title":"Ayuda","footer.info.audit":"Auditoría","footer.info.docs":"Documentos","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"Información","footer.legacy":"Acceso Legacy  (Tortle Ninja)","footer.legal.privacy":"Política de privacidad","footer.legal.terms":"Términos de uso","footer.legal.title":"Legal","footer.peckshield":"Verificar auditoría de *PeckShield*","funds-wallet":"¡Los fondos están en tu cartera!","go-to-airdrop-checker.link":"aquí","go-to-airdrop-checker.text":"Verifica tu asignación de LAY3R ahora haciendo clic {here}.","go-to-position":"Ir a la posición","how-get-whitelisted":"Como ser whitelisteado","ido-banner.text":"*IDO de $LAY3R* se activa en","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Volumen (24h)","landing.hero-banner.text":"Aprovecha los beneficios del Ethereum Re-Staking","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Idioma","language-selector.title":"Seleccionar idioma","launch-button.default-text":"Iniciar dapp","launch-button.landing-hero-banner":"Lanzar AutoLayer","learn-more":"Aprende más","left-point.actual-value":"Valor actual","left-point.deposited":"Depositado","left-point.restaking-rewards":"Recompensas de Restaking","left-point.staking-rewards":"Recompensas de Staking","left-points-fallback":"Conecta *tu billetera* para continuar.","loading":"Cargando...","loyalty-points":"Puntos de lealtad","max":"Max","meta.airdrop.description":"Haz seguimiento del estado de todos los LRT utilizando el AutoLayer\'s Airdrop Tracker - monitorea cada fase, verifica si las reclamaciones están abiertas y accede a enlaces directos para reclamar tus recompensas al instante.🪂","meta.airdrop.title":"Mantente al día con el AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB redefine los Liquid Restaked Tokens (LRTs) en BNB Chain con altos yields y liquidity unificada, ofreciendo hasta un 52% APR en recompensas de $LAY3R! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"El mayor mercado de restaking con análisis avanzados de risk-reward, gestión de puntos y productos estructurados.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Gana AutoLayer Points adicionales tanto para ti como para tu amigo con cada referencia exitosa!","meta.referrals.title":"Refiera a tus amigos y gana AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multiplicadores","middle-section.pool-composition":"Composición del Pool","more-coming-soon":"Más próximamente","more-info":"Más Información","network":"Red","network-selector.actual":"Red Actual","network-selector.title":"Cambiar red","placeholder.token-selector":"Buscar token...","pool-token-table.balance":"Saldo","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Valor","referrals":"Referidos","referrals-header.title":"Referidos","referrals-info-card.title.active-code":"Código de Referencia Activo","referrals-info-card.title.claimable-points":"Puntos Reclamables","referrals-info-card.title.points-earned":"Puntos Ganados","referrals-info-card.title.referrals-traders":"Comerciantes Referidos","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Los códigos de referencia son válidos solo en la red actual. Si deseas que tu código funcione en múltiples cadenas, tendrás que crear un código separado para cada una.","referrals.affiliates.header.code":"Código de Referencia","referrals.affiliates.header.create":"Crear","referrals.affiliates.header.title":"Código del Referido","referrals.affiliates.header.trader":"Comerciantes Referidos","referrals.affiliates.header.volume":"Total Volume","referrals.dialog.create.button":"Crear código","referrals.dialog.create.description-1":"Parece que no tienes un código de referencia para compartir.","referrals.dialog.create.description-2":"Crea uno ahora y comienza a ganar cashback!","referrals.dialog.create.error.claimed":"El código de referencia ya existe","referrals.dialog.create.input.label":"Introduce un código","referrals.dialog.create.input.placeholder":"Escribe tu código...","referrals.dialog.create.success":"El código ha sido creado con éxito.","referrals.dialog.create.title":"Crear código de referencia","referrals.dialog.error":"Ha ocurrido un error inesperado, por favor inténtalo de nuevo.","referrals.dialog.insert.button":"Introduce código de referencia","referrals.dialog.insert.description":"Por favor, introduce un código de referencia para beneficiarte de descuentos en comisiones.","referrals.dialog.insert.error.claimed":"Ya has reclamado un código","referrals.dialog.insert.error.not-exists":"El código de referencia no existe","referrals.dialog.insert.error.same-owner":"No puedes reclamar tu propio código","referrals.dialog.insert.input.label":"Introduce un código","referrals.dialog.insert.input.placeholder":"Introduce código de referencia...","referrals.dialog.insert.success":"El código ha sido ingresado con éxito.","referrals.dialog.insert.title":"Introduce código de referencia","referrals.text":"Invita a tus amigos a operar en AutoLayer y recibe una capa adicional de bonificaciones: AutoLayer Points adicionales para ti y tu amigo!","referrals.title":"AutoLayer Programa de Referidos","refferrals-tab-buttons-affiliates":"Afiliados","refferrals-tab-buttons-traders":"Comerciantes","restake":"Restake","reward-card.claim":"Reclamar","reward-card.points-gathered":"Tus puntos: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL utilizado como garantía","risk-box.dexes":"TVL as liquidity on dexes","select-position":"Seleccionar position","select-wallet-modal.connect-wallet":"Conectar billetera","select-wallet-modal.waiting.confirm":"Por favor, confirma la operación en tu billetera","select-wallet-modal.waiting.connecting":"Conectando a tu billetera","select-wallet-modal.waiting.signing":"Esperando la firma","share-link":"Copiar enlace","share-link-success":"Copiado","share-telegram":"Compartir en Telegram","share-twitter":"Compartir en X","stake":"Depositar","stake-banner.description":"Haz staking de tus LAY3R para ganar hasta un 35% de APY","stake-banner.title":"Staking de LAY3R","stake.banner.items.rewards":"Tus recompensas totales","stake.banner.items.total":"Total LAY3R en staking","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Tu staking","stake.banner.title":"Haz stake de LAY3R y gana recompensas","stake.max-available-amount":"Cantidad máxima para hacer stake: ","stake.staking-data.buttons.claim":"Reclamar recompensa","stake.staking-data.buttons.stake":"Stake recompensa","stake.staking-data.buttons.unstake":"Deshacer stake","stake.staking-data.compounding":"COMPONIENDO","stake.staking-data.days":"DÍAS","stake.staking-data.header.actions":"Acciones","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Capacidad","stake.staking-data.header.info":"Más información","stake.staking-data.header.lock-term":"Término de bloqueo","stake.staking-data.header.my-rewards":"Mis recompensas","stake.staking-data.header.my-stake":"Mi staking","stake.staking-data.header.pools":"Pools","stake.staking-data.title":"Pools Activos","stake.staking-dialog.stake.approved.error":"Aprobación de LAY3R no completada","stake.staking-dialog.stake.approved.loading":"Esperando aprobación","stake.staking-dialog.stake.approved.success":"Aprobación de LAY3R completada","stake.staking-dialog.stake.confirmation.error":"Confirmación cancelada","stake.staking-dialog.stake.confirmation.loading":"Esperando confirmación","stake.staking-dialog.stake.confirmation.success":"Confirmación completada","stake.staking-dialog.steps.done-claim":"Tus recompensas están en tu cartera","stake.staking-dialog.steps.done-restake":"Tus recompensas fueron restakeadas","stake.staking-dialog.steps.done-staking":"¡Los fondos fueron staked con éxito!","stake.staking-dialog.steps.done-unstaking":"Tus LAY3R están en tu cartera","start-inviting":"Comienza a Invitar","strategies":"Estrategias","subscribe":"Subscribirse","swap":"Swap","swap-from":"Swap desde","token-selector.deposit":"Depositar","token-selector.preview":"Estimación de swap","token-selector.withdraw":"Retirar","withdraw":"Retirar","your-portfolio":"Tu portafolio"}');
        ;// ./src/locales/zh.json
        const zh_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"在 {scan}上查看","after-withdrawal-you-receive":"提现后，您将收到您的钱包中 ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"跟踪所有 LRT airdrop 的状态，使用 AutoLayer Aidrop Tracker - 监控每个阶段，检查索赔是否开放，并立即访问索赔奖励的直接链接。","airdrop.title":"发现 AutoLayer Airdrop Tracker","announcement":"公告","apr":"APR","assets":"Assets","aubnb.banner.text":"BNB链生态系统的LRT的未来。","autolayer-info.points":"Autolayer 积分","autolayer-multiplier":"*AutoLayer* 倍增器","avs-info-box.incentives":"奖励","avs-info-box.staked":"重新质押的 TVL","avs-section.extended":"查看 *{n}* 更多","avs-section.hide":"隐藏","avs-section.title":"Actively Validated Services","back-to-dashboard":"返回仪表板","banner-info.title":"这个产品如何产生 Yields?","binace-network-notice":"*Note:* LRTs 不受官方支持在 BNB Chain上；因此 持有它们将不会对您的EigenLayer或或LRT points 产生贡献。然而，它将为您赚取AutoLayer points。","change-network":"更改网络","change-network-to":"切换您的网络到 ","change-to-arbitrum":"请切换到 Arbitrum 网络.","change-to-bsc":"切换到币安智能链","color-scheme.dark":"深色模式","color-scheme.light":"浅色模式","coming-soon":"即将推出","connect-wallet":"连接钱包","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"连接钱包","continue":"继续","copied-bubble.text":"已复制!","dashboard.autoLayer":"Autolayer 积分","dashboard.bedrock":"Bedrock 积分","dashboard.claystack":"ClayStack 积分","dashboard.defi-strategies":"DeFi 策略","dashboard.eigenLayer":"Eigenlayer 积分","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO 积分","dashboard.liquid-strategies":"重新抵押策略","dashboard.mellow":"Mellow 积分","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid staking","dashboard.other-points":"其他积分","dashboard.primestaked":"Prime 积分","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo 积分","dashboard.select-this-product":"选择此产品","dashboard.stake":"抵押","dashboard.swbtc":"Black Pearls 积分","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic 积分","dashboard.uni":"Uni 积分","dashboard.weeth":"Ether.fi 积分","dashboard.your-deposit":"您的存款","deposit-more":"存入更多","deposit-step-approving-token.done":"代币已批准.","deposit-step-approving-token.fail":"代币批准错误","deposit-step-approving-token.running":"等待代币批准...","deposit-step-getting-route.done":"获取用于交换的路线.","deposit-step-getting-route.fail":"获取路线时出错。请尝试其他代币。","deposit-step-getting-route.running":"获取用于交换的路线...","deposit-step-scan.link":"在  *{scan}* 上查看交易","deposit-step-sending-token.done":"操作完成。","deposit-step-sending-token.fail":"交换错误","deposit-step-sending-token.running":"等待操作确认","deposit-step-signing.done":"已签名.","deposit-step-signing.fail":"签名交易时出错.","deposit-step-signing.running":"等待签名","deposit.tx-points-earned":"通过此交易，您已赚取","details":"详情","disconnect":"断开连接","discontinued-notice.text":"Claystack即将关闭。请提取您的资产，并查看他们的{link}以获取更多详细信息。谢谢!","discontinued-notice.title":"项目终止","email-placeholder":"输入您的电子邮件地址","error":"错误","error-loading-data":"加载数据时出错","error-loading-tokens-balance":"加载代币余额时出错","error-loading-your-values":"加载您的值时出错","error.404-text":"抱歉，您请求的页面未找到","expand":"展开","footer.audited-by":"由...审计","footer.community.announcements":"公告","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram 群组","footer.community.title":"社区","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"关于我们","footer.company.blog":"博客","footer.company.title":"公司","footer.help.feed-back":"发送反馈","footer.help.support-docs":"支持文档","footer.help.talk-support":"与支持团队交流","footer.help.title":"帮助","footer.info.audit":"审计","footer.info.docs":"文档","footer.info.github":"Github","footer.info.media":"媒体工具包","footer.info.medium":"Medium","footer.info.title":"信息","footer.legacy":"传统访问 (Tortle Ninja)","footer.legal.privacy":"隐私政策","footer.legal.terms":"使用条款","footer.legal.title":"法律","footer.peckshield":"查看*PeckShield*审计","funds-wallet":"资金已存入您的钱包!","go-to-airdrop-checker.link":"这里","go-to-airdrop-checker.text":"现在点击 {here} 查看您的 LAY3R 分配情况.","go-to-position":"前往仓位","how-get-whitelisted":"如何获得白名单","ido-banner.text":"*$LAY3R IDO* 将在...启动 ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"交易量 (24h)","landing.hero-banner.text":"利用以太坊重质押的优势。","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"语言","language-selector.title":"选择语言","launch-button.default-text":"启动 dapp","launch-button.landing-hero-banner":"启动 AutoLayer","learn-more":"了解更多","left-point.actual-value":"实际价值","left-point.deposited":"已存款","left-point.restaking-rewards":"Restaking Rewards","left-point.staking-rewards":"Staking Rewards","left-points-fallback":"连接 *您的钱包* 以继续.","loading":"加载中...","loyalty-points":"忠诚积分","max":"最大","meta.airdrop.description":"使用 AutoLayer Airdrop Tracker 跟踪所有 LRT airdrops 的状态——监控每个阶段，检查是否开放领取，并立即访问直接链接领取奖励。🪂","meta.airdrop.title":"使用 AutoLayer Airdrop Tracker 领先一步!","meta.aubnb.description":"AuBNB 重新定义了 BNB Chain 上的 Liquid Restaked Tokens (LRTs)，提供顶级的 yields 和统一的 liquidity，可获得高达 52% APR 的 $LAY3R 奖励! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"最大的 restaking 市场，提供先进的 risk-reward analytics、积分管理和结构化产品。","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"每成功推荐一次，您和您的朋友都可以获得额外的 AutoLayer 积分奖励!","meta.referrals.title":"推荐好友并赚取 AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"更多即将推出","more-info":"更多信息","network":"网络","network-selector.actual":"实际网络","network-selector.title":"更改网络","placeholder.token-selector":"搜索代币...","pool-token-table.balance":"余额","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"美元价值","referrals":"推荐","referrals-header.title":"推荐","referrals-info-card.title.active-code":"有效推荐码","referrals-info-card.title.claimable-points":"可领取积分","referrals-info-card.title.points-earned":"已获得积分","referrals-info-card.title.referrals-traders":"推荐交易者","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"推荐码仅在当前网络上有效。如果您希望代码在多个链上使用，您需要为每个链创建一个单独的代码。","referrals.affiliates.header.code":"推荐码","referrals.affiliates.header.create":"创建","referrals.affiliates.header.title":"推荐人的代码","referrals.affiliates.header.trader":"推荐交易者","referrals.affiliates.header.volume":"总交易量","referrals.dialog.create.button":"创建代码","referrals.dialog.create.description-1":"您似乎没有可分享的推荐码.","referrals.dialog.create.description-2":"立即创建并开始赚取返现!","referrals.dialog.create.error.claimed":"推荐码已存在","referrals.dialog.create.input.label":"输入代码","referrals.dialog.create.input.placeholder":"输入您的代码...","referrals.dialog.create.success":"代码已成功创建.","referrals.dialog.create.title":"创建推荐码","referrals.dialog.error":"发生意外错误，请重试.","referrals.dialog.insert.button":"输入推荐码","referrals.dialog.insert.description":"请输入推荐码以享受佣金折扣.","referrals.dialog.insert.error.claimed":"已经领取了一个代码","referrals.dialog.insert.error.not-exists":"推荐码不存在","referrals.dialog.insert.error.same-owner":"不能领取自己的代码","referrals.dialog.insert.input.label":"输入代码","referrals.dialog.insert.input.placeholder":"输入推荐码...","referrals.dialog.insert.success":"代码已成功输入.","referrals.dialog.insert.title":"介绍推荐码","referrals.text":"邀请您的朋友在 AutoLayer 上交易，并获得额外的奖励层：您和您的朋友都能获得额外的 AutoLayer 积分!","referrals.title":"AutoLayer 推荐计划","refferrals-tab-buttons-affiliates":"联盟","refferrals-tab-buttons-traders":"交易者","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"您的points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL 作为抵押品使用","risk-box.dexes":"TVL 作为去中心化交易所上的流动性","select-position":"选择position","select-wallet-modal.connect-wallet":"连接钱包","select-wallet-modal.waiting.confirm":"请在您的钱包上确认操作","select-wallet-modal.waiting.connecting":"连接到您的钱包","select-wallet-modal.waiting.signing":"等待签名","share-link":"复制链接","share-link-success":"已复制","share-telegram":"在Telegram上分享","share-twitter":"在X上分享","stake":"抵押","stake-banner.description":"质押您的 LAY3R 并赚取高达 35% APY","stake-banner.title":"LAY3R Staking","stake.banner.items.rewards":"您的总奖励","stake.banner.items.total":"总共 LAY3R 在 staking","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"您的 stake","stake.banner.title":"Stake LAY3R 并赚取奖励","stake.max-available-amount":"可用的最大质押金额：","stake.staking-data.buttons.claim":"领取奖励","stake.staking-data.buttons.stake":"Stake 奖励","stake.staking-data.buttons.unstake":"解除 stake","stake.staking-data.compounding":"复利","stake.staking-data.days":"天","stake.staking-data.header.actions":"操作","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"容量","stake.staking-data.header.info":"更多信息","stake.staking-data.header.lock-term":"锁定期限","stake.staking-data.header.my-rewards":"我的奖励","stake.staking-data.header.my-stake":"我的 stake","stake.staking-data.header.pools":"池子","stake.staking-data.title":"活跃池子","stake.staking-dialog.stake.approved.error":"LAY3R 批准未完成","stake.staking-dialog.stake.approved.loading":"等待批准","stake.staking-dialog.stake.approved.success":"LAY3R 批准完成","stake.staking-dialog.stake.confirmation.error":"确认已取消","stake.staking-dialog.stake.confirmation.loading":"等待确认","stake.staking-dialog.stake.confirmation.success":"确认完成","stake.staking-dialog.steps.done-claim":"您的奖励已进入钱包","stake.staking-dialog.steps.done-restake":"您的奖励已重新 stake","stake.staking-dialog.steps.done-staking":"资金已成功 stake！","stake.staking-dialog.steps.done-unstaking":"您的 LAY3R 已进入钱包","start-inviting":"开始邀请","strategies":"策略","subscribe":"订阅","swap":"交换","swap-from":"从...交换","token-selector.deposit":"存款","token-selector.preview":"估算","token-selector.withdraw":"撤回","withdraw":"提现","your-portfolio":"您的投资组合"}');
        ;// ./src/locales/ko.json
        const ko_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"{scan}에서 보기","after-withdrawal-you-receive":"출금 후 당신의 지갑으로 받게 됩니다. ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"AutoLayer Airdrop Tracker를 사용하여 모든 LRT airdrop 의 상태를 추적하세요 - 각 단계를 모니터링하고 청구가 열렸는지 확인하며 보상을 즉시 청구할 수 있는 직접 링크에 액세스하세요.","airdrop.title":"AutoLayer Airdrop Tracker를 발견하세요","announcement":"공지사항","apr":"APR","assets":"Assets","aubnb.banner.text":"BNB 체인 생태계를 위한 LRT의 미래.","autolayer-info.points":"Autolayer 포인트","autolayer-multiplier":"*AutoLayer* 멀티플라이어","avs-info-box.incentives":"인센티브","avs-info-box.staked":"재스테이킹된 TVL","avs-section.extended":"*{n}* 더 보기","avs-section.hide":"숨기기","avs-section.title":"Actively Validated Services","back-to-dashboard":"대시보드로 돌아가기","banner-info.title":"이 제품이 Yields어떻게 생성하나요?","binace-network-notice":"*Note:* LRT는 BNB Chain에서 공식적으로 지원되지 않으므로, 보유하더라도 EigenLayer나 LRT points에 기여하지 않습니다. 하지만 AutoLayer points를 부여합니다.","change-network":"네트워크 변경","change-network-to":"네트워크를 다음으로 전환하세요: ","change-to-arbitrum":"Arbitrum 네트워크로 전환해주세요.","change-to-bsc":"화이트리스트에 등록하는 방법","color-scheme.dark":"다크 모드","color-scheme.light":"라이트 모드","coming-soon":"곧 출시 예정","connect-wallet":"지갑 연결","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"지갑 연결","continue":"계속","copied-bubble.text":"복사됨!","dashboard.autoLayer":"Autolayer 포인트","dashboard.bedrock":"Bedrock 포인트","dashboard.claystack":"ClayStack 포인트","dashboard.defi-strategies":"DeFi 전략","dashboard.eigenLayer":"Eigenlayer 포인트","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO 포인트","dashboard.liquid-strategies":"Restaking Strategies","dashboard.mellow":"Mellow 포인트","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid Staking","dashboard.other-points":"다른 포인트","dashboard.primestaked":"Prime 포인트","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo 포인트","dashboard.select-this-product":"이 제품 선택","dashboard.stake":"스테이크","dashboard.swbtc":"Black Pearls 포인트","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic 포인트","dashboard.uni":"Uni 포인트","dashboard.weeth":"Ether.fi 포인트","dashboard.your-deposit":"귀하의 예금","deposit-more":"더 입금하기","deposit-step-approving-token.done":"토큰 승인됨.","deposit-step-approving-token.fail":"토큰 승인 오류","deposit-step-approving-token.running":"토큰 승인 대기 중...","deposit-step-getting-route.done":"스왑을 위한 경로를 받았습니다.","deposit-step-getting-route.fail":"경로 가져오기 오류. 다른 토큰을 시도하세요.","deposit-step-getting-route.running":"스왑을 위한 경로 가져오기 중...","deposit-step-scan.link":"*{scan}*에서 거래 보기","deposit-step-sending-token.done":"작업 완료.","deposit-step-sending-token.fail":"스왑 오류","deposit-step-sending-token.running":"작업 확인 대기 중","deposit-step-signing.done":"서명됨.","deposit-step-signing.fail":"거래 서명 오류.","deposit-step-signing.running":"서명 대기 중","deposit.tx-points-earned":"이 거래로 수익을 올렸습니다","details":"세부 정보","disconnect":"연결 해제","discontinued-notice.text":"Claystack이 종료됩니다. 자산을 인출하시고 자세한 내용은 {link} 를 확인해 주세요. 감사합니다!","discontinued-notice.title":"프로젝트 중단.","email-placeholder":"이메일 주소 입력","error":"오류","error-loading-data":"데이터 로드 오류","error-loading-tokens-balance":"토큰 잔액 로드 오류","error-loading-your-values":"값 로드 오류","error.404-text":"죄송합니다. 요청하신 페이지를 찾을 수 없습니다","expand":"확장","footer.audited-by":"감사한 검토","footer.community.announcements":"공지","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram 그룹","footer.community.title":"커뮤니티","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"회사 소개","footer.company.blog":"블로그","footer.company.title":"회사","footer.help.feed-back":"피드백 보내기","footer.help.support-docs":"지원 문서","footer.help.talk-support":"지원팀과 대화하기","footer.help.title":"도움말","footer.info.audit":"감사","footer.info.docs":"문서","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"정보","footer.legacy":"레거시 액세스 (Tortle Ninja)","footer.legal.privacy":"개인정보 정책","footer.legal.terms":"이용 약관","footer.legal.title":"법적","footer.peckshield":" *PeckShield* 감사 확인","funds-wallet":"자금이 당신의 지갑에 있습니다!","go-to-airdrop-checker.link":"여기","go-to-airdrop-checker.text":"{here}를 클릭하여 지금 LAY3R 할당량을 확인하세요.","go-to-position":"포지션으로 이동","how-get-whitelisted":"화이트리스트에 등록하는 방법","ido-banner.text":"*$LAY3R IDO*가 시작됩니다. ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"거래량 (24h)","landing.hero-banner.text":"이더리움 재스테이킹의 이점을 활용하세요.","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"언어","language-selector.title":"언어 선택","launch-button.default-text":"Dapp 시작","launch-button.landing-hero-banner":"AutoLayer 시작","learn-more":"더 알아보기","left-point.actual-value":"실제 가","left-point.deposited":"예금된 금액","left-point.restaking-rewards":"Restaking Rewards","left-point.staking-rewards":"Staking Rewards","left-points-fallback":"*당신의 지갑*을 연결하여 계속 진행하세요.","loading":"로딩 중...","loyalty-points":"충성 포인트","max":"최대","meta.airdrop.description":"AutoLayer Airdrop Tracker를 사용하여 모든 LRT airdrops의 상태를 모니터링하세요. 각 단계를 추적하고 청구 가능 여부를 확인하며, 보상을 즉시 청구할 수 있는 직접 링크에 접근하세요.🪂","meta.airdrop.title":"AutoLayer Airdrop Tracker로 앞서 나가세요!","meta.aubnb.description":"AuBNB는 최고 수준의 yields와 통합된 liquidity를 통해 BNB Chain의 Liquid Restaked Tokens (LRTs)를 재정의하며, 최대 52% APR의 $LAY3R 보상을 제공합니다! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"고급 risk-reward analytics, 포인트 관리, 그리고 구조화된 상품을 갖춘 가장 큰 restaking 마켓플레이스.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"성공적인 추천마다 당신과 친구 모두에게 보너스 AutoLayer 포인트를 획득하세요!","meta.referrals.title":"친구를 추천하고 AutoLayer Points를 획득하세요!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"더 많은 내용, 곧 찾아옵니다","more-info":"더 많은 정보","network":"네트워크","network-selector.actual":"실제 네트워크","network-selector.title":"네트워크 변경","placeholder.token-selector":"토큰 검색...","pool-token-table.balance":"잔고","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"미국 달러 가치","referrals":"추천인","referrals-header.title":"추천인","referrals-info-card.title.active-code":"활성화된 추천인 코드","referrals-info-card.title.claimable-points":"청구 가능한 포인트","referrals-info-card.title.points-earned":"획득한 포인트","referrals-info-card.title.referrals-traders":"추천인 거래자","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"추천 코드는 현재 네트워크에서만 유효합니다. 여러 체인에서 코드를 사용하려면 각각의 체인에 대해 별도의 코드를 생성해야 합니다.","referrals.affiliates.header.code":"추천 코드","referrals.affiliates.header.create":"생성","referrals.affiliates.header.title":"추천인의 코드","referrals.affiliates.header.trader":"추천 거래자","referrals.affiliates.header.volume":"총 거래량","referrals.dialog.create.button":"코드 생성","referrals.dialog.create.description-1":"공유할 추천인 코드가 없는 것 같습니다..","referrals.dialog.create.description-2":"지금 생성하고 캐시백을 받기 시작하세요.!","referrals.dialog.create.error.claimed":"추천 코드가 이미 존재합니다","referrals.dialog.create.input.label":"코드를 입력하세요","referrals.dialog.create.input.placeholder":"코드를 입력하세요...","referrals.dialog.create.success":"코드가 성공적으로 생성되었습니다.","referrals.dialog.create.title":"추천인 코드 생성","referrals.dialog.error":"예기치 않은 오류가 발생했습니다. 다시 시도해 주세요.","referrals.dialog.insert.button":"추천인 코드 입력","referrals.dialog.insert.description":"커미션 할인 혜택을 받으려면 추천인 코드를 입력하세요..","referrals.dialog.insert.error.claimed":"이미 코드를 청구했습니다","referrals.dialog.insert.error.not-exists":"추천 코드가 존재하지 않습니다","referrals.dialog.insert.error.same-owner":"자신의 코드를 청구할 수 없습니다","referrals.dialog.insert.input.label":"코드를 입력하세요","referrals.dialog.insert.input.placeholder":"추천인 코드 입력...","referrals.dialog.insert.success":"코드가 성공적으로 입력되었습니다.","referrals.dialog.insert.title":"추천인 코드 소개","referrals.text":"친구를 AutoLayer에서 거래하도록 초대하고 추가 보너스를 받으세요: 당신과 친구에게 추가적인 AutoLayer 포인트를 드립니다!","referrals.title":"AutoLayer 추천 프로그램","refferrals-tab-buttons-affiliates":"제휴사","refferrals-tab-buttons-traders":"거래자","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"당신의 points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL을 담보로 사용","risk-box.dexes":"TVL을 dexes의 유동성으로 사용","select-position":"Position 선택","select-wallet-modal.connect-wallet":"지갑 연결","select-wallet-modal.waiting.confirm":"지갑에서 작업을 확인하세요","select-wallet-modal.waiting.connecting":"지갑에 연결 중","select-wallet-modal.waiting.signing":"서명 대기 중","share-link":"링크 복사","share-link-success":"복사됨","share-telegram":"텔레그램에서 공유","share-twitter":"X에 공유","stake":"스테이크","stake-banner.description":"LAY3R를 스테이킹하여 최대 35% APY를 얻으세요.","stake-banner.title":"LAY3R 스테이킹","stake.banner.items.rewards":"총 보상","stake.banner.items.total":"총 LAY3R 스테이킹","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"내 스테이킹","stake.banner.title":"LAY3R을 스테이킹하고 보상을 받으세요","stake.max-available-amount":"[ko] Max available amount to stake: ","stake.staking-data.buttons.claim":"보상 받기","stake.staking-data.buttons.stake":"Stake 보상","stake.staking-data.buttons.unstake":"언스테이킹","stake.staking-data.compounding":"복리","stake.staking-data.days":"일","stake.staking-data.header.actions":"동작","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"용량","stake.staking-data.header.info":"자세히 보기","stake.staking-data.header.lock-term":"잠금 기간","stake.staking-data.header.my-rewards":"내 보상","stake.staking-data.header.my-stake":"내 스테이킹","stake.staking-data.header.pools":"풀","stake.staking-data.title":"활성 풀","stake.staking-dialog.stake.approved.error":"LAY3R 승인이 완료되지 않았습니다","stake.staking-dialog.stake.approved.loading":"승인 대기 중","stake.staking-dialog.stake.approved.success":"LAY3R 승인이 완료되었습니다","stake.staking-dialog.stake.confirmation.error":"확인이 취소되었습니다","stake.staking-dialog.stake.confirmation.loading":"확인 대기 중","stake.staking-dialog.stake.confirmation.success":"확인이 완료되었습니다","stake.staking-dialog.steps.done-claim":"보상이 지갑에 들어왔습니다","stake.staking-dialog.steps.done-restake":"보상이 재스테이킹되었습니다","stake.staking-dialog.steps.done-staking":"자금이 성공적으로 스테이킹되었습니다!","stake.staking-dialog.steps.done-unstaking":"LAY3R가 지갑에 들어왔습니다","start-inviting":"초대를 시작하세요","strategies":"전략","subscribe":"구독","swap":"스왑","swap-from":"스왑 전송","token-selector.deposit":"예금","token-selector.preview":"추정","token-selector.withdraw":"출금하십시오.","withdraw":"출금","your-portfolio":"당신의 포트폴리오"}');
        ;// ./src/locales/vi.json
        const vi_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"Xem trên {scan}","after-withdrawal-you-receive":"Sau khi rút, bạn sẽ nhận được trong ví của mình. ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Giữ theo dõi tình trạng của tất cả LRT airdropssử dụng AutoLayer\'s Airdrop Tracker- theo dõi từng giai đoạn, kiểm tra xem việc đòi được mở hay không, và truy cập các liên kết trực tiếp để đòi phần thưởng của bạn ngay lập tức.","airdrop.title":"Discover AutoLayer Airdrop Tracker","announcement":"Thông báo","apr":"APR","assets":"Assets","aubnb.banner.text":"Tương lai của LRTs cho hệ sinh thái chuỗi BNB.","autolayer-info.points":"Điểm Autolayer","autolayer-multiplier":"Bội số *AutoLayer*","avs-info-box.incentives":"Khuyến khích","avs-info-box.staked":"TVL đã được tái đặt cọc","avs-section.extended":"Xem *{n}* thêm","avs-section.hide":"Ẩn","avs-section.title":"Actively Validated Services","back-to-dashboard":"Quay lại bảng điều khiển","banner-info.title":"Cách sản phẩm này tạo ra Yields là như thế nào?","binace-network-notice":"*Note:* LRTs không được hỗ trợ chính thức trên BNB Chain;do đó, việc giữ chúng sẽ không đóng góp vào EigenLayer hoặc LRT points của bạn. Tuy nhiên, nó sẽ mang lại cho bạn AutoLayer points.","change-network":"Thay đổi mạng","change-network-to":"Chuyển mạng của bạn sang ","change-to-arbitrum":"Vui lòng chuyển sang mạng Arbitrum.","change-to-bsc":"Chuyển sang Binance Smart Chain","color-scheme.dark":"Chế độ tối","color-scheme.light":"Chế độ sáng","coming-soon":"Sắp ra mắt","connect-wallet":"Kết nối Ví","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Kết nối Ví","continue":"Tiếp tục","copied-bubble.text":"Đã sao chép!","dashboard.autoLayer":"Điểm Autolayer","dashboard.bedrock":"Điểm Bedrock","dashboard.claystack":"Điểm  ClayStack","dashboard.defi-strategies":"Chiến lược DeFi","dashboard.eigenLayer":"Điểm Eigenlayer","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Điểm Kelp DAO","dashboard.liquid-strategies":"Chiến lược Restaking","dashboard.mellow":"Mellow Điểm","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid staking","dashboard.other-points":"Những điểm khác","dashboard.primestaked":"Điểm Prime","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Điểm Renzo","dashboard.select-this-product":"Chọn sản phẩm này","dashboard.stake":"Đặt cược","dashboard.swbtc":"Điểm Black Pearls","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic Điểm","dashboard.uni":"Điểm Uni","dashboard.weeth":"Điểm Ether.fi","dashboard.your-deposit":"Số tiền đặt cược của bạn","deposit-more":"Nạp thêm","deposit-step-approving-token.done":"Token đã được phê duyệt.","deposit-step-approving-token.fail":"Lỗi phê duyệt token","deposit-step-approving-token.running":"Đang chờ phê duyệt token...","deposit-step-getting-route.done":"Nhận được tuyến đường cho việc đổi.","deposit-step-getting-route.fail":"Lỗi khi nhận tuyến đường. Hãy thử một token khác.","deposit-step-getting-route.running":"Đang nhận tuyến đường để đổi...","deposit-step-scan.link":"Xem giao dịch trên *{scan}*","deposit-step-sending-token.done":"Hoạt động đã hoàn tất.","deposit-step-sending-token.fail":"Lỗi khi đổi","deposit-step-sending-token.running":"Đang chờ xác nhận hoạt động","deposit-step-signing.done":"Đã ký.","deposit-step-signing.fail":"Lỗi khi ký giao dịch.","deposit-step-signing.running":"Đang chờ ký","deposit.tx-points-earned":"Với giao dịch này, bạn đã kiếm được","details":"Chi tiết","disconnect":"Ngắt kết nối","discontinued-notice.text":"Claystack đang đóng cửa. Vui lòng rút tài sản của bạn và kiểm tra {link} của họ để biết thêm chi tiết. Cảm ơn bạn!","discontinued-notice.title":"Dự án đã ngừng phát triển.","email-placeholder":"Nhập địa chỉ email của bạn","error":"Lỗi","error-loading-data":"Lỗi khi tải dữ liệu","error-loading-tokens-balance":"Lỗi khi tải số dư token","error-loading-your-values":"Lỗi khi tải giá trị của bạn","error.404-text":"Xin lỗi, trang bạn yêu cầu không được tìm thấy","expand":"Mở rộng","footer.audited-by":"Được kiểm định bởi","footer.community.announcements":"Thông báo","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Nhóm Telegram","footer.community.title":"Cộng đồng","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"Về chúng tôi","footer.company.blog":"Blog","footer.company.title":"Công ty","footer.help.feed-back":"Gửi Phản hồi","footer.help.support-docs":"Tài liệu Hỗ trợ","footer.help.talk-support":"Nói chuyện với bộ phận hỗ trợ","footer.help.title":"Trợ giúp","footer.info.audit":"Kiểm định","footer.info.docs":"Tài liệu","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"Thông tin","footer.legacy":"Truy cập theo dõi  (Tortle Ninja)","footer.legal.privacy":"Chính sách bảo mật","footer.legal.terms":"Điều khoản sử dụng","footer.legal.title":"Pháp lý","footer.peckshield":"Kiểm tra kiểm định của *PeckShield*","funds-wallet":"Quỹ đã ở trong ví của bạn!","go-to-airdrop-checker.link":"Đây","go-to-airdrop-checker.text":"Kiểm tra phân bổ LAY3R của bạn ngay bây giờ bằng cách nhấp vào {here}.","go-to-position":"Đi đến vị trí","how-get-whitelisted":"Cách để được vào danh sách trắng","ido-banner.text":"*$LAY3R IDO* sẽ ra mắt trong ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Thể tích (24h)","landing.hero-banner.text":"Tận dụng các lợi ích của việc Re-Staking Ethereum","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Ngôn ngữ","language-selector.title":"Chọn ngôn ngữ","launch-button.default-text":"Khởi chạy dapp","launch-button.landing-hero-banner":"Khởi chạy AutoLayer","learn-more":"Tìm hiểu thêm","left-point.actual-value":"Giá trị Thực tế","left-point.deposited":"Đã Gửi","left-point.restaking-rewards":" Phần thưởng Restaking","left-point.staking-rewards":" Phần thưởng Staking","left-points-fallback":"Kết nối *ví của bạn* để tiếp tục.","loading":"Đang tải...","loyalty-points":"Điểm Trung thành","max":"Tối đa","meta.airdrop.description":"Theo dõi trạng thái của tất cả các LRT airdrops bằng cách sử dụng Airdrop Tracker của AutoLayer - theo dõi từng giai đoạn, kiểm tra xem các yêu cầu có mở không và truy cập các liên kết trực tiếp để yêu cầu phần thưởng của bạn ngay lập tức.🪂","meta.airdrop.title":"Dẫn đầu với AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB tái định nghĩa Liquid Restaked Tokens (LRTs) trên BNB Chain với yields hàng đầu và liquidity thống nhất, cung cấp lên đến 52% APR trong $LAY3R rewards! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Thị trường restaking lớn nhất với phân tích risk-reward tiên tiến, quản lý điểm, và các sản phẩm có cấu trúc.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Kiếm Bonus AutoLayer Points cho cả bạn và bạn của bạn với mỗi lần giới thiệu thành công!","meta.referrals.title":"Giới thiệu bạn bè và kiếm AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Sắp có thêm","more-info":"Thông tin thêm","network":"Mạng","network-selector.actual":"Mạng Hiện tại","network-selector.title":"Thay đổi Mạng","placeholder.token-selector":"Tìm kiếm Token...","pool-token-table.balance":"Số dư","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Giá trị USD","referrals":"Giới thiệu","referrals-header.title":"Giới thiệu","referrals-info-card.title.active-code":"Mã Giới Thiệu Hoạt Động","referrals-info-card.title.claimable-points":"Điểm Có Thể Được Yêu Cầu","referrals-info-card.title.points-earned":"Điểm Đã Kiếm Được","referrals-info-card.title.referrals-traders":"Các Nhà Giao Dịch Giới Thiệu","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Mã giới thiệu chỉ hợp lệ trên mạng hiện tại. Nếu bạn muốn mã của bạn hoạt động trên nhiều chuỗi, bạn sẽ cần tạo mã riêng cho mỗi chuỗi","referrals.affiliates.header.code":"Mã Giới Thiệu","referrals.affiliates.header.create":"Tạo","referrals.affiliates.header.title":"Mã của Người Giới Thiệu","referrals.affiliates.header.trader":"Các Nhà Giao Dịch Giới Thiệu","referrals.affiliates.header.volume":"Tổng Khối Lượng","referrals.dialog.create.button":"Tạo mã","referrals.dialog.create.description-1":"Có vẻ như bạn không có mã giới thiệu để chia sẻ.","referrals.dialog.create.description-2":"Tạo ngay một mã và bắt đầu kiếm tiền hoàn lại!","referrals.dialog.create.error.claimed":"Mã giới thiệu đã tồn tại","referrals.dialog.create.input.label":"Nhập mã","referrals.dialog.create.input.placeholder":"Nhập mã của bạn...","referrals.dialog.create.success":"Mã đã được tạo thành công.","referrals.dialog.create.title":"Tạo mã giới thiệu","referrals.dialog.error":"Đã xảy ra lỗi không mong muốn, vui lòng thử lại.","referrals.dialog.insert.button":"Nhập mã giới thiệu","referrals.dialog.insert.description":"Vui lòng nhập mã giới thiệu để được hưởng chiết khấu hoa hồng.","referrals.dialog.insert.error.claimed":"Đã yêu cầu mã","referrals.dialog.insert.error.not-exists":"Mã giới thiệu không tồn tại","referrals.dialog.insert.error.same-owner":"Không thể yêu cầu mã của chính bạn","referrals.dialog.insert.input.label":"Nhập mã","referrals.dialog.insert.input.placeholder":"Nhập mã giới thiệu...","referrals.dialog.insert.success":"Mã đã được nhập thành công.","referrals.dialog.insert.title":"Giới thiệu mã giới thiệu","referrals.text":"Mời bạn bè của bạn giao dịch trên AutoLayer và nhận thêm một lớp thưởng: AutoLayer Points bổ sung cho bạn và bạn của bạn!","referrals.title":"Chương Trình Giới Thiệu AutoLayer.","refferrals-tab-buttons-affiliates":"Đối Tác","refferrals-tab-buttons-traders":"Nhà Giao Dịch","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Points của bạn: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL được sử dụng làm tài sản thế chấp","risk-box.dexes":"TVL như liquidity trên các sàn DEX","select-position":"Chọn position","select-wallet-modal.connect-wallet":"Kết nối Ví","select-wallet-modal.waiting.confirm":"Vui lòng xác nhận thao tác trên ví của bạn","select-wallet-modal.waiting.connecting":"Đang kết nối đến ví của bạn","select-wallet-modal.waiting.signing":"Đang chờ chữ ký","share-link":"Copy Link","share-link-success":"Copied","share-telegram":"Share on Telegram","share-twitter":"Share on X","stake":"Đặt cược","stake-banner.description":"Stake LAY3R của bạn để kiếm lợi suất lên đến 35% APY.","stake-banner.title":"LAY3R Staking","stake.banner.items.rewards":"Tổng phần thưởng của bạn","stake.banner.items.total":"Tổng LAY3R đã stake","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Stake của bạn","stake.banner.title":"Stake LAY3R và nhận phần thưởng","stake.max-available-amount":"Số tiền tối đa có thể stake: ","stake.staking-data.buttons.claim":"Nhận phần thưởng","stake.staking-data.buttons.stake":"Stake phần thưởng","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"LÃI KÉP","stake.staking-data.days":"NGÀY","stake.staking-data.header.actions":"Hành động","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Dung lượng","stake.staking-data.header.info":"Thông tin thêm","stake.staking-data.header.lock-term":"Thời gian khóa","stake.staking-data.header.my-rewards":"Phần thưởng của tôi","stake.staking-data.header.my-stake":"Stake của tôi","stake.staking-data.header.pools":"Pools","stake.staking-data.title":"Pools Hoạt động","stake.staking-dialog.stake.approved.error":"Phê duyệt LAY3R chưa hoàn thành","stake.staking-dialog.stake.approved.loading":"Đang chờ phê duyệt","stake.staking-dialog.stake.approved.success":"Phê duyệt LAY3R đã hoàn thành","stake.staking-dialog.stake.confirmation.error":"Xác nhận đã bị hủy","stake.staking-dialog.stake.confirmation.loading":"Đang chờ xác nhận","stake.staking-dialog.stake.confirmation.success":"Xác nhận đã hoàn thành","stake.staking-dialog.steps.done-claim":"Phần thưởng của bạn đã có trong ví","stake.staking-dialog.steps.done-restake":"Phần thưởng của bạn đã được restake","stake.staking-dialog.steps.done-staking":"Quỹ đã được stake thành công!","stake.staking-dialog.steps.done-unstaking":"LAY3R của bạn đã có trong ví","start-inviting":"Bắt Đầu Mời","strategies":"Chiến lược","subscribe":"Đăng ký","swap":"Trao đổi","swap-from":"Trao đổi từ","token-selector.deposit":"Gửi tiền","token-selector.preview":"Ước tính","token-selector.withdraw":"Rút tiền","withdraw":"Rút tiền","your-portfolio":"danh mục đầu tư của bạn"}');
        ;// ./src/locales/uk.json
        const uk_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"{scan}Переглянути на ","after-withdrawal-you-receive":"Після зняття ви отримаєте на свій гаманець ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Слідкуйте за статусом всіх LRT airdropsза допомогою AutoLayer\'s Airdrop Tracker - відстежуйте кожну фазу, перевіряйте, чи відкриті претензії, та отримуйте прямі посилання для миттєвого отримання нагород.","airdrop.title":"Дізнайтеся більше про AutoLayer Airdrop Tracker","announcement":"Оголошення","apr":"APR","assets":"Assets","aubnb.banner.text":"Майбутнє LRT для екосистеми ланцюга BNB.","autolayer-info.points":"Бали Autolayer","autolayer-multiplier":"Множник *AutoLayer*","avs-info-box.incentives":"Інцентиви","avs-info-box.staked":"Рестейканий TVL","avs-section.extended":"Показати ще *{n}*","avs-section.hide":"Приховати","avs-section.title":"Actively Validated Services","back-to-dashboard":"Назад до панелі інструментів","banner-info.title":"Як цей продукт генерує Yields?","binace-network-notice":"*Note:* LRT\'ler BNB Chain\'nde resmi olarak desteklenmiyor; bu nedenle, onları tutmak EigenLayer veya LRT points\'a katkıda bulunmayacaktır. Ancak, size AutoLayer points kazandıracaktır.","change-network":"Змінити мережу","change-network-to":"Перемкніть свою мережу на ","change-to-arbitrum":"Будь ласка, перемкніться на мережу Arbitrum.","change-to-bsc":"Перейти на Binance Smart Chain","color-scheme.dark":"Темний режим","color-scheme.light":"Світлий режим","coming-soon":"Незабаром","connect-wallet":"Підключити гаманець","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Підключити гаманець","continue":"Продовжити","copied-bubble.text":"Скопійовано!","dashboard.autoLayer":"Бали Autolayer","dashboard.bedrock":"Бали Bedrock","dashboard.claystack":"Бали ClayStack","dashboard.defi-strategies":"Стратегії DeFi","dashboard.eigenLayer":"Бали Eigenlayer","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Бали Kelp DAO","dashboard.liquid-strategies":"Стратегії Restaking","dashboard.mellow":"Mellow Бали","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid staking","dashboard.other-points":"Інші бали","dashboard.primestaked":"Бали Prime","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Бали Renzo","dashboard.select-this-product":"Вибрати цей продукт","dashboard.stake":"Укласти ставку","dashboard.swbtc":"Black Pearls Бали","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic Бали","dashboard.uni":"Бали Uni","dashboard.weeth":"Бали Ether.fi","dashboard.your-deposit":"Ваш депозит","deposit-more":"Внести ще","deposit-step-approving-token.done":"Токен схвалено.","deposit-step-approving-token.fail":"Помилка схвалення токену","deposit-step-approving-token.running":"Очікування на схвалення токену...","deposit-step-getting-route.done":"Отримано маршрут для обміну.","deposit-step-getting-route.fail":"Помилка отримання маршруту. Спробуйте інший токен.","deposit-step-getting-route.running":"Отримання маршруту для обміну...","deposit-step-scan.link":"Дивитися транзакцію на *{scan}*","deposit-step-sending-token.done":"Операція виконана.","deposit-step-sending-token.fail":"Помилка обміну","deposit-step-sending-token.running":"Очікування підтвердження операції","deposit-step-signing.done":"Підписано.","deposit-step-signing.fail":"Помилка підписання транзакції.","deposit-step-signing.running":"Очікування підпису","deposit.tx-points-earned":"З цією транзакцією ви заробили","details":"Деталі","disconnect":"Відключити","discontinued-notice.text":"Claystack закривається. Будь ласка, зніміть свої активи та перегляньте їх {link} для отримання додаткової інформації. Дякуємо!","discontinued-notice.title":"Проект припинено.","email-placeholder":"Введіть свою адресу електронної пошти","error":"Помилка","error-loading-data":"Помилка завантаження даних","error-loading-tokens-balance":"Помилка завантаження балансу токенів","error-loading-your-values":"Помилка завантаження ваших значень","error.404-text":"Вибачте, сторінку, яку ви запитали, не знайдено","expand":"Розгорнути","footer.audited-by":"Аудитовано","footer.community.announcements":"Оголошення","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram Group","footer.community.title":"Спільнота","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"Про нас","footer.company.blog":"Блог","footer.company.title":"Компанія","footer.help.feed-back":"Надіслати відгук","footer.help.support-docs":"Документація підтримки","footer.help.talk-support":"Звертайтеся до підтримки","footer.help.title":"Допомога","footer.info.audit":"Аудит","footer.info.docs":"Документи","footer.info.github":"Github","footer.info.media":"Медіа-кіт","footer.info.medium":"Medium","footer.info.title":"Інформація","footer.legacy":"Старий доступ  (Tortle Ninja)","footer.legal.privacy":"Політика конфіденційності","footer.legal.terms":"Умови використання","footer.legal.title":"Юридичні відомості","footer.peckshield":"Перевірте аудит *PeckShield*","funds-wallet":"Гроші в вашому гаманці!","go-to-airdrop-checker.link":"Тут","go-to-airdrop-checker.text":"Перевірте свою частку LAY3R зараз, натиснувши {here}.","go-to-position":"Перейти до позиції","how-get-whitelisted":"Як потрапити до білого списку","ido-banner.text":"*$LAY3R IDO* стартує через ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Обсяг (24h)","landing.hero-banner.text":"Використовуйте переваги повторного стейкінгу Ethereum","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Мова","language-selector.title":"Виберіть мову","launch-button.default-text":"Запуск додатка","launch-button.landing-hero-banner":"Запуск AutoLayer","learn-more":"Дізнатися більше","left-point.actual-value":"Фактична вартість","left-point.deposited":"Внесено","left-point.restaking-rewards":"Винагорода за Restaking","left-point.staking-rewards":"Винагорода за Staking","left-points-fallback":"Підключіть *ваш гаманець* для продовження.","loading":"Завантаження...","loyalty-points":"Бали лояльності","max":"Макс","meta.airdrop.description":"Слідкуйте за статусом всіх LRT airdrops за допомогою AutoLayer′s Airdrop Tracker - контролюйте кожну фазу, перевіряйте, чи відкриті заявки, і отримуйте прямі посилання для миттєвого отримання ваших винагород. 🪂","meta.airdrop.title":"Будьте попереду з AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB переосмислює Liquid Restaked Tokens (LRTs) на BNB Chain із найвищими yields і об’єднаною liquidity, пропонуючи до 52% APR у вигляді винагород $LAY3R! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Найбільший restaking ринок із розширеною risk-reward analytics, управлінням балами та структурованими продуктами.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Заробляйте бонусні AutoLayer Points для себе та вашого друга з кожним успішним рефералом!","meta.referrals.title":"Запрошуйте друзів і заробляйте AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Більше незабаром","more-info":"Докладніше","network":"Мережа","network-selector.actual":"Поточна мережа","network-selector.title":"Змінити мережу","placeholder.token-selector":"Пошук токена...","pool-token-table.balance":"Баланс","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Значення в USD","referrals":"Реферали","referrals-header.title":"Реферали","referrals-info-card.title.active-code":"Активний реферальний код","referrals-info-card.title.claimable-points":"Бали, що підлягають отриманню","referrals-info-card.title.points-earned":"Зараховані бали","referrals-info-card.title.referrals-traders":"Реферальні трейдери","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Реферальні коди дійсні лише в поточній мережі. Якщо ви хочете, щоб ваш код працював на кількох ланцюгах, вам потрібно створити окремий код для кожного з них","referrals.affiliates.header.code":"Реферальний код","referrals.affiliates.header.create":"Створити","referrals.affiliates.header.title":"Код реферала","referrals.affiliates.header.trader":"Реферальні трейдери","referrals.affiliates.header.volume":"Загальний обсяг","referrals.dialog.create.button":"Створити код","referrals.dialog.create.description-1":"Здається, у вас немає реферального коду для розподілу.","referrals.dialog.create.description-2":"Створіть один зараз і почніть заробляти кешбек!","referrals.dialog.create.error.claimed":"Реферальний код вже існує","referrals.dialog.create.input.label":"Введіть код","referrals.dialog.create.input.placeholder":"Введіть ваш код...","referrals.dialog.create.success":"Код було успішно створено.","referrals.dialog.create.title":"Створити реферальний код","referrals.dialog.error":"Сталася несподівана помилка, будь ласка, спробуйте ще раз.","referrals.dialog.insert.button":"Введіть реферальний код","referrals.dialog.insert.description":"Будь ласка, введіть реферальний код, щоб скористатися знижками на комісії.","referrals.dialog.insert.error.claimed":"Код вже був використаний","referrals.dialog.insert.error.not-exists":"Реферальний код не існує","referrals.dialog.insert.error.same-owner":"Не можна використати власний код","referrals.dialog.insert.input.label":"Введіть код","referrals.dialog.insert.input.placeholder":"Введіть реферальний код...","referrals.dialog.insert.success":"Код було успішно введено.","referrals.dialog.insert.title":"Введіть реферальний код","referrals.text":"Запрошуйте друзів торгувати на AutoLayer і отримуйте додатковий шар бонусів: Додаткові AutoLayer Points для вас і вашого друга!","referrals.title":"Реферальна програма AutoLayer","refferrals-tab-buttons-affiliates":"Партнери","refferrals-tab-buttons-traders":"Трейдери","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Ваші points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL teminat olarak kullanıldı","risk-box.dexes":"TVL, dexes\'te liquidity olarak kullanıldı","select-position":"Вибрати position","select-wallet-modal.connect-wallet":"Підключити гаманець","select-wallet-modal.waiting.confirm":"Будь ласка, підтвердіть операцію в своєму гаманці","select-wallet-modal.waiting.connecting":"Підключення до вашого гаманця","select-wallet-modal.waiting.signing":"Очікування підпису","share-link":"Скопіювати посилання","share-link-success":"Скопійовано","share-telegram":"Поділитися в Telegram","share-twitter":"Поділитися в X","stake":"Стейк","stake-banner.description":"Стейкайте свої LAY3R, щоб заробити до 35% річних (APY).","stake-banner.title":"LAY3R Стейкінг","stake.banner.items.rewards":"Ваші загальні винагороди","stake.banner.items.total":"Загальний LAY3R у стейкінгу","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Ваш стейк","stake.banner.title":"Stake LAY3R і заробляйте винагороди","stake.max-available-amount":"Максимальна доступна сума для стейкінгу: ","stake.staking-data.buttons.claim":"Забрати винагороду","stake.staking-data.buttons.stake":"Stake винагороду","stake.staking-data.buttons.unstake":"Розстейк","stake.staking-data.compounding":"КОМПОУНДИНГ","stake.staking-data.days":"ДНІ","stake.staking-data.header.actions":"Дії","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Місткість","stake.staking-data.header.info":"Більше інформації","stake.staking-data.header.lock-term":"Термін блокування","stake.staking-data.header.my-rewards":"Мої винагороди","stake.staking-data.header.my-stake":"Мій стейк","stake.staking-data.header.pools":"Пули","stake.staking-data.title":"Активні пули","stake.staking-dialog.stake.approved.error":"LAY3R схвалення не завершено","stake.staking-dialog.stake.approved.loading":"Очікування схвалення","stake.staking-dialog.stake.approved.success":"LAY3R схвалення завершено","stake.staking-dialog.stake.confirmation.error":"Підтвердження скасовано","stake.staking-dialog.stake.confirmation.loading":"Очікування підтвердження","stake.staking-dialog.stake.confirmation.success":"Підтвердження завершено","stake.staking-dialog.steps.done-claim":"Ваші винагороди у вашому гаманці","stake.staking-dialog.steps.done-restake":"Ваші винагороди були restake","stake.staking-dialog.steps.done-staking":"Кошти успішно стейковані!","stake.staking-dialog.steps.done-unstaking":"Ваші LAY3R у вашому гаманці","start-inviting":"Почніть запрошувати","strategies":"Стратегії","subscribe":"Підписатися","swap":"Обмін","swap-from":"Обмін","token-selector.deposit":"Депозит","token-selector.preview":"оцінка","token-selector.withdraw":"Зняти","withdraw":"Зняти","your-portfolio":"Ваш портфель"}');
        ;// ./src/locales/fr.json
        const fr_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"Voir sur {scan}","after-withdrawal-you-receive":"Après le retrait, vous recevrez dans votre portefeuille. ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Suivez l\'état de tous les LRT airdrops en utilisant le AutoLayer\'s Airdrop Tracker - surveillez chaque phase, vérifiez si les réclamations sont ouvertes et accédez aux liens directs pour réclamer vos récompenses instantanément.","airdrop.title":"Découvrez le AutoLayer Airdrop Tracker","announcement":"annonce","apr":"APR","assets":"Assets","aubnb.banner.text":"L\'avenir des LRTs pour l\'écosystème de la chaîne BNB.","autolayer-info.points":"Autolayer points","autolayer-multiplier":"Multiplicateur *AutoLayer*","avs-info-box.incentives":"Incitations","avs-info-box.staked":"TVL restaké","avs-section.extended":"Voir *{n}* de plus","avs-section.hide":"Cacher","avs-section.title":"Actively Validated Services","back-to-dashboard":"Retour au tableau de bord","banner-info.title":"Comment ce produit génère-t-il du Yields?","binace-network-notice":"*Note:* Les LRT ne sont pas officiellement pris en charge sur la BNB Chain; par conséquent, les détenir ne contribuera pas à vos points EigenLayerouLRT, Cependant, celavousaccorderadesAutoLayer points.","change-network":"Changer de réseau","change-network-to":"Changez votre réseau pour ","change-to-arbitrum":"Veuillez passer au réseau Arbitrum.","change-to-bsc":"Changer pour Binance Smart Chain","color-scheme.dark":"Mode sombre","color-scheme.light":"Mode clair","coming-soon":"Bientôt disponible","connect-wallet":"Connecter le portefeuille","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Connecter le portefeuille","continue":"Continuer","copied-bubble.text":"Copié !","dashboard.autoLayer":"Autolayer Points","dashboard.bedrock":"Points Bedrock","dashboard.claystack":"Points ClayStack","dashboard.defi-strategies":"Stratégies DeFi","dashboard.eigenLayer":"Eigenlayer Points","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Points Kelp DAO","dashboard.liquid-strategies":"Stratégies de Restaking","dashboard.mellow":"Mellow Points","dashboard.one-click-lrst":"Restaking Liquide en 1 clic","dashboard.one-click-restaking":"Staking Liquide en 1 clic","dashboard.other-points":"Autres Points","dashboard.primestaked":"Points Prime","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Points Renzo","dashboard.select-this-product":"Sélectionner ce produit","dashboard.stake":"Miser","dashboard.swbtc":"Black Pearls Points","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic Points","dashboard.uni":"Points Uni","dashboard.weeth":"Points Ether.fi","dashboard.your-deposit":"Votre Dépôt","deposit-more":"Déposer plus","deposit-step-approving-token.done":"Jeton approuvé.","deposit-step-approving-token.fail":"Erreur d\'approbation du jeton","deposit-step-approving-token.running":"En attente d\'approbation du jeton...","deposit-step-getting-route.done":"Obtenu la route pour l\'échange.","deposit-step-getting-route.fail":"Erreur lors de l\'obtention de la route. Essayez un autre jeton.","deposit-step-getting-route.running":"Obtention de la route pour l\'échange...","deposit-step-scan.link":"Voir la transaction sur  *{scan}*","deposit-step-sending-token.done":"Opération terminée.","deposit-step-sending-token.fail":"Erreur lors de l\'échange","deposit-step-sending-token.running":"En attente de confirmation de l\'opération","deposit-step-signing.done":"Signé.","deposit-step-signing.fail":"Erreur de signature de transaction.","deposit-step-signing.running":"En attente de signature","deposit.tx-points-earned":"Avec cette transaction, vous avez gagné","details":"Détails","disconnect":"Déconnecter","discontinued-notice.text":"Claystack ferme ses portes. Veuillez retirer vos actifs et consulter leur {link} pour plus de détails. Merci!","discontinued-notice.title":"Projet abandonné","email-placeholder":"Enter your email address","error":"Erreur","error-loading-data":"Erreur de chargement des données","error-loading-tokens-balance":"Erreur de chargement du solde","error-loading-your-values":"Erreur lors du chargement de vos valeurs","error.404-text":"Désolé, la page que vous avez demandée n\'a pas été trouvée","expand":"Développer","footer.audited-by":"Audité par","footer.community.announcements":"Annonces","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Groupe Telegram","footer.community.title":"Communauté","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"À Propos de Nous","footer.company.blog":"Blog","footer.company.title":"Société","footer.help.feed-back":"Envoyer des commentaires","footer.help.support-docs":"Documents de Support","footer.help.talk-support":"Discuter avec le support","footer.help.title":"Aide","footer.info.audit":"Audit","footer.info.docs":"Documents","footer.info.github":"Github","footer.info.media":"Kit Media","footer.info.medium":"Medium","footer.info.title":"Info","footer.legacy":"Accès Hérité  (Tortle Ninja)","footer.legal.privacy":"Politique de Confidentialité","footer.legal.terms":"Conditions d\'Utilisation","footer.legal.title":"Legal","footer.peckshield":"Vérifier l\'audit *PeckShield* ","funds-wallet":"Les fonds sont dans votre portefeuille !","go-to-airdrop-checker.link":"ici","go-to-airdrop-checker.text":"Vérifiez votre allocation de LAY3R maintenant en cliquant {here}.","go-to-position":"Aller à la position","how-get-whitelisted":"Comment être inscrit sur la liste blanche","ido-banner.text":"*$LAY3R IDO* se lance le ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Volume (24h)","landing.hero-banner.text":"Exploitez les avantages du restaking Ethereum.","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Langue","language-selector.title":"Sélectionnez la langue","launch-button.default-text":"Lancer dapp","launch-button.landing-hero-banner":"Lancer AutoLayer","learn-more":"En savoir plus","left-point.actual-value":"Valeur Actuelle","left-point.deposited":"Déposé","left-point.restaking-rewards":"Restaking Rewards","left-point.staking-rewards":"Staking Rewards","left-points-fallback":"Connectez *votre portefeuille* pour continuer.","loading":"Chargement...","loyalty-points":"Points de Fidélité","max":"Max","meta.airdrop.description":"Suivez l\'état de tous les LRT Airdrops en utilisant le AutoLayer Airdrop Tracker - surveillez chaque phase, vérifiez si les réclamations sont ouvertes et accédez à des liens directs pour réclamer vos récompenses instantanément.🪂","meta.airdrop.title":"Restez à jour avec le AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB redéfinit les Liquid Restaked Tokens (LRTs) sur la BNB Chain avec des yields élevés et une liquidity unifiée, offrant jusqu’à 52% APR en récompenses $LAY3R! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Le plus grand restaking marketplace avec des risk-reward analysis, une gestion des points, et des produits structurés.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Gagnez des bonus AutoLayer points pour vous et votre ami à chaque parrainage réussi!","meta.referrals.title":"Parrainez des amis et gagnez des AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Plus à venir prochainement","more-info":"Plus d\'informations","network":"Réseau","network-selector.actual":"Réseau Actuel","network-selector.title":"Changer de réseau","placeholder.token-selector":"Rechercher un Jeton...","pool-token-table.balance":"Solde","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Valeur en USD","referrals":"Parrainages","referrals-header.title":"Parrainages","referrals-info-card.title.active-code":"Code de parrainage actif","referrals-info-card.title.claimable-points":"Points réclamables","referrals-info-card.title.points-earned":"Points gagnés","referrals-info-card.title.referrals-traders":"Traders parrainés","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Les codes de parrainage sont valables uniquement sur le réseau actuel. Si vous souhaitez que votre code fonctionne sur plusieurs chaînes, vous devrez créer un code distinct pour chacune d\'elles.","referrals.affiliates.header.code":"Code de parrainage","referrals.affiliates.header.create":"Créer","referrals.affiliates.header.title":"Code du parrainage","referrals.affiliates.header.trader":"Traders parrainés","referrals.affiliates.header.volume":"Volume total","referrals.dialog.create.button":"Créer un code","referrals.dialog.create.description-1":"Il semble que vous n\'ayez pas de code de parrainage à partager.","referrals.dialog.create.description-2":"Créez-en un maintenant et commencez à gagner du cashback!","referrals.dialog.create.error.claimed":"Le code de parrainage existe déjà","referrals.dialog.create.input.label":"Entrez un code","referrals.dialog.create.input.placeholder":"Tapez votre code...","referrals.dialog.create.success":"Le code a été créé avec succès.","referrals.dialog.create.title":"Créer un code de parrainage","referrals.dialog.error":"Une erreur inattendue s\'est produite, veuillez réessayer.","referrals.dialog.insert.button":"Entrez le code de parrainage","referrals.dialog.insert.description":"Veuillez entrer un code de parrainage pour bénéficier de réductions sur les commissions.","referrals.dialog.insert.error.claimed":"Code déjà réclamé","referrals.dialog.insert.error.not-exists":"Le code de parrainage n\'existe pas","referrals.dialog.insert.error.same-owner":"Impossible de réclamer votre propre code","referrals.dialog.insert.input.label":"Entrez un code","referrals.dialog.insert.input.placeholder":"Entrez le code de parrainage...","referrals.dialog.insert.success":"Le code a été saisi avec succès.","referrals.dialog.insert.title":"Introduisez le code de parrainage","referrals.text":"Invitez vos amis à trader sur AutoLayer et soyez récompensé avec une couche supplémentaire de bonus : des AutoLayer points supplémentaires pour vous et votre ami!","referrals.title":"Programme de parrainage AutoLayer","refferrals-tab-buttons-affiliates":"Affiliés","refferrals-tab-buttons-traders":"Traders","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Vos points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL utilisé comme garantie","risk-box.dexes":"TVL comme liquiditeˊ sur les DEX","select-position":"Sélectionnez la position","select-wallet-modal.connect-wallet":"Connecter le Portefeuille","select-wallet-modal.waiting.confirm":"Veuillez confirmer l\'opération sur votre portefeuille","select-wallet-modal.waiting.connecting":"Connexion à votre portefeuille","select-wallet-modal.waiting.signing":"En attente de la signature","share-link":"Copier le lien","share-link-success":"Copié","share-telegram":"Partager sur Telegram","share-twitter":"Partager sur X","stake":"Staker","stake-banner.description":"Mettez en staking vos LAY3R pour gagner jusqu\'à 35 % d\'APY.","stake-banner.title":"Staking de LAY3R","stake.banner.items.rewards":"Vos récompenses totales","stake.banner.items.total":"Total LAY3R en staking","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Votre stake","stake.banner.title":"Faites du stake de LAY3R et gagnez des récompenses","stake.max-available-amount":"Montant maximum disponible pour le jalonnement : ","stake.staking-data.buttons.claim":"Réclamer la récompense","stake.staking-data.buttons.stake":"Stake récompense","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"COMPOSÉ","stake.staking-data.days":"JOURS","stake.staking-data.header.actions":"Actions","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Capacité","stake.staking-data.header.info":"Plus d\'infos","stake.staking-data.header.lock-term":"Durée de blocage","stake.staking-data.header.my-rewards":"Mes récompenses","stake.staking-data.header.my-stake":"Mon stake","stake.staking-data.header.pools":"Pools","stake.staking-data.title":"Pools Actifs","stake.staking-dialog.stake.approved.error":"Approbation de LAY3R non complétée","stake.staking-dialog.stake.approved.loading":"En attente d\'approbation","stake.staking-dialog.stake.approved.success":"Approbation de LAY3R complétée","stake.staking-dialog.stake.confirmation.error":"Confirmation annulée","stake.staking-dialog.stake.confirmation.loading":"En attente de confirmation","stake.staking-dialog.stake.confirmation.success":"Confirmation complétée","stake.staking-dialog.steps.done-claim":"Vos récompenses sont dans votre portefeuille","stake.staking-dialog.steps.done-restake":"Vos récompenses ont été restake","stake.staking-dialog.steps.done-staking":"Les fonds ont été stakés avec succès !","stake.staking-dialog.steps.done-unstaking":"Vos LAY3R sont dans votre portefeuille","start-inviting":"Commencez à inviter","strategies":"Stratégies","subscribe":"S\'Abonner","swap":"Échanger","swap-from":"Échanger à partir de","token-selector.deposit":"Déposer","token-selector.preview":"Estimation d\'swap","token-selector.withdraw":"Retrait","withdraw":"Retrait","your-portfolio":"Votre portefeuille"}');
        ;// ./src/locales/in.json
        const in_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"Lihat di {scan}","after-withdrawal-you-receive":"Setelah penarikan, Anda akan menerimanya di dompet Anda ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Lacak status semua LRT airdrops menggunakan AutoLayer\'s Airdrop Tracker - pantau setiap fase, periksa apakah klaim dibuka, dan akses tautan langsung untuk mengklaim hadiah Anda secara instan.","airdrop.title":"Temukan AutoLayer Airdrop Tracker","announcement":"pengumuman","apr":"APR","assets":"Assets","aubnb.banner.text":"Masa depan LRT untuk ekosistem rantai BNB.","autolayer-info.points":"Poin AutoLayer","autolayer-multiplier":"Pemultipel *AutoLayer*","avs-info-box.incentives":"Insentif","avs-info-box.staked":"TVL yang Diistirahatkan","avs-section.extended":"Lihat *{n}* lagi","avs-section.hide":"Sembunyikan","avs-section.title":"Actively Validated Services","back-to-dashboard":"Kembali ke dasbor","banner-info.title":"Bagaimana produk ini menghasilkan Yields?","binace-network-notice":"*Note:* LRTs tidak didukung secara resmi di BNB Chain; oleh karena itu, memegangnya tidak akan berkontribusi pada EigenLayeratauLRTpointsAnda. Namun,iniakanmemberiAnda AutoLayer points.","change-network":"Ubah jaringan","change-network-to":"Ganti jaringan Anda ke ","change-to-arbitrum":"Silakan beralih ke jaringan Arbitrum.","change-to-bsc":"Beralih ke Binance Smart Chain","color-scheme.dark":"Mode gelap","color-scheme.light":"Mode terang","coming-soon":"Segera hadir","connect-wallet":"Hubungkan Dompet","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Hubungkan Dompet","continue":"Lanjutkan","copied-bubble.text":"Disalin!","dashboard.autoLayer":"Poin AutoLayer","dashboard.bedrock":"Poin Bedrock","dashboard.claystack":"Poin ClayStack","dashboard.defi-strategies":"Strategi DeFi","dashboard.eigenLayer":"Poin EigenLayer","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Poin Kelp DAO","dashboard.liquid-strategies":"Strategi Restaking","dashboard.mellow":"Mellow Poin","dashboard.one-click-lrst":"Liquid Restaking 1-Klik","dashboard.one-click-restaking":"Liquid staking 1-Klik","dashboard.other-points":"Poin Lainnya","dashboard.primestaked":"Poin Prime","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Poin Renzo","dashboard.select-this-product":"Pilih produk ini","dashboard.stake":"Stake","dashboard.swbtc":"Poin Black Pearls","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic Poin","dashboard.uni":"Poin Uni","dashboard.weeth":"Poin Ether.fi","dashboard.your-deposit":"Deposit Anda","deposit-more":"Deposit lebih","deposit-step-approving-token.done":"Token disetujui.","deposit-step-approving-token.fail":"Kesalahan persetujuan token","deposit-step-approving-token.running":"Menunggu persetujuan token...","deposit-step-getting-route.done":"Mendapatkan rute untuk pertukaran.","deposit-step-getting-route.fail":"Kesalahan mendapatkan rute. Coba token lain.","deposit-step-getting-route.running":"Mendapatkan rute untuk pertukaran...","deposit-step-scan.link":"Lihat transaksi di *{scan}*","deposit-step-sending-token.done":"Operasi selesai.","deposit-step-sending-token.fail":"Kesalahan pertukaran","deposit-step-sending-token.running":"Menunggu konfirmasi operasi","deposit-step-signing.done":"Tersign.","deposit-step-signing.fail":"Terjadi kesalahan saat menandatangani transaksi.","deposit-step-signing.running":"Menunggu untuk ditandatangani","deposit.tx-points-earned":"Dengan transaksi ini, Anda telah mendapatkan","details":"Detail","disconnect":"Putuskan","discontinued-notice.text":"Claystack akan ditutup. Harap tarik aset Anda dan kunjungi {link} untuk informasi lebih lanjut. Terima kasih!","discontinued-notice.title":"Proyek Dihentikan.","email-placeholder":"Masukkan alamat email Anda","error":"Kesalahan","error-loading-data":"Kesalahan memuat data","error-loading-tokens-balance":"Kesalahan memuat saldo token","error-loading-your-values":"Kesalahan memuat nilai Anda","error.404-text":"Maaf, halaman yang Anda minta tidak ditemukan","expand":"Perluas","footer.audited-by":"Diaudit oleh","footer.community.announcements":"Pengumuman","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Grup Telegram","footer.community.title":"Komunitas","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"Tentang Kami","footer.company.blog":"Blog","footer.company.title":"Perusahaan","footer.help.feed-back":"Kirim Umpan Balik","footer.help.support-docs":"Dokumentasi Dukungan","footer.help.talk-support":"Bicara dengan dukungan","footer.help.title":"Bantuan","footer.info.audit":"Audit","footer.info.docs":"Dokumen","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"Informasi","footer.legacy":"Akses Legacy  (Tortle Ninja)","footer.legal.privacy":"Kebijakan Privasi","footer.legal.terms":"Syarat Penggunaan","footer.legal.title":"Hukum","footer.peckshield":"Periksa audit *PeckShield*","funds-wallet":"Dana ada di dompet Anda!","go-to-airdrop-checker.link":"di sini","go-to-airdrop-checker.text":"Periksa alokasi LAY3R Anda sekarang dengan mengklik {here}.","go-to-position":"Pergi ke posisi","how-get-whitelisted":"Cara masuk daftar putih","ido-banner.text":"*$LAY3R IDO* akan tayang dalam ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Volume (24h)","landing.hero-banner.text":"Manfaatkan keuntungan dari Re-Staking Ethereum.","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Bahasa","language-selector.title":"Pilih bahasa","launch-button.default-text":"Luncurkan dapp","launch-button.landing-hero-banner":"Luncurkan AutoLayer","learn-more":"Pelajari lebih lanjut","left-point.actual-value":"Nilai Sebenarnya","left-point.deposited":"Didepositkan","left-point.restaking-rewards":"Hadiah Restaking","left-point.staking-rewards":"Hadiah Staking","left-points-fallback":"Hubungkan *dompet Anda* untuk melanjutkan.","loading":"Memuat...","loyalty-points":"Poin Kesetiaan","max":"Poin Kesetiaan","meta.airdrop.description":"Pantau status semua LRT Airdrops menggunakan AutoLayer′s Airdrop Tracker - monitor setiap fase, periksa apakah klaim sudah dibuka, dan akses tautan langsung untuk mengklaim hadiah Anda secara instan.🪂","meta.airdrop.title":"Tetap terdepan dengan AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB mendefinisikan ulang Liquid Restaked Tokens (LRTs) di BNB Chain dengan yields tertinggi dan liquidity terpadu, menawarkan hingga 52% APR dalam $LAY3R rewards! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Pasar restaking terbesar dengan analitik risk-reward analytics yang canggih, manajemen poin, dan produk terstruktur.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Dapatkan Bonus AutoLayer Points untuk Anda dan teman Anda dengan setiap referensi yang berhasil!","meta.referrals.title":"Ajak Teman dan Dapatkan AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Lebih banyak akan datang segera","more-info":"Informasi lebih lanjut","network":"Jaringan","network-selector.actual":"Jaringan Saat Ini","network-selector.title":"Ubah Jaringan","placeholder.token-selector":"Cari Token...","pool-token-table.balance":"keseimbangan","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"Nilai dalam USD","referrals":"Referensi","referrals-header.title":"Referensi","referrals-info-card.title.active-code":"Kode Referensi Aktif","referrals-info-card.title.claimable-points":"Poin yang Dapat Diklaim","referrals-info-card.title.points-earned":"Poin yang Diperoleh","referrals-info-card.title.referrals-traders":"Referensi Pedagang","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Kode referensi hanya berlaku di jaringan saat ini. Jika Anda ingin kode Anda berfungsi di beberapa jaringan, Anda perlu membuat kode terpisah untuk masing-masing jaringan","referrals.affiliates.header.code":"Kode Referensi","referrals.affiliates.header.create":"Buat","referrals.affiliates.header.title":"Kode Referensi","referrals.affiliates.header.trader":"Referensi Pedagang","referrals.affiliates.header.volume":"Total Volume","referrals.dialog.create.button":"Buat kode","referrals.dialog.create.description-1":"Sepertinya Anda tidak memiliki kode referensi untuk dibagikan.","referrals.dialog.create.description-2":"Buat satu sekarang dan mulai mendapatkan cashback!","referrals.dialog.create.error.claimed":"Kode referensi sudah ada","referrals.dialog.create.input.label":"Masukkan kode","referrals.dialog.create.input.placeholder":"Ketik kode Anda...","referrals.dialog.create.success":"Kode telah dibuat dengan sukses.","referrals.dialog.create.title":"Buat kode referensi","referrals.dialog.error":"Terjadi kesalahan tak terduga, silakan coba lagi.","referrals.dialog.insert.button":"Masukkan kode referensi","referrals.dialog.insert.description":"Harap masukkan kode referensi untuk mendapatkan diskon komisi.","referrals.dialog.insert.error.claimed":"Kode sudah diklaim","referrals.dialog.insert.error.not-exists":"Kode referensi tidak ada","referrals.dialog.insert.error.same-owner":"Tidak dapat mengklaim kode Anda sendiri","referrals.dialog.insert.input.label":"Masukkan kode","referrals.dialog.insert.input.placeholder":"Masukkan kode referensi...","referrals.dialog.insert.success":"Kode telah dimasukkan dengan sukses.","referrals.dialog.insert.title":"Perkenalkan kode referensi","referrals.text":"Undang teman-teman Anda untuk berdagang di AutoLayer dan dapatkan lapisan bonus tambahan: AutoLayer Points ekstra untuk Anda dan teman Anda!","referrals.title":"Program Referensi AutoLayer","refferrals-tab-buttons-affiliates":"Afiliasi","refferrals-tab-buttons-traders":"Pedagang","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Pointsanda: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL digunakan sebagai agunan.","risk-box.dexes":"TVL sebagai liquidity di dexes.","select-position":"Pilih position","select-wallet-modal.connect-wallet":"Hubungkan Dompet","select-wallet-modal.waiting.confirm":"Silakan konfirmasi operasi di dompet Anda","select-wallet-modal.waiting.connecting":"Menghubungkan ke dompet Anda","select-wallet-modal.waiting.signing":"Menunggu tanda tangan","share-link":"Salin Tautan","share-link-success":"Tautan Disalin","share-telegram":"Bagikan di Telegram","share-twitter":"Bagikan di X","stake":"Stake","stake-banner.description":"Stake LAY3R Anda untuk mendapatkan hingga 35% APY.","stake-banner.title":"LAY3R Staking","stake.banner.items.rewards":"Total hadiah Anda","stake.banner.items.total":"Total LAY3R yang di-stake","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Stake Anda","stake.banner.title":"Stake LAY3R dan dapatkan hadiah","stake.max-available-amount":"Jumlah maksimum yang tersedia untuk stake: ","stake.staking-data.buttons.claim":"Klaim Hadiah","stake.staking-data.buttons.stake":"Stake Hadiah","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"BUNGA MAJEMUK","stake.staking-data.days":"HARI","stake.staking-data.header.actions":"Aksi","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Kapasitas","stake.staking-data.header.info":"Info lebih lanjut","stake.staking-data.header.lock-term":"Masa Kunci","stake.staking-data.header.my-rewards":"Hadiah saya","stake.staking-data.header.my-stake":"Stake saya","stake.staking-data.header.pools":"Pool","stake.staking-data.title":"Pool Aktif","stake.staking-dialog.stake.approved.error":"Persetujuan LAY3R belum selesai","stake.staking-dialog.stake.approved.loading":"Menunggu persetujuan","stake.staking-dialog.stake.approved.success":"Persetujuan LAY3R selesai","stake.staking-dialog.stake.confirmation.error":"Konfirmasi dibatalkan","stake.staking-dialog.stake.confirmation.loading":"Menunggu konfirmasi","stake.staking-dialog.stake.confirmation.success":"Konfirmasi selesai","stake.staking-dialog.steps.done-claim":"Hadiah Anda telah masuk ke dompet","stake.staking-dialog.steps.done-restake":"Hadiah Anda telah di-restake","stake.staking-dialog.steps.done-staking":"Dana berhasil di-stake!","stake.staking-dialog.steps.done-unstaking":"LAY3R Anda telah masuk ke dompet","start-inviting":"Mulai Mengundang","strategies":"Strategi","subscribe":"Menunggu tanda tangan","swap":"Tukar","swap-from":"Tukar dari","token-selector.deposit":"Deposit","token-selector.preview":"Estimasi Swap","token-selector.withdraw":"Tarik","withdraw":"penarikan","your-portfolio":"Portofolio Anda"}');
        ;// ./src/locales/jp.json
        const jp_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"{scan}で表示 ","after-withdrawal-you-receive":"引き出し後、ウォレットに受け取ります","airdrop-header.title":"Airdrop Tracker","airdrop.text":"AutoLayerのAirdrop Trackerを使用してすべての LRT airdrops の状況を追跡しましょう - 各フェーズをモニタリングし、請求が可能かどうかをチェックし、報酬を即座に請求するための直接リンクにアクセスします。","airdrop.title":"AutoLayer Airdrop Tracker の発見","announcement":"お知らせ","apr":"APR","assets":"Assets","aubnb.banner.text":"BNBチェーンエコシステムのLRTの未来。","autolayer-info.points":"Autolayer ポイント ","autolayer-multiplier":"*AutoLayer* マルチプライヤー ","avs-info-box.incentives":"インセンティブ","avs-info-box.staked":"再ステークされた TVL","avs-section.extended":"*{n}* を見る","avs-section.hide":"隠す","avs-section.title":"Actively Validated Services","back-to-dashboard":"ダッシュボードに戻る ","banner-info.title":"この製品はどのようにしてYieldsを生成しますか","binace-network-notice":"*Note:* LRTs は公式には BNB Chain でサポートされていないため; それを保有しても EigenLayerやLRTpointsに貢献しません。ただし、AutoLayerpoints を獲得することができます。","change-network":"ネットワークを変更","change-network-to":"ネットワークを切り替えてください ","change-to-arbitrum":"Arbitrumネットワークに切り替えてください.","change-to-bsc":"Binance Smart Chainへ切り替え","color-scheme.dark":"ダークモード ","color-scheme.light":"ライトモード ","coming-soon":"近日公開 ","connect-wallet":"ウォレットに接続 ","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"ウォレットに接続 ","continue":"続ける ","copied-bubble.text":"コピーされました!","dashboard.autoLayer":"Autolayer ポイント ","dashboard.bedrock":"Bedrock ポイント","dashboard.claystack":"ClayStack ポイント","dashboard.defi-strategies":"DeFi 戦略 ","dashboard.eigenLayer":"Eigenlayer ポイント ","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO ポイント","dashboard.liquid-strategies":"Restaking Strategies ","dashboard.mellow":"Mellowポイント","dashboard.one-click-lrst":"1-Click Liquid Restaking ","dashboard.one-click-restaking":"1-Click Liquid staking ","dashboard.other-points":"その他のポイント ","dashboard.primestaked":"Prime ポイント","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo ポイント","dashboard.select-this-product":"この商品を選択 ","dashboard.stake":"ステーク ","dashboard.swbtc":"Black Pearls ポイント","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbioticポイント","dashboard.uni":"Uni ポイント","dashboard.weeth":"Ether.fi ポイント","dashboard.your-deposit":"あなたのデポジット ","deposit-more":"もっとデポジット ","deposit-step-approving-token.done":"トークンが承認されました .","deposit-step-approving-token.fail":"トークン承認エラー ","deposit-step-approving-token.running":"トークンの承認を待っています... ","deposit-step-getting-route.done":"スワップのためのルートを取得しました.","deposit-step-getting-route.fail":"ルートの取得エラー。別のトークンを試してください.","deposit-step-getting-route.running":"スワップのためのルートを取得中...","deposit-step-scan.link":"*{scan}* でトランザクションを確認してください。","deposit-step-sending-token.done":"操作が完了しました.","deposit-step-sending-token.fail":"スワップエラー ","deposit-step-sending-token.running":"操作の確認を待っています","deposit-step-signing.done":"署名済み.","deposit-step-signing.fail":"トランザクションの署名エラー.","deposit-step-signing.running":"署名待ち","deposit.tx-points-earned":"このトランザクションで獲得した","details":"詳細 ","disconnect":"切断 ","discontinued-notice.text":"Claystack は閉鎖されます。資産を引き出して、詳細は {link} をご確認ください。ありがとうございました。","discontinued-notice.title":"プロジェクトは中止されました。","email-placeholder":"メールアドレスを入力してください ","error":"エラー","error-loading-data":"データの読み込みエラー ","error-loading-tokens-balance":"トークン残高の読み込みエラー","error-loading-your-values":"あなたの値の読み込みエラー","error.404-text":"申し訳ありませんが、要求されたページが見つかりませんでした","expand":"拡大 ","footer.audited-by":"監査","footer.community.announcements":"お知らせ ","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram グループ ","footer.community.title":"コミュニティ ","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"弊社について ","footer.company.blog":"ブログ ","footer.company.title":"会社 ","footer.help.feed-back":"フィードバックを送信 ","footer.help.support-docs":"サポートドキュメント ","footer.help.talk-support":"サポートに話しかける ","footer.help.title":"ヘルプ ","footer.info.audit":"監査 ","footer.info.docs":"ドキュメント ","footer.info.github":"Github","footer.info.media":"メディアキット ","footer.info.medium":"Medium","footer.info.title":"情報 ","footer.legacy":"Legacy Access (Tortle Ninja)","footer.legal.privacy":"プライバシーポリシー","footer.legal.terms":"利用規約 ","footer.legal.title":"法的事項 ","footer.peckshield":"*PeckShield*の監査を確認 ","funds-wallet":"資金はあなたのウォレットにあります!","go-to-airdrop-checker.link":"ここ","go-to-airdrop-checker.text":"{here}をクリックして、今すぐ LAY3R の割り当てを確認してください。","go-to-position":"ポジションに移動 ","how-get-whitelisted":"ホワイトリストに登録する方法","ido-banner.text":"*$LAY3R IDO* が開始されるまで ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"取引量 (24h)","landing.hero-banner.text":"Ethereum リステーキングの利点を活用しましょう。","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"言語 ","language-selector.title":"言語を選択","launch-button.default-text":"Dappを起動する ","launch-button.landing-hero-banner":"AutoLayerを起動 ","learn-more":"詳細を学ぶ ","left-point.actual-value":"実際の価値 ","left-point.deposited":"デポジット済み ","left-point.restaking-rewards":"リステイキングリワード ","left-point.staking-rewards":"ステーキングリワード ","left-points-fallback":"続行するには、*あなたのウォレット*を接続してください。","loading":"読み込み中...","loyalty-points":"ロイヤリティポイント ","max":"最大 ","meta.airdrop.description":"AutoLayer Airdrop Tracker を使って、すべての LRT Airdrops のステータスを追跡しましょう - 各フェーズを監視し、請求が可能かを確認し、報酬を即座に請求できるリンクにアクセスできます。🪂","meta.airdrop.title":"AutoLayer Airdrop Tracker を使ってリードを保ちましょう!","meta.aubnb.description":"AuBNBは、最高のyieldsと統合されたliquidityを備えたBNB Chain上でLiquid Restaked Tokens (LRTs)を再定義し、$LAY3Rリワードで最大52% APRを提供します。! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"高度なrisk-reward analysis、ポイント管理、構造化商品を備えた最大のrestakingマーケットプレイス。","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"成功した紹介ごとに、自分と友達の両方にボーナス AutoLayer ポイントを獲得しましょう!","meta.referrals.title":"を紹介して AutoLayer ポイント を獲得しましょう!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"もっと近日公開","more-info":"詳細 ","network":"ネットワーク ","network-selector.actual":"実際のネットワーク","network-selector.title":"ネットワークを変更","placeholder.token-selector":"トークンを検索...","pool-token-table.balance":"残高","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"米ドルの価値","referrals":"リファーラル","referrals-header.title":"リファーラル","referrals-info-card.title.active-code":"アクティブなリファラルコード","referrals-info-card.title.claimable-points":"請求可能なポイント","referrals-info-card.title.points-earned":"獲得ポイント","referrals-info-card.title.referrals-traders":"リファラルトレーダー","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"リファラルコードは現在のネットワークでのみ有効です。複数のチェーンでコードを機能させたい場合は、それぞれのチェーン用に別々のコードを作成する必要があります。","referrals.affiliates.header.code":"リファラルコード","referrals.affiliates.header.create":"作成","referrals.affiliates.header.title":"リファラルのコード","referrals.affiliates.header.trader":"リファラルトレーダー","referrals.affiliates.header.volume":"総取引量","referrals.dialog.create.button":"コードを作成","referrals.dialog.create.description-1":"リファラルコードを共有するコードがないようです.","referrals.dialog.create.description-2":"今すぐ作成してキャッシュバックを獲得しましょう!","referrals.dialog.create.error.claimed":"リファラルコードはすでに存在します","referrals.dialog.create.input.label":"コードを入力","referrals.dialog.create.input.placeholder":"コードを入力してください...","referrals.dialog.create.success":"コードが正常に作成されました.","referrals.dialog.create.title":"リファラルコードを作成","referrals.dialog.error":"予期しないエラーが発生しました。もう一度お試しください.","referrals.dialog.insert.button":"リファラルコードを入力","referrals.dialog.insert.description":"コミッションの割引を受けるにはリファラルコードを入力してください.","referrals.dialog.insert.error.claimed":"すでにコードを請求済みです","referrals.dialog.insert.error.not-exists":"リファラルコードが存在しません","referrals.dialog.insert.error.same-owner":"自分のコードを請求することはできません","referrals.dialog.insert.input.label":"コードを入力","referrals.dialog.insert.input.placeholder":"リファラルコードを入力...","referrals.dialog.insert.success":"コードが正常に入力されました.","referrals.dialog.insert.title":"リファラルコードを紹介","referrals.text":"友達を AutoLayer で取引するよう招待し、追加のボーナスを獲得しましょう：自分と友達のための追加の AutoLayer ポイント!","referrals.title":"AutoLayer リファラルプログラム","refferrals-tab-buttons-affiliates":"アフィリエイト","refferrals-tab-buttons-traders":"トレーダー","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"あなたのpoints: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"担保として使用される TVL","risk-box.dexes":"DEX 上の liquidity としての TVL.","select-position":"Position を選択","select-wallet-modal.connect-wallet":"ウォレットに接続 ","select-wallet-modal.waiting.confirm":"ウォレットで操作を確認してください ","select-wallet-modal.waiting.connecting":"ウォレットに接続中 ","select-wallet-modal.waiting.signing":"署名を待っています ","share-link":"リンクをコピー ","share-link-success":"コピーされました ","share-telegram":"Telegramで共有 ","share-twitter":"Xで共有 ","stake":"ステーク ","stake-banner.description":"LAY3Rをステーキングして、最大35%のAPYを獲得しましょう。","stake-banner.title":"LAY3R ステーキング","stake.banner.items.rewards":"合計報酬","stake.banner.items.total":"合計 LAY3R ステーキング","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"あなたのステーキング","stake.banner.title":"LAY3R をステーキングして報酬を獲得","stake.max-available-amount":"ステーク可能な最大額：","stake.staking-data.buttons.claim":"報酬を請求","stake.staking-data.buttons.stake":"ステーキング報酬","stake.staking-data.buttons.unstake":"ステーキング解除","stake.staking-data.compounding":"複利","stake.staking-data.days":"日","stake.staking-data.header.actions":"アクション","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"容量","stake.staking-data.header.info":"詳細情報","stake.staking-data.header.lock-term":"ロック期間","stake.staking-data.header.my-rewards":"私の報酬","stake.staking-data.header.my-stake":"私のステーキング","stake.staking-data.header.pools":"プール","stake.staking-data.title":"アクティブなプール","stake.staking-dialog.stake.approved.error":"LAY3R の承認が完了していません","stake.staking-dialog.stake.approved.loading":"承認待ち","stake.staking-dialog.stake.approved.success":"LAY3R の承認が完了しました","stake.staking-dialog.stake.confirmation.error":"確認がキャンセルされました","stake.staking-dialog.stake.confirmation.loading":"確認待ち","stake.staking-dialog.stake.confirmation.success":"確認が完了しました","stake.staking-dialog.steps.done-claim":"報酬がウォレットに入りました","stake.staking-dialog.steps.done-restake":"報酬が再ステーキングされました","stake.staking-dialog.steps.done-staking":"資金が正常にステーキングされました！","stake.staking-dialog.steps.done-unstaking":"あなたの LAY3R がウォレットに入りました","start-inviting":"招待を開始","strategies":"戦略","subscribe":"購読 ","swap":"スワップ ","swap-from":"からスワップ ","token-selector.deposit":"デポジット ","token-selector.preview":"の見積もり","token-selector.withdraw":"引き出す","withdraw":"引き出す","your-portfolio":"あなたのポートフォリオ"}');
        ;// ./src/locales/th.json
        const th_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"ดูที่ {scan}","after-withdrawal-you-receive":"หลังจากการถอนคุณจะได้รับในกระเป๋าเงินของคุณ ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"ติดตามสถานะของ LRT airdropsทั้งหมดโดยใช้ AutoLayer\'s Airdrop Tracker- ตรวจสอบแต่ละเฟส ตรวจสอบว่าการเรียกรับเปิดอยู่หรือไม่ และเข้าถึงลิงก์โดยตรงเพื่อเรียกรับรางวัลของคุณทันที.","airdrop.title":"ค้นพบ AutoLayer Airdrop Tracker","announcement":"ประกาศ","apr":"APR","assets":"Assets","aubnb.banner.text":"อนาคตของ LRT สำหรับระบบนิเวศของ BNB Chain","autolayer-info.points":"Autolayer points","autolayer-multiplier":"ตัวคูณ *AutoLayer*","avs-info-box.incentives":"แรงจูงใจ","avs-info-box.staked":"TVL ที่นำมาวางใหม่","avs-section.extended":"ดูเพิ่มเติม *{n}* รายการ","avs-section.hide":"ซ่อน","avs-section.title":"Actively Validated Services","back-to-dashboard":"กลับไปที่แดชบอร์ด","banner-info.title":" สินค้านี้สร้าง Yield ได้อย่างไร?","binace-network-notice":"*Note:* LRTs ยังไม่ได้รับการสนับสนุนทางกฎหมายบน BNB Chain; ดังนั้นการถือครองมันจะไม่ส่งผลให้กับ EigenLayer หรือ LRT points ของคุณ แต่มันจะให้คุณได้รับ AutoLayer points.","change-network":"เปลี่ยนเครือข่าย","change-network-to":"สลับเครือข่ายของคุณไปที่ ","change-to-arbitrum":"โปรดสลับเป็นเครือข่าย Arbitrum.","change-to-bsc":"สลับไปยัง Binance Smart Chain","color-scheme.dark":"โหมดมืด","color-scheme.light":"โหมดสว่าง","coming-soon":"เร็ว ๆ นี้","connect-wallet":"เชื่อมต่อกระเป๋า","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"เชื่อมต่อกระเป๋า","continue":"ดำเนินการต่อ","copied-bubble.text":"คัดลอกแล้ว!","dashboard.autoLayer":"Autolayer Points","dashboard.bedrock":"คะแนน Bedrock","dashboard.claystack":"คะแนน ClayStack","dashboard.defi-strategies":"กลยุทธ์ DeFi","dashboard.eigenLayer":"Eigenlayer Points","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO Points","dashboard.liquid-strategies":"กลยุทธ์ Restaking","dashboard.mellow":"Mellow คะแนน","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid staking","dashboard.other-points":"คะแนนอื่น ๆ","dashboard.primestaked":"คะแนน Prime","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo Points","dashboard.select-this-product":"เลือกผลิตภัณฑ์นี้","dashboard.stake":"Stake","dashboard.swbtc":"คะแนน Black Pearls","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic คะแนน","dashboard.uni":"คะแนน Uni","dashboard.weeth":"คะแนน Ether.fi","dashboard.your-deposit":"เงินฝากของคุณ","deposit-more":"ฝากเงินเพิ่ม","deposit-step-approving-token.done":"สิทธิ์ในการใช้ Token ได้รับการอนุมัติ.","deposit-step-approving-token.fail":"ข้อผิดพลาดในการอนุมัติ Token","deposit-step-approving-token.running":"กำลังรอการอนุมัติ Token...","deposit-step-getting-route.done":"ได้เส้นทางสำหรับสว็อปแล้ว.","deposit-step-getting-route.fail":"เกิดข้อผิดพลาดในการเรียกเส้นทาง ลองใช้ Token อื่น.","deposit-step-getting-route.running":"กำลังเรียกเส้นทางสำหรับการสว็อป...","deposit-step-scan.link":"ดูธุรกรรมที่ *{scan}*","deposit-step-sending-token.done":"ดำเนินการเสร็จสิ้น.","deposit-step-sending-token.fail":"ข้อผิดพลาดในการสว็อป","deposit-step-sending-token.running":"กำลังรอการยืนยันของการดำเนินการ","deposit-step-signing.done":"ลงนามแล้ว.","deposit-step-signing.fail":"เกิดข้อผิดพลาดในการลงนามธุรกรรม.","deposit-step-signing.running":"รอการลงนาม","deposit.tx-points-earned":"ด้วยธุรกรรมนี้คุณได้รับ","details":"รายละเอียด","disconnect":"ตัดการเชื่อมต่อ","discontinued-notice.text":"Claystack กำลังปิดตัวลง โปรดถอนสินทรัพย์ของคุณและตรวจสอบ {link} เพื่อดูรายละเอียดเพิ่มเติม ขอบคุณครับ/ค่ะ!","discontinued-notice.title":"โครงการถูกยุติการดำเนินการลง","email-placeholder":"ป้อนที่อยู่อีเมลของคุณ","error":"ข้อผิดพลาด","error-loading-data":"ข้อผิดพลาดในการโหลดข้อมูล","error-loading-tokens-balance":"ข้อผิดพลาดในการโหลดยอดคงเหลือ Token","error-loading-your-values":"ข้อผิดพลาดในการโหลดค่าของคุณ","error.404-text":"ขออภัย, ไม่พบหน้าที่คุณขอ","expand":"ขยาย","footer.audited-by":"ได้รับการตรวจสอบจาก","footer.community.announcements":"ประกาศ","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram Group","footer.community.title":"ชุมชน","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"เกี่ยวกับเรา","footer.company.blog":"บล็อก","footer.company.title":"บริษัท","footer.help.feed-back":"ส่งข้อเสนอความคิด","footer.help.support-docs":"เอกสารการสนับสนุน","footer.help.talk-support":"พูดคุยกับฝ่ายสนับสนุน","footer.help.title":"ช่วยเหลือ","footer.info.audit":"การตรวจสอบ","footer.info.docs":"เอกสาร","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"ข้อมูล","footer.legacy":"การเข้าถึงรุ่นเก่า (Tortle Ninja)","footer.legal.privacy":"นโยบายความเป็นส่วนตัว","footer.legal.terms":"เงื่อนไขการใช้งาน","footer.legal.title":"กฎหมาย","footer.peckshield":"ตรวจสอบการตรวจสอบ *PeckShield*","funds-wallet":"เงินอยู่ในกระเป๋าของคุณแล้ว!","go-to-airdrop-checker.link":"ที่นี่","go-to-airdrop-checker.text":"ตรวจสอบการจัดสรร LAY3R ของคุณตอนนี้โดยคลิกที่ {here}.","go-to-position":"ไปที่ตำแหน่ง","how-get-whitelisted":"วิธีการรับสิทธิ์ในบัญชีรายชื่อขาว","ido-banner.text":"*$LAY3R IDO* เปิดตัวใน ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"ปริมาณ (24h)","landing.hero-banner.text":"ใช้ประโยชน์จาก Ethereum Re-Staking.","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"ภาษา","language-selector.title":"เลือกภาษา","launch-button.default-text":"เปิดใช้ dapp","launch-button.landing-hero-banner":"เปิดใช้ AutoLayer","learn-more":"เรียนรู้เพิ่มเติม","left-point.actual-value":"ค่าจริง","left-point.deposited":"ฝาก","left-point.restaking-rewards":"Restaking rewards","left-point.staking-rewards":"Staking rewards","left-points-fallback":"เชื่อมต่อ *กระเป๋าเงินของคุณ* เพื่อดำเนินการต่อ.","loading":"กำลังโหลด...","loyalty-points":"คะแนนความลงมือทุน","max":"สูงสุด","meta.airdrop.description":"ติดตามสถานะของ LRT airdrops ทั้งหมดโดยใช้ AutoLayer′s Airdrop Tracker - ตรวจสอบแต่ละขั้นตอน ดูว่าการเรียกร้องเปิดอยู่หรือไม่ และเข้าถึงลิงก์โดยตรงเพื่อรับรางวัลของคุณทันที. 🪂","meta.airdrop.title":"ติดตามล้ำหน้าด้วย AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB ปฏิวัติ Liquid Restaked Tokens (LRTs) บน BNB Chain ด้วยผลตอบแทนสูงสุด yields และสภาพคล่องที่รวมกัน liquidity เสนอถึง 52% APR ใน $LAY3R รางวัล! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"ตลาด restaking ที่ใหญ่ที่สุดพร้อมด้วย risk-reward analytics ที่ก้าวหน้า การจัดการคะแนน และผลิตภัณฑ์โครงสร้าง.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"รับโบนัส AutoLayer Points สำหรับคุณและเพื่อนของคุณทุกครั้งที่การแนะนำสำเร็จ!","meta.referrals.title":"แนะนำเพื่อนและรับ AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"เพิ่มเติมเร็ว ๆ นี้","more-info":"ข้อมูลเพิ่มเติม","network":"เครือข่าย","network-selector.actual":"เครือข่ายปัจจุบัน","network-selector.title":"เปลี่ยนเครือข่าย","placeholder.token-selector":"ค้นหาโทเคน...","pool-token-table.balance":"ยอดคงเหลือ","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"มูลค่าใน USD","referrals":"การแนะนำ","referrals-header.title":"การแนะนำ","referrals-info-card.title.active-code":"รหัสแนะนำที่ใช้งาน","referrals-info-card.title.claimable-points":"คะแนนที่สามารถเรียกร้องได้","referrals-info-card.title.points-earned":"คะแนนที่ได้รับ","referrals-info-card.title.referrals-traders":"นักเทรดที่ถูกแนะนำ","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"รหัสแนะนำใช้ได้เฉพาะบนเครือข่ายปัจจุบันเท่านั้น หากคุณต้องการให้รหัสของคุณทำงานข้ามหลายเชน คุณจะต้องสร้างรหัสแยกสำหรับแต่ละเชน","referrals.affiliates.header.code":"รหัสแนะนำ","referrals.affiliates.header.create":"สร้าง","referrals.affiliates.header.title":"รหัสของผู้แนะนำ","referrals.affiliates.header.trader":"นักเทรดที่ถูกแนะนำ","referrals.affiliates.header.volume":"ปริมาณรวม","referrals.dialog.create.button":"สร้างรหัส","referrals.dialog.create.description-1":"ดูเหมือนว่าคุณยังไม่มีรหัสแนะนำเพื่อแชร์.","referrals.dialog.create.description-2":"สร้างรหัสตอนนี้และเริ่มรับเงินคืน!","referrals.dialog.create.error.claimed":"รหัสแนะนำมีอยู่แล้ว","referrals.dialog.create.input.label":"ใส่รหัส","referrals.dialog.create.input.placeholder":"พิมพ์รหัสของคุณ...","referrals.dialog.create.success":"รหัสถูกสร้างเรียบร้อยแล้ว.","referrals.dialog.create.title":"สร้างรหัสแนะนำ","referrals.dialog.error":"เกิดข้อผิดพลาดที่ไม่คาดคิด โปรดลองอีกครั้ง.","referrals.dialog.insert.button":"ใส่รหัสแนะนำ","referrals.dialog.insert.description":"โปรดใส่รหัสแนะนำเพื่อรับส่วนลดค่าคอมมิชชั่น.","referrals.dialog.insert.error.claimed":"ได้เรียกร้องรหัสไปแล้ว","referrals.dialog.insert.error.not-exists":"รหัสแนะนำไม่มีอยู่","referrals.dialog.insert.error.same-owner":"ไม่สามารถเรียกร้องรหัสของตัวเองได้","referrals.dialog.insert.input.label":"ใส่รหัส","referrals.dialog.insert.input.placeholder":"ใส่รหัสแนะนำ...","referrals.dialog.insert.success":"รหัสถูกป้อนสำเร็จ.","referrals.dialog.insert.title":"แนะนำรหัสแนะนำ","referrals.text":"เชิญเพื่อนของคุณมาเทรดบน AutoLayer และรับโบนัสพิเศษ: AutoLayer Points เพิ่มเติมสำหรับคุณและเพื่อนของคุณ!","referrals.title":"โปรแกรมแนะนำเพื่อน AutoLayer","refferrals-tab-buttons-affiliates":"พันธมิตร","refferrals-tab-buttons-traders":"นักเทรด","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"pointsของคุณ: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL ใช้เป็นหลักประกัน","risk-box.dexes":"TVL เป็น liquidity บน dexes","select-position":"เลือกposition","select-wallet-modal.connect-wallet":"เชื่อมต่อกระเป๋าเงิน","select-wallet-modal.waiting.confirm":"โปรดยืนยันการดำเนินการในกระเป๋าเงินของคุณ","select-wallet-modal.waiting.connecting":"กำลังเชื่อมต่อกับกระเป๋าเงินของคุณ","select-wallet-modal.waiting.signing":"กำลังรอลายเซ็น","share-link":"คัดลอกลิงก์","share-link-success":"คัดลอกแล้ว","share-telegram":"แชร์บนเทเลกราม","share-twitter":"แชร์บน X","stake":"จัดฝาก","stake-banner.description":"เดิมพัน LAY3R ของคุณเพื่อรับผลตอบแทนสูงสุดถึง 35% APY","stake-banner.title":"การ Staking $LAY3R","stake.banner.items.rewards":"ผลตอบแทนทั้งหมดของคุณ","stake.banner.items.total":"LAY3R ที่ถูก Stake ทั้งหมด","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Stake ของคุณ","stake.banner.title":"Stake LAY3R และรับผลตอบแทน","stake.max-available-amount":"จำนวนสูงสุดที่สามารถ Stake ได้: ","stake.staking-data.buttons.claim":"รับรางวัล","stake.staking-data.buttons.stake":"Stake รางวัล","stake.staking-data.buttons.unstake":"ถอน Stake","stake.staking-data.compounding":"ทบต้น","stake.staking-data.days":"วัน","stake.staking-data.header.actions":"การดำเนินการ","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"ความจุ","stake.staking-data.header.info":"ข้อมูลเพิ่มเติม","stake.staking-data.header.lock-term":"ระยะเวลาล็อค","stake.staking-data.header.my-rewards":"รางวัลของฉัน","stake.staking-data.header.my-stake":"Stake ของฉัน","stake.staking-data.header.pools":"พูล","stake.staking-data.title":"พูลที่ใช้งานอยู่","stake.staking-dialog.stake.approved.error":"การอนุมัติ LAY3R ไม่สำเร็จ","stake.staking-dialog.stake.approved.loading":"กำลังรอการอนุมัติ","stake.staking-dialog.stake.approved.success":"การอนุมัติ LAY3R สำเร็จ","stake.staking-dialog.stake.confirmation.error":"การยืนยันถูกยกเลิก","stake.staking-dialog.stake.confirmation.loading":"กำลังรอการยืนยัน","stake.staking-dialog.stake.confirmation.success":"การยืนยันเสร็จสมบูรณ์","stake.staking-dialog.steps.done-claim":"รางวัลของคุณอยู่ในกระเป๋าเงินแล้ว","stake.staking-dialog.steps.done-restake":"รางวัลของคุณถูก Stake ใหม่แล้ว","stake.staking-dialog.steps.done-staking":"การ Stake เงินทุนสำเร็จแล้ว!","stake.staking-dialog.steps.done-unstaking":"LAY3R ของคุณอยู่ในกระเป๋าเงินแล้ว","start-inviting":"เริ่มเชิญ","strategies":"กลยุทธ์","subscribe":"สมัครสมาชิก","swap":"สลับ","swap-from":"สลับจาก","token-selector.deposit":"ฝาก","token-selector.preview":"การประมาณการ","token-selector.withdraw":"ถอน","withdraw":"ถอน","your-portfolio":"พอร์ต​โฟลิโอ​ของคุณ"}');
        ;// ./src/locales/tk.json
        const tk_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"{scan} üzerinde görüntüle","after-withdrawal-you-receive":"Çekimden sonra cüzdanınıza alacaksınız ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"LRT airdrop\'lerin durumunu AutoLayer\'s Airdrop Tracker kullanarak takip edin - her aşamayı izleyin, taleplerin açık olup olmadığını kontrol edin ve ödüllerinizi anında talep etmek için doğrudan bağlantılara erişin.","airdrop.title":"Discover AutoLayer Airdrop Tracker","announcement":"Duyuru","apr":"APR","assets":"Assets","aubnb.banner.text":"BNB Zincir ekosistemi için LRT\'lerin geleceği.","autolayer-info.points":"Autolayer Puanları","autolayer-multiplier":"*AutoLayer* Çarpanı","avs-info-box.incentives":"Teşvikler","avs-info-box.staked":"Yeniden Stake Edilen TVL","avs-section.extended":"*{n}* tane daha gör","avs-section.hide":"Gizle","avs-section.title":"Actively Validated Services","back-to-dashboard":"Panoya geri dön","banner-info.title":"Bu ürün nasıl Yields sağlar?","binace-network-notice":"*Note:* LRT\'ler BNB Chain\'nde resmi olarak desteklenmiyor; bu nedenle, onları tutmak EigenLayer veya LRT points\'a katkıda bulunmayacaktır. Ancak, size AutoLayer points kazandıracaktır.","change-network":"Ağı değiştir","change-network-to":"Ağınızı değiştirin ","change-to-arbitrum":"Lütfen Arbitrum ağına geçin.","change-to-bsc":"Binance Smart Chain\'e geç","color-scheme.dark":"Koyu mod","color-scheme.light":"Açık mod","coming-soon":"Yakında","connect-wallet":"Cüzdan Bağla","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Cüzdan Bağla","continue":"Devam et","copied-bubble.text":"Kopyalandı!","dashboard.autoLayer":"Autolayer Puanları","dashboard.bedrock":"Bedrock Puanları","dashboard.claystack":"ClayStack Puanları","dashboard.defi-strategies":"DeFi Stratejileri","dashboard.eigenLayer":"Eigenlayer Puanları","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO Puanları","dashboard.liquid-strategies":"Restaking Stratejileri","dashboard.mellow":"Mellow puanlar","dashboard.one-click-lrst":"1-Tıklamayla Liquid Restaking","dashboard.one-click-restaking":" 1-Tıklamayla Liquid Staking","dashboard.other-points":"Diğer Puanlar","dashboard.primestaked":"Prime Puanları","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo Puanları","dashboard.select-this-product":"Bu ürünü seç","dashboard.stake":"Stake Et","dashboard.swbtc":"Black Pearls Puanları","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic puanlar","dashboard.uni":"Uni Puanları","dashboard.weeth":"Ether.fi Puanları","dashboard.your-deposit":"Yatırımınız","deposit-more":"Daha fazla yatırım yap","deposit-step-approving-token.done":"Token onaylandı.","deposit-step-approving-token.fail":"Token onay hatası","deposit-step-approving-token.running":"Token onayı bekleniyor...","deposit-step-getting-route.done":"Takas için yol alındı.","deposit-step-getting-route.fail":"Yol alınamıyor. Başka bir token deneyin.","deposit-step-getting-route.running":"Takas için yol alınıyor...","deposit-step-scan.link":"*{scan}* üzerinde işlemi görüntüle","deposit-step-sending-token.done":"İşlem tamamlandı.","deposit-step-sending-token.fail":"Takas hatası","deposit-step-sending-token.running":"İşlem onayı bekleniyor","deposit-step-signing.done":"İmzalandı.","deposit-step-signing.fail":"İşlem imzalanırken hata oluştu.","deposit-step-signing.running":"İmzalama bekleniyor","deposit.tx-points-earned":"Bu işlemle kazandınız","details":"Detaylar","disconnect":"Bağlantıyı Kes","discontinued-notice.text":"Claystack kapanıyor. Lütfen varlıklarınızı çekin ve daha fazla detay için {link}\'i kontrol edin. Teşekkürler!","discontinued-notice.title":"Proje Durduruldu.","email-placeholder":"E-posta adresinizi girin","error":"Hata","error-loading-data":"Veri yüklenirken hata oluştu","error-loading-tokens-balance":"Token bakiyesi yüklenirken hata oluştu","error-loading-your-values":"Değerleriniz yüklenirken hata oluştu","error.404-text":"Üzgünüz, istediğiniz sayfa bulunamadı","expand":"Genişlet","footer.audited-by":"Denetlendi","footer.community.announcements":"Duyurular","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram Grubu","footer.community.title":"Topluluk","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"Hakkımızda","footer.company.blog":"Blog","footer.company.title":"Şirket","footer.help.feed-back":"Geri Bildirim Gönder","footer.help.support-docs":"Destek Belgeleri","footer.help.talk-support":"Destek ile Konuşun","footer.help.title":"Yardım","footer.info.audit":"Denetim","footer.info.docs":"Belgeler","footer.info.github":"Github","footer.info.media":"Medya Kiti","footer.info.medium":"Medium","footer.info.title":"Bilgi","footer.legacy":"Eski Erişim  (Tortle Ninja)","footer.legal.privacy":"Gizlilik Politikası","footer.legal.terms":"Kullanım Koşulları","footer.legal.title":"Hukuki","footer.peckshield":"*PeckShield* denetimini kontrol et","funds-wallet":"Fonlar cüzdanınızda!","go-to-airdrop-checker.link":"Burada","go-to-airdrop-checker.text":"LAY3R tahsisinizi kontrol etmek için {here} tıklayın.","go-to-position":"Pozisyona git","how-get-whitelisted":"Beyaz listeye nasıl girilir","ido-banner.text":"*$LAY3R IDO* başlıyor ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Hacim (24h)","landing.hero-banner.text":"Ethereum Yeniden Staking\'in faydalarını kullanın","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Dil","language-selector.title":"Dil Seçin","launch-button.default-text":"Dapp\'ı Başlat","launch-button.landing-hero-banner":"AutoLayer\'ı Başlat","learn-more":"Daha Fazla Bilgi Edinin","left-point.actual-value":"Gerçek Değer","left-point.deposited":"Yatırılan","left-point.restaking-rewards":"Restaking Ödülleri","left-point.staking-rewards":"Staking Ödülleri","left-points-fallback":"*Cüzdanınızı bağlamak* için devam edin.","loading":"Yükleniyor...","loyalty-points":"Sadakat Puanları","max":"Maksimum","meta.airdrop.description":"Tüm LRT airdrops\'larının durumunu AutoLayer\'s Airdrop Tracker\'ı ile takip edin - her aşamayı izleyin, taleplerin açık olup olmadığını kontrol edin ve ödüllerinizi anında talep etmek için doğrudan bağlantılara erişin. 🪂","meta.airdrop.title":"AutoLayer Airdrop Tracker ile önde olun!","meta.aubnb.description":"AuBNB, 33BNB Chain33 üzerinde en yüksek yields ve birleşik liquidity ile Liquid Restaked Tokens (LRTs) yeniden tanımlar, $LAY3R ödüllerinde %52\'ye varan APR sunar! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Gelişmiş risk-reward analytics, puan yönetimi ve yapılandırılmış ürünlerle en büyük restaking pazarı.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Her başarılı yönlendirme ile hem siz hem de arkadaşınız için Bonus AutoLayer Points kazanın!","meta.referrals.title":"Arkadaşlarını Yönlendir ve AutoLayer Points Kazan!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Daha fazlası yakında","more-info":"Daha Fazla Bilgi","network":"Ağ","network-selector.actual":"Mevcut Ağ","network-selector.title":"Ağı Değiştir","placeholder.token-selector":"Token Ara...","pool-token-table.balance":"Bakiye","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"USD Değeri","referrals":"Yönlendirmeler","referrals-header.title":"Yönlendirmeler","referrals-info-card.title.active-code":"Aktif Yönlendirme Kodu","referrals-info-card.title.claimable-points":"Talep Edilebilir Puanlar","referrals-info-card.title.points-earned":"Kazanılan Puanlar","referrals-info-card.title.referrals-traders":"Yönlendirme Tüccarları","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Yönlendirme kodları yalnızca mevcut ağda geçerlidir. Kodunuzun birden fazla zincirde çalışmasını istiyorsanız, her biri için ayrı bir kod oluşturmanız gerekecek.","referrals.affiliates.header.code":"Yönlendirme Kodu","referrals.affiliates.header.create":"Oluştur","referrals.affiliates.header.title":"Yönlendirme Kodu","referrals.affiliates.header.trader":"Yönlendirme Tüccarları","referrals.affiliates.header.volume":"Toplam Hacim","referrals.dialog.create.button":"Kod Oluştur","referrals.dialog.create.description-1":"Paylaşacak bir yönlendirme kodunuz yok gibi görünüyor.","referrals.dialog.create.description-2":"Şimdi bir tane oluşturun ve nakit geri kazanmaya başlayın!","referrals.dialog.create.error.claimed":"Yönlendirme kodu zaten mevcut","referrals.dialog.create.input.label":"Kod Girin","referrals.dialog.create.input.placeholder":"Kodunuzu Yazın...","referrals.dialog.create.success":"Kod başarıyla oluşturuldu.","referrals.dialog.create.title":"Yönlendirme Kodu Oluştur","referrals.dialog.error":"Beklenmeyen bir hata oluştu, lütfen tekrar deneyin.","referrals.dialog.insert.button":"Yönlendirme Kodunu Girin","referrals.dialog.insert.description":"Komisyon indirimlerinden faydalanmak için lütfen bir yönlendirme kodu girin.","referrals.dialog.insert.error.claimed":"Zaten bir kod talep edildi","referrals.dialog.insert.error.not-exists":"Yönlendirme kodu mevcut değil","referrals.dialog.insert.error.same-owner":"Kendi kodunuzu talep edemezsiniz","referrals.dialog.insert.input.label":"Kod Girin","referrals.dialog.insert.input.placeholder":"Yönlendirme Kodunu Girin...","referrals.dialog.insert.success":"Kod başarıyla girildi.","referrals.dialog.insert.title":"Yönlendirme Kodunu Tanıtın","referrals.text":"Arkadaşlarınızı AutoLayer\'da işlem yapmaya davet edin ve ekstra bir bonus katmanı ile ödüllendirin: Hem sizin hem de arkadaşınız için Ekstra AutoLayer Points kazanın!","referrals.title":"AutoLayer Yönlendirme Programı","refferrals-tab-buttons-affiliates":"Ortaklar","refferrals-tab-buttons-traders":"Tüccarlar","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"senin points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL teminat olarak kullanıldı","risk-box.dexes":"TVL, dexes\'te liquidity olarak kullanıldı","select-position":"Position seçin","select-wallet-modal.connect-wallet":"Cüzdanı Bağla","select-wallet-modal.waiting.confirm":"Lütfen cüzdanınızda işlemi onaylayın","select-wallet-modal.waiting.connecting":"Cüzdanınıza bağlanıyor","select-wallet-modal.waiting.signing":"İmza bekleniyor","share-link":"Bağlantıyı Kopyala","share-link-success":"Kopyalandı","share-telegram":"Telegram\'da Paylaş","share-twitter":"X\'te Paylaş","stake":"Stake","stake-banner.description":"LAY3R\'ınızı stake ederek %35 APY\'ye kadar kazanın.","stake-banner.title":"LAY3R Staking","stake.banner.items.rewards":"Toplam ödülleriniz","stake.banner.items.total":"Toplam LAY3R stake edilen","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Sizin stake\'iniz","stake.banner.title":"LAY3R stake edin ve ödüller kazanın","stake.max-available-amount":"Stake edilebilecek maksimum miktar: ","stake.staking-data.buttons.claim":"Ödül Talep Et","stake.staking-data.buttons.stake":"Stake Ödülü","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"BİLEŞİK","stake.staking-data.days":"GÜN","stake.staking-data.header.actions":"İşlemler","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Kapasite","stake.staking-data.header.info":"Daha fazla bilgi","stake.staking-data.header.lock-term":"Kilitleme süresi","stake.staking-data.header.my-rewards":"Ödüllerim","stake.staking-data.header.my-stake":"Stake\'im","stake.staking-data.header.pools":"Havuzlar","stake.staking-data.title":"Aktif Havuzlar","stake.staking-dialog.stake.approved.error":"LAY3R onayı tamamlanmadı","stake.staking-dialog.stake.approved.loading":"Onay bekleniyor","stake.staking-dialog.stake.approved.success":"LAY3R onayı tamamlandı","stake.staking-dialog.stake.confirmation.error":"Onay iptal edildi","stake.staking-dialog.stake.confirmation.loading":"Onay bekleniyor","stake.staking-dialog.stake.confirmation.success":"Onay tamamlandı","stake.staking-dialog.steps.done-claim":"Ödülleriniz cüzdanınıza geldi","stake.staking-dialog.steps.done-restake":"Ödülleriniz restake edildi","stake.staking-dialog.steps.done-staking":"Fonlar başarıyla stake edildi!","stake.staking-dialog.steps.done-unstaking":"LAY3R\'larınız cüzdanınıza geldi","start-inviting":"Davet Etmeye Başla","strategies":"Stratejiler","subscribe":"Abone Ol","swap":"Takas","swap-from":"Şu Cüzdandan Takas Yap","token-selector.deposit":"Yatırım","token-selector.preview":"tahmini","token-selector.withdraw":"Çekmek","withdraw":"çekme","your-portfolio":"Portföyünüz"}');
        ;// ./src/locales/ind.json
        const ind_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"देखें {scan}","after-withdrawal-you-receive":"निकासी के बाद आपको अपने वॉलेट में प्राप्त होगा ","airdrop-header.title":"Airdrop Tracker","airdrop.text":"सभी LRT airdropके स्थिति का ट्रैक रखें, AutoLayer Airdrop Trackerका उपयोग करें - प्रत्येक चरण का मॉनिटर करें, देखें कि दावे खुले हैं, और अपने पुरस्कारों को तुरंत दावा करने के लिए सीधे लिंक तक पहुँचें.","airdrop.title":"खोजें AutoLayer Airdrop Tracker","announcement":"घोषणा","apr":"APR","assets":"Assets","aubnb.banner.text":"BNB चेन इकोसिस्टम के लिए LRTs का भविष्य।","autolayer-info.points":"Autolayer पॉइंट्स","autolayer-multiplier":"*AutoLayer* मल्टीप्लायर","avs-info-box.incentives":"प्रोत्साहन","avs-info-box.staked":"फिर से स्टेक किया गया TVL","avs-section.extended":"*{n}* और देखें","avs-section.hide":"छिपाएँ","avs-section.title":"Actively Validated Services","back-to-dashboard":"डैशबोर्ड पर वापस","banner-info.title":"यह उत्पाद कैसे Yields उत्पन्न करता है?","binace-network-notice":"*Note:* LRTs BNB Chain पर आधिकारिक रूप से समर्थित नहीं हैं; इसलिए इन्हें धारण करने से आपके EigenLayer या LRT points में योगदान नहीं होगा। हालांकि यह आपको AutoLayer points प्रदान करेगा।.","change-network":"नेटवर्क बदलें","change-network-to":"अपनी नेटवर्क को स्विच करें ","change-to-arbitrum":"कृपया Arbitrum नेटवर्क पर स्विच करें।.","change-to-bsc":"Binance Smart Chain पर स्विच करें","color-scheme.dark":"डार्क मोड","color-scheme.light":"लाइट मोड","coming-soon":"जल्दी आ रहा है","connect-wallet":"वॉलेट कनेक्ट करें","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"वॉलेट कनेक्ट करें","continue":"जारी रखें","copied-bubble.text":"कॉपी किया गया!","dashboard.autoLayer":"Autolayer पॉइंट्स","dashboard.bedrock":"Bedrock अंक","dashboard.claystack":"ClayStack अंक","dashboard.defi-strategies":"डीफी स्ट्रैटेजीज","dashboard.eigenLayer":"Eigenlayer पॉइंट्स","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO पॉइंट्स","dashboard.liquid-strategies":"Restaking स्ट्रैटेजीज","dashboard.mellow":"Mellow अंक","dashboard.one-click-lrst":"1-क्लिक Liquid Restaking","dashboard.one-click-restaking":"1-क्लिक Liquid staking","dashboard.other-points":"अन्य पॉइंट्स","dashboard.primestaked":"Prime अंक","dashboard.puffer":"Puffer Finance","dashboard.renzo":"Renzo पॉइंट्स","dashboard.select-this-product":"इस उत्पाद को चुनें","dashboard.stake":"स्टेक करें","dashboard.swbtc":"Black Pearls अंक","dashboard.swell":"Swellnetwork","dashboard.symbiotic":"Symbiotic अंक","dashboard.uni":"Uni अंक","dashboard.weeth":"Ether.fi अंक","dashboard.your-deposit":"आपका जमा","deposit-more":"अधिक जमा करें","deposit-step-approving-token.done":"टोकन स्वीकृत.","deposit-step-approving-token.fail":"टोकन स्वीकृति त्रुटि","deposit-step-approving-token.running":"टोकन स्वीकृति का प्रतीक्षा कर रहा है...","deposit-step-getting-route.done":"स्वैप के लिए मार्ग प्राप्त हुआ।.","deposit-step-getting-route.fail":"मार्ग प्राप्त करने में त्रुटि। कृपया कोई अन्य टोकन प्रयास करें।","deposit-step-getting-route.running":"स्वैपिंग के लिए मार्ग प्राप्त कर रहा है...","deposit-step-scan.link":"*{scan}* पर लेन-देन देखें","deposit-step-sending-token.done":"ऑपरेशन हो गया।.","deposit-step-sending-token.fail":"त्रुटि स्वैपिंग","deposit-step-sending-token.running":"ऑपरेशन की पुष्टि का प्रतीक्षा कर रहा है","deposit-step-signing.done":"साइन किया गया.","deposit-step-signing.fail":"लेन-देन साइन करने में त्रुटि.","deposit-step-signing.running":"साइनिंग का इंतजार कर रहे हैं","deposit.tx-points-earned":"इस लेन-देन के साथ आपने कमाई है","details":"विवरण","disconnect":"डिस्कनेक्ट","discontinued-notice.text":"Claystack बंद हो रहा है। कृपया अपनी संपत्तियों को निकाल लें और अधिक जानकारी के लिए उनके{link}को देखें। धन्यवाद!","discontinued-notice.title":"परियोजना बंद कर दी गई।","email-placeholder":"अपना ईमेल पता दर्ज करें","error":"त्रुटि","error-loading-data":"डेटा लोड करने में त्रुटि","error-loading-tokens-balance":"टोकन शेषता लोड करने में त्रुटि","error-loading-your-values":"आपके मूल्यों को लोड करने में त्रुटि","error.404-text":"माफ़ करें, आपके द्वारा अनुरोध किया गया पृष्ठ नहीं मिला गया था","expand":"विस्तार करें","footer.audited-by":"ऑडिट करें","footer.community.announcements":"घोषणाएँ","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Telegram ग्रुप","footer.community.title":"समुदाय","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"हमारे बारे में","footer.company.blog":"ब्लॉग","footer.company.title":"कंपनी","footer.help.feed-back":"सुझाव भेजें","footer.help.support-docs":"समर्थन दस्तावेज़","footer.help.talk-support":"समर्थन से बात करें","footer.help.title":"सहायता","footer.info.audit":"ऑडिट","footer.info.docs":"दस्तावेज़","footer.info.github":"Github","footer.info.media":"मीडिया किट","footer.info.medium":"Medium","footer.info.title":"जानकारी","footer.legacy":"विरासत एक्सेस (Tortle Ninja)","footer.legal.privacy":"गोपनीयता नीति","footer.legal.terms":"उपयोग की शर्तें","footer.legal.title":"कानूनी","footer.peckshield":"*PeckShield* ऑडिट चेक करें","funds-wallet":"फंड आपके वॉलेट में हैं!","go-to-airdrop-checker.link":"यहाँ","go-to-airdrop-checker.text":"अपनी LAY3R आवंटन की जाँच करने के लिए अभी {here} क्लिक करें.","go-to-position":"पोजीशन पर जाएं","how-get-whitelisted":"व्हाइटलिस्ट में कैसे शामिल हों","ido-banner.text":"*$LAY3R IDO* लाइव होने वाला है","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"आद्यतन मात्रा (24h)","landing.hero-banner.text":"Ethereum Restaking के लाभों का लाभ उठाएं।","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"भाषा","language-selector.title":"भाषा का चयन करें","launch-button.default-text":"डैप लॉन्च करें","launch-button.landing-hero-banner":"AutoLayer लॉन्च करें","learn-more":"और अधिक जानें","left-point.actual-value":"वास्तविक मूल्य","left-point.deposited":"जमा किया गया","left-point.restaking-rewards":"Restaking रिवॉर्ड्स","left-point.staking-rewards":"Staking रिवॉर्ड्स","left-points-fallback":"*आपका वॉलेट* कनेक्ट करने के लिए जारी रखें।.","loading":"लोड हो रहा है...","loyalty-points":"लॉयल्टी पॉइंट्स","max":"अधिकतम","meta.airdrop.description":"AutoLayer′sAirdropTracker का उपयोग करके सभी LRT airdrops की स्थिति पर नजर रखें - प्रत्येक चरण की निगरानी करें, जांचें कि क्या दावे खुले हैं, और तुरंत अपने इनाम का दावा करने के लिए सीधे लिंक तक पहुंचें।🪂","meta.airdrop.title":" AutoLayer Airdrop Tracker के साथ आगे रहें!","meta.aubnb.description":"AuBNB शीर्ष yields और एकीकृत liquidity के साथ BNB Chain पर Liquid Restaked Tokens (LRTs) को पुनर्परिभाषित करता है, और $LAY3R पुरस्कारों में 52% APR तक की पेशकश करता है! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"सबसे बड़ा restaking बाज़ार जिसमें उन्नत risk-reward analytics, पॉइंट्स प्रबंधन, और संरचित उत्पाद शामिल हैं।.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"प्रत्येक सफल संदर्भ के साथ अपने और अपने दोस्त दोनों के लिए बोनस AutoLayer Points कमाएं!","meta.referrals.title":"दोस्तों को संदर्भित करें और AutoLayer Points कमाएं!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"और जल्दी ही आ रहा है","more-info":"अधिक जानकारी","network":"नेटवर्क","network-selector.actual":"वास्तविक नेटवर्क","network-selector.title":"नेटवर्क बदलें","placeholder.token-selector":"टोकन खोजें...","pool-token-table.balance":"शेष राशि","pool-token-table.token":"Token","pool-token-table.token-weight":"Token %","pool-token-table.usd-value":"अमरीकी डालर मूल्य","referrals":"संदर्भ","referrals-header.title":"संदर्भ","referrals-info-card.title.active-code":"सक्रिय संदर्भ कोड","referrals-info-card.title.claimable-points":"दावे योग्य अंक","referrals-info-card.title.points-earned":"प्राप्त अंक","referrals-info-card.title.referrals-traders":"संदर्भ व्यापारी","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"संदर्भ कोड केवल वर्तमान नेटवर्क पर मान्य होते हैं। यदि आप चाहते हैं कि आपका कोड कई चेन पर काम करे, तो आपको प्रत्येक के लिए एक अलग कोड बनाना होगा।","referrals.affiliates.header.code":"संदर्भ कोड","referrals.affiliates.header.create":"बनाएं","referrals.affiliates.header.title":"संदर्भ का कोड","referrals.affiliates.header.trader":"संदर्भ व्यापारी","referrals.affiliates.header.volume":"कुल मात्रा","referrals.dialog.create.button":"कोड बनाएं","referrals.dialog.create.description-1":"ऐसा लगता है कि आपके पास साझा करने के लिए कोई संदर्भ कोड नहीं है.","referrals.dialog.create.description-2":"अब एक बनाएं और कैशबैक कमाना शुरू करें!","referrals.dialog.create.error.claimed":"संदर्भ कोड पहले से मौजूद है","referrals.dialog.create.input.label":"कोड दर्ज करें","referrals.dialog.create.input.placeholder":"अपना कोड टाइप करें...","referrals.dialog.create.success":"कोड सफलतापूर्वक बनाया गया है.","referrals.dialog.create.title":"संदर्भ कोड बनाएं","referrals.dialog.error":"एक अप्रत्याशित त्रुटि हुई है, कृपया पुनः प्रयास करें.","referrals.dialog.insert.button":"संदर्भ कोड दर्ज करें","referrals.dialog.insert.description":"कृपया कमीशन छूट का लाभ उठाने के लिए संदर्भ कोड दर्ज करें.","referrals.dialog.insert.error.claimed":"कोड पहले ही दावा किया जा चुका है","referrals.dialog.insert.error.not-exists":"संदर्भ कोड मौजूद नहीं है","referrals.dialog.insert.error.same-owner":"आप अपना खुद का कोड दावा नहीं कर सकते","referrals.dialog.insert.input.label":"कोड दर्ज करें","referrals.dialog.insert.input.placeholder":"संदर्भ कोड दर्ज करें...","referrals.dialog.insert.success":"कोड सफलतापूर्वक दर्ज किया गया है.","referrals.dialog.insert.title":"संदर्भ कोड पेश करें","referrals.text":"अपने दोस्तों को AutoLayer पर व्यापार करने के लिए आमंत्रित करें और अतिरिक्त बोनस परत के साथ पुरस्कृत हों: आपके और आपके दोस्त के लिए अतिरिक्त AutoLayer Points!","referrals.title":"AutoLayer रेफरल प्रोग्राम","refferrals-tab-buttons-affiliates":"साझेदार","refferrals-tab-buttons-traders":"व्यापारी","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"आपके points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL गारंटी के रूप में प्रयुक्त होता है","risk-box.dexes":"TVL dexes पर liquidity के रूप में","select-position":"position चयन करें","select-wallet-modal.connect-wallet":"वॉलेट कनेक्ट करें","select-wallet-modal.waiting.confirm":"कृपया अपने वॉलेट पर संबंधित क्रिया की पुष्टि करें","select-wallet-modal.waiting.connecting":"अपने वॉलेट से कनेक्ट हो रहा है","select-wallet-modal.waiting.signing":"साइनेचर के लिए प्रतीक्षा कर रहा है","share-link":"लिंक कॉपी करें","share-link-success":"कॉपी किया गया","share-telegram":"Telegram पर साझा करें","share-twitter":"X पर साझा करें","stake":"स्टेक","stake-banner.description":"Stake LAY3R को स्टेक करें और 35% APY तक कमाएँ।","stake-banner.title":"LAY3R स्टेकिंग","stake.banner.items.rewards":"आपका कुल पुरस्कार","stake.banner.items.total":"कुल LAY3R स्टेक किया गया","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"आपका स्टेक","stake.banner.title":"LAY3R का स्टेक करें और पुरस्कार अर्जित करें","stake.max-available-amount":"स्टेक करने के लिए अधिकतम उपलब्ध राशि: ","stake.staking-data.buttons.claim":"पुरस्कार प्राप्त करें","stake.staking-data.buttons.stake":"Stake पुरस्कार","stake.staking-data.buttons.unstake":"स्टेक हटाएं","stake.staking-data.compounding":"चक्रवृद्धि","stake.staking-data.days":"दिन","stake.staking-data.header.actions":"क्रियाएँ","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"क्षमता","stake.staking-data.header.info":"अधिक जानकारी","stake.staking-data.header.lock-term":"लॉक अवधि","stake.staking-data.header.my-rewards":"मेरे पुरस्कार","stake.staking-data.header.my-stake":"मेरा स्टेक","stake.staking-data.header.pools":"पूल","stake.staking-data.title":"सक्रिय पूल","stake.staking-dialog.stake.approved.error":"LAY3R स्वीकृति पूरी नहीं हुई","stake.staking-dialog.stake.approved.loading":"स्वीकृति की प्रतीक्षा हो रही है","stake.staking-dialog.stake.approved.success":"LAY3R स्वीकृति पूरी हुई","stake.staking-dialog.stake.confirmation.error":"पुष्टिकरण रद्द किया गया","stake.staking-dialog.stake.confirmation.loading":"पुष्टिकरण की प्रतीक्षा हो रही है","stake.staking-dialog.stake.confirmation.success":"पुष्टिकरण पूरा हुआ","stake.staking-dialog.steps.done-claim":"आपके पुरस्कार आपके वॉलेट में हैं","stake.staking-dialog.steps.done-restake":"आपके पुरस्कारों को restake किया गया","stake.staking-dialog.steps.done-staking":"फंड सफलतापूर्वक स्टेक किया गया!","stake.staking-dialog.steps.done-unstaking":"आपके LAY3R आपके वॉलेट में हैं","start-inviting":"आमंत्रित करना शुरू करें","strategies":"रणनीतियाँ","subscribe":"सब्सक्राइब","swap":"स्वैप","swap-from":"स्वैप से","token-selector.deposit":"जमा","token-selector.preview":"अनुमान","token-selector.withdraw":"निकासी करें","withdraw":"निकासी","your-portfolio":"आपका पोर्टफोलियो"}');
        ;// ./src/locales/ru.json
        const ru_namespaceObject = /*#__PURE__*/JSON.parse('{"account-data.view":"Посмотреть на {scan}","after-withdrawal-you-receive":"После снятия вы получите на свой кошелек.","airdrop-header.title":"Airdrop Tracker","airdrop.text":"Отслеживайте статус всех LRT airdrops с помощью AutoLayer Airdrop Tracker - отслеживайте каждую фазу, проверяйте, открыты ли претензии, и получайте мгновенный доступ к прямым ссылкам для получения своих наград.","airdrop.title":"Откройте для себя AutoLayer Airdrop Tracker","announcement":"объявление","apr":"APR","assets":"Assets","aubnb.banner.text":"Будущее LRT для экосистемы цепочки BNB.","autolayer-info.points":"AutoLayer points","autolayer-multiplier":"*AutoLayer* multiplier","avs-info-box.incentives":"Стимулы","avs-info-box.staked":"Рестейкнутый TVL","avs-section.extended":"Посмотреть еще *{n}*","avs-section.hide":"Скрыть","avs-section.title":"Actively Validated Services","back-to-dashboard":"Вернуться на главную страницу.","banner-info.title":"Как этот продукт генерирует Yield?","binace-network-notice":"*Note:* LRTs официально не поддерживаются на BNB Chain; поэтому их хранение не будет способствовать вашему EigenLayer или LRT points. Однако это даст вам AutoLayer points.","change-network":"Изменить сеть.","change-network-to":"Чтобы продолжить, переключите вашу сеть на.","change-to-arbitrum":"Пожалуйста, переключитесь на сеть Arbitrum.","change-to-bsc":"Переключиться на Binance Smart Chain","color-scheme.dark":"Темный режим","color-scheme.light":"Светлый режим","coming-soon":"Скоро.","connect-wallet":"Подключить кошелек","connect-wallet.airdrop":"Airdrop Tracker","connect-wallet.default-text":"Подключить кошелек","continue":"Продолжить","copied-bubble.text":"Скопировано!","dashboard.autoLayer":"AutoLayer Points","dashboard.bedrock":"Bedrock Points","dashboard.claystack":"ClayStack Points","dashboard.defi-strategies":"DeFi Strategies","dashboard.eigenLayer":"EigenLayer Points","dashboard.ether":"Ether.fi Points","dashboard.inception":"InceptionLRT Totems","dashboard.kelp":"Kelp DAO Points","dashboard.liquid-strategies":"Restaking Strategies","dashboard.mellow":"Mellow Баллы","dashboard.one-click-lrst":"1-Click Liquid Restaking","dashboard.one-click-restaking":"1-Click Liquid Staking","dashboard.other-points":"Other Points","dashboard.primestaked":"Prime Points","dashboard.puffer":"Puffer Points","dashboard.renzo":"Renzo Points","dashboard.select-this-product":"Выбрать этот продукт.","dashboard.stake":"Stake","dashboard.swbtc":"Очки Black Pearls","dashboard.swell":"Swell Points","dashboard.symbiotic":"Symbiotic Баллы","dashboard.uni":"Uni Points","dashboard.weeth":"Ether.fi Points","dashboard.your-deposit":"Ваш депозит","deposit-more":"Внести больше","deposit-step-approving-token.done":"Токен утвержден.","deposit-step-approving-token.fail":"Ошибка утверждения токена","deposit-step-approving-token.running":"Ожидание утверждения токена","deposit-step-getting-route.done":"Получен маршрут для обмена.","deposit-step-getting-route.fail":"Ошибка получения маршрута. Попробуйте другой токен.","deposit-step-getting-route.running":"Получение маршрута для обмена...","deposit-step-scan.link":"Посмотреть транзакцию на *{scan}*","deposit-step-sending-token.done":"Операция выполнена.","deposit-step-sending-token.fail":"Ошибка обмена","deposit-step-sending-token.running":"Ожидание подтверждения операции","deposit-step-signing.done":"Подписано.","deposit-step-signing.fail":"Ошибка подписи транзакции.","deposit-step-signing.running":"Ожидание подписи","deposit.tx-points-earned":"С этой транзакцией вы заработали","details":"Детали","disconnect":"Отключиться","discontinued-notice.text":"Claystack закрывается. Пожалуйста, выведите ваши активы и ознакомьтесь с их {link} для получения более подробной информации. Спасибо!","discontinued-notice.title":"Проект прекращает своё существование.","email-placeholder":"Введите ваш адрес электронной почты","error":"Ошибка","error-loading-data":"Ошибка загрузки данных","error-loading-tokens-balance":"Ошибка загрузки баланса токенов","error-loading-your-values":"Ошибка загрузки ваших значений","error.404-text":"Извините, запрошенная страница не найдена","expand":"Развернуть","footer.audited-by":"Проверено","footer.community.announcements":"Announcements","footer.community.coinmarketcap":"CoinMarketCap","footer.community.discord":"Discord","footer.community.guild":"Guild","footer.community.telegram":"Группа в Telegram","footer.community.title":"Сообщество","footer.community.twitter":"Twitter","footer.community.youtube":"Youtube","footer.company.about":"О нас","footer.company.blog":"Блог","footer.company.title":"Компания","footer.help.feed-back":"Отправить отзыв","footer.help.support-docs":"Support Docs","footer.help.talk-support":"Обратиться в службу поддержки","footer.help.title":"Помощь","footer.info.audit":"Аудит","footer.info.docs":"Документы","footer.info.github":"Github","footer.info.media":"Media Kit","footer.info.medium":"Medium","footer.info.title":"Информация","footer.legacy":"Доступ к наследию (Tortle Ninja)","footer.legal.privacy":"Политика конфиденциальности","footer.legal.terms":"Условия использования","footer.legal.title":"Юридическая информация","footer.peckshield":"Проверить аудит *PeckShield*","funds-wallet":"Средства находятся в вашем кошельке!","go-to-airdrop-checker.link":"Здесь","go-to-airdrop-checker.text":"Проверьте ваше распределение LAY3R сейчас, нажав {here}.","go-to-position":"Перейти к позиции","how-get-whitelisted":"Как попасть в белый список","ido-banner.text":"*$LAY3R IDO* начинается через ","info-box.apr":"APR","info-box.tvl":"TVL","info-box.volume":"Volume (24h)","landing.hero-banner.text":"Используйте преимущества Ethereum Re-Staking","landing.hero-banner.title":"All LRTfi. One interface.","language-selector.text":"Язык","language-selector.title":"Выбрать язык","launch-button.default-text":"Запустить dapp","launch-button.landing-hero-banner":"Запустить AutoLayer","learn-more":"Узнать больше","left-point.actual-value":"Фактическая стоимость","left-point.deposited":"Внесено","left-point.restaking-rewards":"Restaking Rewards","left-point.staking-rewards":"Staking Rewards","left-points-fallback":"Подключите *ваш кошелек* чтобы продолжить.","loading":"Загрузка...","loyalty-points":"Loyalty Points","max":"Максимум","meta.airdrop.description":"Отслеживайте статус всех LRT airdrops с помощью AutoLayer\'s Airdrop Tracker - следите за каждой фазой, проверяйте, открыты ли заявки, и получайте доступ к прямым ссылкам для мгновенного получения ваших наград.🪂","meta.airdrop.title":"Будьте в курсе с AutoLayer Airdrop Tracker!","meta.aubnb.description":"AuBNB переопределяет Liquid Restaked Tokens (LRTs)33 на BNB Chain с лучшими yields и единой liquidity, предлагая до 52% APR в виде наград $LAY3R! 📈","meta.aubnb.title":"AutoLayer Restaked BNB (AuBNB) | AutoLayer","meta.description":"Крупнейший restaking рынок с продвинутой risk-reward analytics, управлением очками и структурированными продуктами.","meta.keywords":"Cryptocurrency, blockchain, decentralized finance, DeFi, Investment, AutoLayer, Ethereum, Arbitrum, Liquid Restaked Tokens, LRT, Liquid Staked Tokens, LST, AVS, AVSs, operators, incentives, LRTfi, UniSwap, SushiSwap, Balancer Labs, Camelot DEX, Yearn Finance, GMX, protocol, Slashing Bounties, autocompounding, token liquification, liquid assets, illiquid assets, AVS Scoring, staking, restaking, liquid staking, liquid restaking, ETH Staking Yields, EigenLayer points, liquidity, provider, minting, swaps, APR, ERC-20, marginal cost, analytics engine, Key Performance Indicators (KPI), non-custodial, RPCs, Profit and Loss, PNL, staking rewards, LPs, NFTs, Virtual Operators, Professional Operators TVL, Community TVL, automation, automating, securing, vaults, inflation, gauge, P2P, LRT Scoring, AVS tokens, mint, burn, tokens, slashing tests, bounties, auto-delayed, LRT Rehypothecation, leverage, strategy, boost, yields, principal, compound, loop, risk, smart contract, points, co-efficient, non-liquid, non-tradeable, LLTIP, positions, asset, liquidify, dumping, dapp, value, holders, $LAY3R, fees, gas, Point-Derivatives, Peckshield, beta, audit, convert, platform, active strategies, triggers, longing assets, shorting assets, perpetual node, node, farm, oracles, on-chain, off-chain, DEX, cost, Progressive Web App, PWA, mobile app, data protection","meta.referrals.description":"Зарабатывайте бонусные AutoLayer Points для вас и вашего друга за каждую успешную рекомендацию!","meta.referrals.title":"Приглашайте друзей и зарабатывайте AutoLayer Points!","meta.title":"AutoLayer","middle-section.multipliers":"Multipliers","middle-section.pool-composition":"Pool Composition","more-coming-soon":"Больше скоро","more-info":"Дополнительная информация","network":"Сеть","network-selector.actual":"Фактическая сеть","network-selector.title":"Изменить сеть","placeholder.token-selector":"Поиск токена...","pool-token-table.balance":"Баланс","pool-token-table.token":"Токен","pool-token-table.token-weight":"Токен %","pool-token-table.usd-value":"Значение","referrals":"рефералы","referrals-header.title":"рефералы","referrals-info-card.title.active-code":"Активный реферальный код","referrals-info-card.title.claimable-points":"Баллы, которые можно получить","referrals-info-card.title.points-earned":"Заработанные баллы","referrals-info-card.title.referrals-traders":"Реферальные трейдеры","referrals-info-card.title.trading-volume":"Trading Volume","referrals.advice":"Реферальные коды действительны только в текущей сети. Если вы хотите, чтобы ваш код работал в нескольких сетях, вам нужно создать отдельный код для каждой из них.","referrals.affiliates.header.code":"Реферальный код","referrals.affiliates.header.create":"Создать","referrals.affiliates.header.title":"Код реферала","referrals.affiliates.header.trader":"Реферальные трейдеры","referrals.affiliates.header.volume":"Общий объем","referrals.dialog.create.button":"Создать код","referrals.dialog.create.description-1":"Похоже, у вас нет реферального кода для распространения.","referrals.dialog.create.description-2":"Создайте один сейчас и начните зарабатывать кэшбэк!","referrals.dialog.create.error.claimed":"Реферальный код уже существует","referrals.dialog.create.input.label":"Введите код","referrals.dialog.create.input.placeholder":"Введите ваш код...","referrals.dialog.create.success":"Код успешно создан.","referrals.dialog.create.title":"Создать реферальный код","referrals.dialog.error":"Произошла неожиданная ошибка, пожалуйста, попробуйте еще раз.","referrals.dialog.insert.button":"Введите реферальный код","referrals.dialog.insert.description":"Пожалуйста, введите реферальный код, чтобы воспользоваться скидками на комиссии.","referrals.dialog.insert.error.claimed":"Код уже был использован","referrals.dialog.insert.error.not-exists":"Реферальный код не существует","referrals.dialog.insert.error.same-owner":"Нельзя использовать собственный код","referrals.dialog.insert.input.label":"Введите код","referrals.dialog.insert.input.placeholder":"Введите реферальный код...","referrals.dialog.insert.success":"Код успешно введен.","referrals.dialog.insert.title":"Введите реферальный код","referrals.text":"Пригласите своих друзей торговать на AutoLayer и получите дополнительный слой бонусов: дополнительные AutoLayer Points для вас и вашего друга!","referrals.title":"Реферальная программа AutoLayer","refferrals-tab-buttons-affiliates":"Партнеры","refferrals-tab-buttons-traders":"Трейдеры","restake":"Restake","reward-card.claim":"Claim","reward-card.points-gathered":"Ваши points: {n}","reward-card.stage":"Stage: {s}","risk-box.collateral":"TVL используется в качестве залога","risk-box.dexes":"TVL как liquidity на децентрализованных биржах","select-position":"Выбрать позицию","select-wallet-modal.connect-wallet":"Подключить кошелек","select-wallet-modal.waiting.confirm":"Подтвердите операцию на вашем кошельке","select-wallet-modal.waiting.connecting":"Подключение к вашему кошельку","select-wallet-modal.waiting.signing":"Ожидание подписи","share-link":"Скопировать ссылку","share-link-success":"Скопировано","share-telegram":"Поделиться в Telegram","share-twitter":"Поделиться на X","stake":"Внести","stake-banner.description":"Делайте стейкинг ваших LAY3R, чтобы заработать до 35% годовых (APY).","stake-banner.title":"LAY3R Стейкинг","stake.banner.items.rewards":"Ваши общие награды","stake.banner.items.total":"Всего LAY3R в стейкинге","stake.banner.items.usd":"TVL$USD","stake.banner.items.userStake":"Ваш стейк","stake.banner.title":"Stake LAY3R и зарабатывайте награды","stake.max-available-amount":"Максимальная доступная сумма для стейкинга: ","stake.staking-data.buttons.claim":"Забрать награду","stake.staking-data.buttons.stake":"Stake награду","stake.staking-data.buttons.unstake":"Unstake","stake.staking-data.compounding":"КОМПОУНДИНГ","stake.staking-data.days":"ДНЕЙ","stake.staking-data.header.actions":"Действия","stake.staking-data.header.apy":"APY","stake.staking-data.header.capacity":"Вместимость","stake.staking-data.header.info":"Подробнее","stake.staking-data.header.lock-term":"Срок блокировки","stake.staking-data.header.my-rewards":"Мои награды","stake.staking-data.header.my-stake":"Мой стейк","stake.staking-data.header.pools":"Пулы","stake.staking-data.title":"Активные пулы","stake.staking-dialog.stake.approved.error":"LAY3R одобрение не завершено","stake.staking-dialog.stake.approved.loading":"Ожидание одобрения","stake.staking-dialog.stake.approved.success":"LAY3R одобрение завершено","stake.staking-dialog.stake.confirmation.error":"Подтверждение отменено","stake.staking-dialog.stake.confirmation.loading":"Ожидание подтверждения","stake.staking-dialog.stake.confirmation.success":"Подтверждение завершено","stake.staking-dialog.steps.done-claim":"Ваши награды в вашем кошельке","stake.staking-dialog.steps.done-restake":"Ваши награды были restake","stake.staking-dialog.steps.done-staking":"Средства успешно застейканы!","stake.staking-dialog.steps.done-unstaking":"Ваши LAY3R в вашем кошельке","start-inviting":"Начните приглашать","strategies":"Strategies","subscribe":"Подписаться","swap":"Обмен","swap-from":"Обмен с","token-selector.deposit":"Внести","token-selector.preview":"Оценка обмена","token-selector.withdraw":"Вывести","withdraw":"Вывести","your-portfolio":"Ваш портфель"}');
        ;// ./src/locales/index.ts
/* harmony default export */ const locales = ({ en: en_namespaceObject, es: es_namespaceObject, zh: zh_namespaceObject, vi: vi_namespaceObject, ko: ko_namespaceObject, uk: uk_namespaceObject, fr: fr_namespaceObject, in: in_namespaceObject, jp: jp_namespaceObject, th: th_namespaceObject, tk: tk_namespaceObject, ind: ind_namespaceObject, ru: ru_namespaceObject });

        /***/
}),

/***/ 16156:
/*!********************************************!*\
  !*** ./src/routes/index.tsx + 387 modules ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
          A: () => (/* binding */ routes)
        });

        // EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js
        var jsx_runtime = __webpack_require__(74848);
        // EXTERNAL MODULE: ./node_modules/react/index.js
        var react = __webpack_require__(96540);
        // EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 17 modules
        var es = __webpack_require__(2008);
        // EXTERNAL MODULE: ./node_modules/react-router/dist/index.js
        var dist = __webpack_require__(47767);
        // EXTERNAL MODULE: ./node_modules/react-intl/lib/src/components/message.js
        var message = __webpack_require__(58065);
        // EXTERNAL MODULE: ./node_modules/react-router-dom/dist/index.js
        var react_router_dom_dist = __webpack_require__(84976);
        ;// ./src/components/ButtonsChooseRST/ButtonChooseRST.tsx
        const ButtonsChooseRST = () => { const getButtonClassName = isActive => `button ${isActive ? "choosen" : ""}`; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "tab-buttons", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "scroll-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* NavLink */.k2, { className: ({ isActive }) => getButtonClassName(isActive), to: "/lrt", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "dashboard.one-click-lrst" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* NavLink */.k2, { className: ({ isActive }) => getButtonClassName(isActive), to: "/lst", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "dashboard.one-click-restaking" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* NavLink */.k2, { className: ({ isActive }) => getButtonClassName(isActive), to: "/defi-strategies", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "dashboard.defi-strategies" }) })] }) }) };/* harmony default export */ const ButtonChooseRST = (ButtonsChooseRST);
        // EXTERNAL MODULE: ./node_modules/@gluedigital/ruse-fetch-extras/dist/index.esm.js
        var index_esm = __webpack_require__(743);
        // EXTERNAL MODULE: ./src/constants.ts
        var constants = __webpack_require__(38660);
        ;// ./src/hooks/useTokensLst.ts
        const useTokensLst = () => { const route = "/lst"; const tokens = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + route); return tokens };/* harmony default export */ const hooks_useTokensLst = (useTokensLst);
        ;// ./src/components/ErrorBoundary/ErrorBoundary.tsx
        class ErrorBoundary extends react.Component { static getDerivedStateFromError(error) { console.error("ErrorBoundary caught an error", error); return { hasError: true } } componentDidCatch(error, info) { console.error("ErrorBoundary caught an error", error, info) } render() { if (this.state.hasError) { if (this.props.fallback) { return this.props.fallback } else { return /*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children: "Something went wrong." }) } } else { return this.props.children } } constructor(props) { super(props); this.state = { hasError: false } } }/* harmony default export */ const ErrorBoundary_ErrorBoundary = (ErrorBoundary);
        ;// ./src/hooks/useTokensLrst.ts
        const useTokensLrst = () => { const route = "/lrst"; const tokens = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + route); return tokens };/* harmony default export */ const hooks_useTokensLrst = (useTokensLrst); const useTokensLrtCrosschain = () => { const route = "/lrt-crosschain"; const tokens = useFetch(dataMicroserviceUrl + route); return tokens }; const useSingleTokenLrtCrosschain = tokenId => { const route = `/lrt-crosschain/${tokenId}`; const token = useFetch(dataMicroserviceUrl + route); return token };
        ;// ./src/components/Loading/Loading.tsx
        const Loading = ({ withText = false, colored = false, mini = false }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "loading", className: `${colored ? "colored" : ""} ${mini ? "mini" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "loader" }), withText &&/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "loading" }) })] }) };/* harmony default export */ const Loading_Loading = (Loading);
        // EXTERNAL MODULE: ./node_modules/react-intl/lib/src/components/useIntl.js
        var useIntl = __webpack_require__(6442);
        ;// ./src/utils/compactNumbers.js
        const compactNumbers = (amount = 0, digits = 1, locale = "en") => { if (isNaN(amount)) return "-"; return new Intl.NumberFormat(locale, { notation: "compact", maximumFractionDigits: amount < .1 ? 4 : digits }).format(amount) };
        ;// ./src/hooks/useCompactNumbers.ts
        const useCompactNumbers = () => { const { locale } = (0, useIntl/* default */.A)(); const result = (amount = 0, digits = 1) => compactNumbers(amount, digits, locale); return result };
        ;// ./src/components/GenericPoints/GenericPoints.tsx
        const typeConfig = { tvl: { prefix: "$ ", suffix: "" }, restaking: { prefix: "", suffix: " %" }, default: { prefix: "", suffix: "" } }; const GenericPoints = ({ type, points }) => { const title = type === "tvl" ? "tvl" :/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: type }); const calc = useCompactNumbers(); const { prefix, suffix } = typeConfig[type] || typeConfig.default; const content = points >= 0 ? `${prefix}${calc(points, 2)}${suffix}` :/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "coming-soon" }); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "points-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children: title }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { title: points.toFixed(2), children: content }) })] }) }; const GenericPointsFallback = ({ pointsType, type = "loading" }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "points-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: pointsType }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("strong", { className: "points-text", children: [" ",/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: type })] }) })] }) };/* harmony default export */ const GenericPoints_GenericPoints = (GenericPoints);
        ;// ./src/components/ApyInfo/ApyInfo.tsx
        const ApyInfo = ({ apr }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "apy-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children: "APY" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { title: apr + "%", className: "apy-value", children: [" ", apr ?? "-", " %"] }) })] }) };/* harmony default export */ const ApyInfo_ApyInfo = (ApyInfo);
        ;// ./src/data/tokensImages.json
        const tokensImages_namespaceObject = /*#__PURE__*/JSON.parse('["ankreth.png","arb.png","aubnb.png","aura.png","aurabal.png","bal.png","cbeth.png","crv.png","cseth.png","dai.png","dola.png","eth.png","eeth.png","ezeth.png","geneth.png","gmx.png","grt.png","lay3r.png","ldo.png","link.png","primeeth.png","pufeth.png","rdnt.png","reth.png","rpl.png","rseth.png","rsweth.png","sfrxeth.png","stg.png","sveth.png","TOKEN.svg","uni.png","unieth.png","usdc.e.png","usdt.png","vsta.png","weeth.png","wbtc.png","weth.png","wsteth.png","bnb.png","usdc.png","sol.png","pendle.png","wnbnb.png","near.png","trx.png","doge.png","shiba.png","toncoin.png","xrp.png","ineth.png","pzeth.png","swbtc.png"]');
        ;// ./src/data/avs/avsImages.json
        const avsImages_namespaceObject = /*#__PURE__*/JSON.parse('["eoracle.png","eigenda.png","altlayer.png","brevis.png","lagrange.png","witness-chain.png","omni-network.png","automata.png","openlayer.png","xterio.png","lagrange-zk.png","cyber.png","arpa.png","hyperlane.png"]');
        ;// ./src/data/protocol/protocolImages.json
        const protocolImages_namespaceObject = /*#__PURE__*/JSON.parse('["aave.png","prisma.png","gearbox.png","morpho.png"]');
        ;// ./src/utils/getTokenImage.ts
        const getTokenImage = symbol => { const lowerSymbol = symbol.toLowerCase(); if (tokensImages_namespaceObject.includes(`${lowerSymbol}.png`)) { return `/images/tokens/${lowerSymbol}.png` } return "/images/tokens/TOKEN.svg" }; const getAVSImage = symbol => { const lowerSymbol = symbol.toLowerCase(); if (avsImages_namespaceObject.includes(`${lowerSymbol}.png`)) { return `/images/avs/${lowerSymbol}.png` } return "/images/tokens/TOKEN.svg" }; const getProtocolImage = symbol => { const lowerSymbol = symbol.toLowerCase(); if (protocolImages_namespaceObject.includes(`${lowerSymbol}.png`)) { return `/images/protocol/${lowerSymbol}.png` } return "/images/tokens/TOKEN.svg" };
        ;// ./src/components/TokenImageList/TokenImageList.tsx
        const TokenImageList = ({ tokens = [], mini = false }) => { const max = mini ? 2 : 4; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `token-image-list tokens-${tokens?.length} ${mini ? "mini" : ""}`, children: [tokens?.map(t =>/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage(t.symbol.toLowerCase()), title: t.symbol, alt: t.symbol, className: "token-image" }, t.address)).slice(0, max), tokens?.length > max &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "rest-tokens", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: `+${tokens?.length - max}` }) })] }) };/* harmony default export */ const TokenImageList_TokenImageList = (TokenImageList);
        ;// ./src/static/vectors/fire.svg
        const fire_namespaceObject = __webpack_require__.p + "static/fire.3b773127e2ddaa302012.svg";
        ;// ./src/components/MultiplierInfo/MultiplierInfo.tsx
        const MultiplierInfo = ({ amount }) => { const isOnFire = amount > 1; return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: `multiplier-info ${isOnFire ? "on-fire" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "multiplier-value", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: ["x", amount] }) }), isOnFire &&/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: fire_namespaceObject })] }) };/* harmony default export */ const MultiplierInfo_MultiplierInfo = (MultiplierInfo);
        ;// ./src/static/logos/autolayer/autolayerIconWhite.svg
        const autolayerIconWhite_namespaceObject = __webpack_require__.p + "static/autolayerIconWhite.659d04142a0ba7d33089.svg";
        ;// ./src/static/logos/eigenlayer/eigenlayer-icon-white.svg
        const eigenlayer_icon_white_namespaceObject = __webpack_require__.p + "static/eigenlayer-icon-white.515bb9f3997da868ef7a.svg";
        ;// ./src/static/logos/renzo/renzo-icon-white.svg
        const renzo_icon_white_namespaceObject = __webpack_require__.p + "static/renzo-icon-white.6163b14e852144b5b176.svg";
        ;// ./src/static/logos/kelpdao/kelpdao-icon-white.svg
        const kelpdao_icon_white_namespaceObject = __webpack_require__.p + "static/kelpdao-icon-white.b308e30d83920ac54a4f.svg";
        ;// ./src/static/logos/puffer/puffer-icon-white.svg
        const puffer_icon_white_namespaceObject = __webpack_require__.p + "static/puffer-icon-white.f686203b58bbf9c3c7bf.svg";
        ;// ./src/static/logos/swell/swell-icon-white.svg
        const swell_icon_white_namespaceObject = __webpack_require__.p + "static/swell-icon-white.038f49e5645b420fc91b.svg";
        ;// ./src/static/logos/ether/ether-icon-white.svg
        const ether_icon_white_namespaceObject = __webpack_require__.p + "static/ether-icon-white.0ef7980f56e991bf6eeb.svg";
        ;// ./src/static/logos/bedrock/bedrock-icon-white.svg
        const bedrock_icon_white_namespaceObject = __webpack_require__.p + "static/bedrock-icon-white.0cad1c08f579b30de384.svg";
        ;// ./src/static/logos/primestaked/primestacked-icon-white.svg
        const primestacked_icon_white_namespaceObject = __webpack_require__.p + "static/primestacked-icon-white.38eae1ce2b43e3390241.svg";
        ;// ./src/static/logos/inception/inception-icon-white.svg
        const inception_icon_white_namespaceObject = __webpack_require__.p + "static/inception-icon-white.09b5d349997416046727.svg";
        ;// ./src/static/logos/mellow/mellow-icon-white.svg
        const mellow_icon_white_namespaceObject = __webpack_require__.p + "static/mellow-icon-white.1a3f5bf44b5ab4ce9ca0.svg";
        ;// ./src/static/logos/symbiotic/symbiotic-icon-white.svg
        const symbiotic_icon_white_namespaceObject = __webpack_require__.p + "static/symbiotic-icon-white.1d30ac407f5a32093f45.svg";
        ;// ./src/static/logos/swell/swbtc-icon-white.svg
        const swbtc_icon_white_namespaceObject = __webpack_require__.p + "static/swbtc-icon-white.d1b0fd5b402ff077fa3f.svg";
        ;// ./src/static/logos/whiteIcons.ts
        const WhiteIcons = { autoLayer: autolayerIconWhite_namespaceObject, eigenLayer: eigenlayer_icon_white_namespaceObject, renzo: renzo_icon_white_namespaceObject, kelp: kelpdao_icon_white_namespaceObject, puffer: puffer_icon_white_namespaceObject, swell: swell_icon_white_namespaceObject, ether: ether_icon_white_namespaceObject, bedrock: bedrock_icon_white_namespaceObject, primestaked: primestacked_icon_white_namespaceObject, inception: inception_icon_white_namespaceObject, mellow: mellow_icon_white_namespaceObject, symbiotic: symbiotic_icon_white_namespaceObject, swbtc: swbtc_icon_white_namespaceObject };
        ;// ./src/components/MultiplierInfo/multipliersList.ts
        const multipliersList = { autoLayer: { name: "AutoLayer", value: "autoLayerMultiplier", icon: WhiteIcons.autoLayer }, bedrock: { name: "Bedrock", value: "bedrockMultiplier", icon: WhiteIcons.bedrock }, eigenLayer: { name: "EigenLayer", value: "eigenLayerMultiplier", icon: WhiteIcons.eigenLayer }, etherfi: { name: "Etherfi", value: "etherfiMultiplier", icon: WhiteIcons.ether }, inception: { name: "Inception", value: "inceptionMultiplier", icon: WhiteIcons.inception }, kelp: { name: "Kelp", value: "kelpMultiplier", icon: WhiteIcons.kelp }, mellow: { name: "Mellow", value: "mellowMultiplier", icon: WhiteIcons.mellow }, prime: { name: "Prime", value: "primeMultiplier", icon: WhiteIcons.primestaked }, puffer: { name: "Puffer", value: "pufferMultiplier", icon: WhiteIcons.puffer }, renzo: { name: "Renzo", value: "renzoMultiplier", icon: WhiteIcons.renzo }, swell: { name: "Swell", value: "swellMultiplier", icon: WhiteIcons.swell }, symbiotic: { name: "Symbiotic", value: "symbioticMultiplier", icon: WhiteIcons.symbiotic }, swellBlackPearl: { name: "Black Perls", value: "swellBlackPearlMultiplier", icon: WhiteIcons.swbtc } };
        ;// ./src/components/MultiplierInfo/IconMultiplier/IconMultiplier.tsx
        const IconMultiplier = ({ icon, name }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: `icon-multiplier-${name.toLowerCase().replace(/ /g, "_")}`, className: "icon-multiplier", children: !icon ? "?" :/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: name, loading: "lazy", src: icon, alt: `${name} icon` }) }) };/* harmony default export */ const IconMultiplier_IconMultiplier = (IconMultiplier);
        ;// ./src/components/MultiplierInfo/ListMultiplier/ListMultiplier.tsx
        const ListMultiplier = ({ multipliers, mini }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: `list-multipliers ${mini ? "mini" : ""}`, children: Object.entries(multipliersList).map(([key, value]) => { const multiplierValue = multipliers[key]; if (!multiplierValue) return null; const { icon, name } = value; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `product-multiplier product-multiplier-${name.toLowerCase()}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children: name }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "product-multiplier-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(IconMultiplier_IconMultiplier, { name: name.toLowerCase(), icon: icon }),/*#__PURE__*/(0, jsx_runtime.jsx)(MultiplierInfo_MultiplierInfo, { amount: multiplierValue })] })] }, name) }) }) };/* harmony default export */ const ListMultiplier_ListMultiplier = (ListMultiplier);
        ;// ./src/data/Binance/tokensLRS.json
        const tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0x38","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0x38","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/oAskLTj.jpeg","description":"weETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"}]');
        ;// ./src/data/Binance/tokens.json
        const tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"LAY3R","address":"0xF06ce11836851d71E74e4ffeFa7b73FCc8A27786","decimals":"18","name":"AutoLayer"},{"id":"BNB","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"BNB"},{"id":"USDC","address":"0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d","decimals":"18","name":"USD Coin"},{"id":"USDT","address":"0x55d398326f99059ff775485246999027b3197955","decimals":"18","name":"Tether USD"},{"id":"SOL","address":"0x570A5D26f7765Ecb712C0924E4De545B89fD43dF","decimals":"18","name":"Solana"},{"id":"PENDLE","address":"0xb3Ed0A426155B79B898849803E3B36552f7ED507","decimals":"18","name":"Pendle"},{"id":"WNBNB","address":"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c","decimals":"18","name":"Wrapped BNB"},{"id":"WETH","address":"0x4DB5a66E937A9F4473fA95b1cAF1d1E1D62E29EA","decimals":"18","name":"Wrapped Ether"},{"id":"XRP","address":"0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE","decimals":"18","name":"XRP"},{"id":"DOGE","address":"0xbA2aE424d960c26247Dd6c32edC70B295c744C43","decimals":"8","name":"DDogecoin"},{"id":"SHIBA","address":"0x2859e4544C4bB03966803b044A93563Bd2D0DD4D","decimals":"18","name":"Shiba Inu"},{"id":"TONCOIN","address":"0x76A797A59Ba2C17726896976B7B3747BfD1d220f","decimals":"9","name":"TONCOIN"},{"id":"LINK","address":"0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD","decimals":"18","name":"Chainlink"},{"id":"NEAR","address":"0x1Fa4a73a3F0133f0025378af00236f3aBDEE5D63","decimals":"18","name":"Near"},{"id":"TRX","address":"0xCE7de646e7208a4Ef112cb6ed5038FA6cC6b12e3","decimals":"6","name":"Tron"}]');
        ;// ./src/data/Binance/auBnb.json
        const auBnb_namespaceObject = /*#__PURE__*/JSON.parse('{"id":"auBNB","address":"","name":"AutoLayer Restaked BNB (AuBNB)","decimals":"18","network":"0x38","type":"LRT","multipliers":{"autoLayer":1},"image":"","description":"AuBNB is reimagining Liquid Restaked Tokens (LRTs), backed by BNB, with superior yields and unified liquidity, setting a new standard on the BNB Chain ecosystem. AutoLayer will reward AuBNB holders with up to 52% APR in $LAY3R tokens, transitioning to a sustainable, integrated reward structure that drives long-term value and engagement within the Binance community.","opengraph":""}');
        ;// ./src/data/Binance/index.ts
        const lrtTokens = tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const newTokens = tokens_namespaceObject.slice(0, 3).concat(lrtTokens).concat(tokens_namespaceObject.slice(3)); const BinanceData = { tokensLRS: tokensLRS_namespaceObject, tokens: newTokens, auBnb: auBnb_namespaceObject };
        ;// ./src/utils/networkHelper.ts
        var Networks; (function (Networks) { Networks["arbitrum"] = "0xa4b1"; Networks["ethereum"] = "0x1"; Networks["binance"] = "0x38"; Networks["base"] = "0x2105"; Networks["scroll"] = "0x82750"; Networks["linea"] = "0xe708"; Networks["optimism"] = "0xa"; Networks["mode"] = "0x868b" })(Networks || (Networks = {})); var Environments; (function (Environments) { Environments["localDev"] = "LOCAL_DEV"; Environments["fantomLocalDev"] = "MAINNET_FANTOM_DEV_LOCAL"; Environments["arbitrumLocal"] = "MAINNET_ARBITRUM_DEV_LOCAL"; Environments["mainnetCandidate"] = "MAINNET_DEV"; Environments["mainnetPro"] = "MAINNET_PRO" })(Environments || (Environments = {})); const DEFAULT_NETWORK_ID = "0x38"; const DEFAULT_NETWORK_NAME = "binance"; const DEFAULT_NETWORK_DATA = BinanceData; const DEFAULT_NETWORK = (/* unused pure expression or super */ null && (BINANCE)); const getNetworkName = networkId => { if (networkId === "0xa4b1") return "arbitrum"; else if (networkId === "0x1") return "ethereum"; else if (networkId === "0x38") return "binance"; else if (networkId === "0x2105") return "base"; else if (networkId === "0x82750") return "scroll"; else if (networkId === "0xe708") return "linea"; else if (networkId === "0xa") return "optimism"; else if (networkId === "0x868b") return "mode"; else if (!networkId) return DEFAULT_NETWORK_NAME }; const getNetworkIdByName = networkName => { if (networkName === "arbitrum") return "0xa4b1"; else if (networkName === "ethereum") return "0x1"; else if (networkName === "binance") return "0x38"; else if (networkName === "base") return "0x2105"; else if (networkName === "scroll") return "0x82750"; else if (networkName === "linea") return "0xe708"; else if (networkName === "optimism") return "0xa"; else if (networkName === "mode") return "0x868b"; else return DEFAULT_NETWORK_ID }; const getNativeCurrencySymbol = networkId => { if (networkId === "0x38") return "BNB"; else return "ETH" }; const getItemByNetwork = networkId => { let scanName; let networkTag; switch (networkId) { case "0xa4b1": scanName = "ARBIScan"; networkTag = "Arbitrum"; break; case "0x38": scanName = "BscScan"; networkTag = "BNB Chain"; break; case "0x1": scanName = "Etherscan"; networkTag = "Ethereum"; break; case "0x2105": scanName = "BaseScan"; networkTag = "Base"; break; case "0x82750": scanName = "ScrollScan"; networkTag = "Scroll"; break; case "0xe708": scanName = "LineaScan"; networkTag = "Linea"; break; case "0xa": scanName = "OptimismScan"; networkTag = "Optimism"; break; case "0x868b": scanName = "ModeScan"; networkTag = "Mode"; break; default: scanName = "Scan"; break }return { scanName, networkTag } };
        ;// ./src/static/logos/protocols/balancer.png
        const balancer_namespaceObject = __webpack_require__.p + "static/balancer.e2940c661dfebf1f50f7.png";
        ;// ./src/static/logos/protocols/gmx.png
        const gmx_namespaceObject = __webpack_require__.p + "static/gmx.4fc0560be9419342dddc.png";
        ;// ./src/static/logos/protocols/camelot.png
        const camelot_namespaceObject = __webpack_require__.p + "static/camelot.d7e4b71365d2317c59e8.png";
        ;// ./src/static/logos/protocols/reaper.png
        const reaper_namespaceObject = __webpack_require__.p + "static/reaper.d712afa34bad2e73d0a6.png";
        ;// ./src/static/logos/protocols/sushiswap.png
        const sushiswap_namespaceObject = __webpack_require__.p + "static/sushiswap.67686e328f4624259c4b.png";
        ;// ./src/static/logos/protocols/uniswap.png
        const uniswap_namespaceObject = __webpack_require__.p + "static/uniswap.02d2d4d208a97e1216e9.png";
        ;// ./src/static/logos/protocols/index.ts
        const protocolsIcons = { sushiswap: sushiswap_namespaceObject, reaper: reaper_namespaceObject, camelot: camelot_namespaceObject, gmx: gmx_namespaceObject, balancer: balancer_namespaceObject, uniswap: uniswap_namespaceObject };
        ;// ./src/components/ProductCard/DefiCard.tsx
        function checkIsBalancer(pool) { return pool.featured } const DefiCard = ({ strategy, camelotPools }) => { const infoUsed = strategy ?? camelotPools; const { network, address, name, apy, provider, filteredTokens, liquidity, multipliers } = infoUsed; const urlData = strategy ? address : camelotPools?.pos; const navigate = (0, dist/* useNavigate */.Zp)(); const networkName = getNetworkName(network); const tvl = +liquidity; const isFeatured = checkIsBalancer(infoUsed) ? infoUsed.featured : false; return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { id: `defi-card-${name}`, className: `defi-card ${isFeatured ? "featured" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenImageList_TokenImageList, { tokens: filteredTokens }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: `provider-badge ${provider.toLowerCase()}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: protocolsIcons?.[provider.toLowerCase()], alt: provider, className: "provider-badge-image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: provider })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { title: name, children: name }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "strategy-card-points", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ApyInfo_ApyInfo, { apr: !isNaN(+apy) ? +apy : null }),/*#__PURE__*/(0, jsx_runtime.jsx)(GenericPoints_GenericPoints, { type: "tvl", points: tvl })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(ListMultiplier_ListMultiplier, { multipliers: multipliers }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: isFeatured ? "button-featured" : "button-not-featured", onClick: () => navigate(`/info/defi-strategies/${networkName}/` + urlData), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "more-info" }) }), isFeatured ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "featured-bg" }) :/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "bg" })] }) };/* harmony default export */ const ProductCard_DefiCard = (DefiCard);
        ;// ./src/components/ProductGrid/DefiGrid/DefiGrid.tsx
        const DefiGrid = ({ strategies, camelotPools }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "defi-grid", className: "product-grid", children: [strategies?.map(s =>/*#__PURE__*/(0, jsx_runtime.jsx)(ProductCard_DefiCard, { strategy: s }, s?.id)), camelotPools?.map(pool =>/*#__PURE__*/(0, jsx_runtime.jsx)(ProductCard_DefiCard, { camelotPools: pool }, pool?.address))] }) };/* harmony default export */ const DefiGrid_DefiGrid = (DefiGrid);
        ;// ./src/static/logos/networks/ethereum-logo.png
        const ethereum_logo_namespaceObject = __webpack_require__.p + "static/ethereum-logo.d2d0e002cb3895194c45.png";
        ;// ./src/static/logos/networks/arbitrum-logo.png
        const arbitrum_logo_namespaceObject = __webpack_require__.p + "static/arbitrum-logo.f8e6405d7faca19aafa4.png";
        ;// ./src/static/logos/networks/binance-logo.png
        const binance_logo_namespaceObject = __webpack_require__.p + "static/binance-logo.1ec1d4f7ad9666a94ca5.png";
        ;// ./src/static/logos/networks/base-logo.png
        const base_logo_namespaceObject = __webpack_require__.p + "static/base-logo.872346a2cfaa24f43999.png";
        ;// ./src/static/logos/networks/optimism-logo.png
        const optimism_logo_namespaceObject = __webpack_require__.p + "static/optimism-logo.bbec3b08882dc1e8f1d0.png";
        ;// ./src/static/logos/networks/arbitrum.svg
        const arbitrum_namespaceObject = __webpack_require__.p + "static/arbitrum.573ff3996e27c03c15e9.svg";
        ;// ./src/static/logos/networks/ethereum.svg
        const ethereum_namespaceObject = __webpack_require__.p + "static/ethereum.1843d6c93b66d74982f8.svg";
        ;// ./src/static/logos/networks/base.svg
        const base_namespaceObject = __webpack_require__.p + "static/base.e6159a4ffc3bc6a6f58d.svg";
        ;// ./src/static/logos/networks/optimism.svg
        const optimism_namespaceObject = __webpack_require__.p + "static/optimism.8e02aab14eef09db0cb3.svg";
        ;// ./src/static/logos/networks/ethereumWhite.svg
        const ethereumWhite_namespaceObject = __webpack_require__.p + "static/ethereumWhite.144e8a4944aeda1198d6.svg";
        ;// ./src/static/logos/networks/arbitrumWhite.svg
        const arbitrumWhite_namespaceObject = __webpack_require__.p + "static/arbitrumWhite.ad031321e98cffbd02d6.svg";
        ;// ./src/static/logos/networks/binance.svg
        const binance_namespaceObject = __webpack_require__.p + "static/binance.a6e6202c20e29d46025b.svg";
        ;// ./src/static/logos/networks/binanceWhite.svg
        const binanceWhite_namespaceObject = __webpack_require__.p + "static/binanceWhite.942b59a38a1ccd6a753b.svg";
        ;// ./src/static/logos/networks.ts
        const networkLogos = { arbitrum: arbitrum_logo_namespaceObject, ethereum: ethereum_logo_namespaceObject, binance: binance_logo_namespaceObject, linea: arbitrum_logo_namespaceObject, base: base_logo_namespaceObject, scroll: arbitrum_logo_namespaceObject, mode: arbitrum_logo_namespaceObject, optimism: optimism_logo_namespaceObject }; const networkVectors = { arbitrum: arbitrum_namespaceObject, ethereum: ethereum_namespaceObject, binance: binance_namespaceObject, linea: arbitrum_namespaceObject, base: base_namespaceObject, scroll: arbitrum_namespaceObject, mode: arbitrum_namespaceObject, optimism: optimism_namespaceObject }; const networkVectorsWhite = { arbitrum: arbitrumWhite_namespaceObject, ethereum: ethereumWhite_namespaceObject, binance: binanceWhite_namespaceObject, linea: arbitrumWhite_namespaceObject, base: arbitrumWhite_namespaceObject, scroll: arbitrumWhite_namespaceObject, mode: arbitrumWhite_namespaceObject, optimism: arbitrumWhite_namespaceObject };
        ;// ./src/components/MultiplierInfo/ClusterMultiplier/ClusterMultiplier.tsx
        const ClusterMultiplier = ({ multipliers }) => { const groupedMultipliers = Object.entries(multipliersList).reduce((acc, [key, value]) => { const multiplierValue = multipliers[key]; if (!multiplierValue) return acc; if (!acc[multiplierValue]) acc[multiplierValue] = []; acc[multiplierValue].push(value); return acc }, {}); return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "cluster-multiplier", children: Object.entries(groupedMultipliers).map(([multiplierValue, items]) =>/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "product-multiplier", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(MultiplierInfo_MultiplierInfo, { amount: +multiplierValue }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "product-multiplier-wrapper", children: items.map(({ name, icon }) =>/*#__PURE__*/(0, jsx_runtime.jsx)(IconMultiplier_IconMultiplier, { name: name.toLowerCase(), icon: icon }, name)) })] }, multiplierValue)) }) };/* harmony default export */ const ClusterMultiplier_ClusterMultiplier = (ClusterMultiplier);
        ;// ./src/components/ProductCard/AssetsCard.tsx
        const AssetsCard = ({ token, showNetwork = false }) => { const { id, type, name, apr, network, multipliers } = token; const navigate = (0, dist/* useNavigate */.Zp)(); const networkName = getNetworkName(network); const { networkTag } = getItemByNetwork(network); const handleNavigate = () => { let route = `/info/${type.toLowerCase()}/${networkName}/` + id?.toLowerCase(); if (id.toLowerCase() === "aubnb") route = "/info/aubnb"; navigate(route) }; const showedApr = id === "auBNB" ? 52.1 : !isNaN(+apr) ? +apr : null; return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { id: `assets-card-${name}`, className: id.toLowerCase() !== "aubnb" ? "assets-card" : "assets-card aubnb", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "left-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage(id?.toLowerCase()), alt: id, className: "token-image" }), showNetwork &&/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `network ${id.toLowerCase()}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: networkLogos[networkName], alt: `${networkName} logo` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: networkTag })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "right-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `badge ${type}`, children: type }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { title: name, children: name }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "assets-card-points", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ApyInfo_ApyInfo, { apr: showedApr }),/*#__PURE__*/(0, jsx_runtime.jsx)(ClusterMultiplier_ClusterMultiplier, { multipliers: multipliers })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: handleNavigate, className: id.toLowerCase(), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "more-info" }) }), id.toLowerCase() !== "aubnb" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "bg" })] }) };/* harmony default export */ const ProductCard_AssetsCard = (AssetsCard);
        ;// ./src/components/ProductGrid/AssetsGrid/AssetsGrid.tsx
        const AssetsGrid = ({ tokens, showNetwork, selectedNetwork = "all networks" }) => { const filteredTokens = selectedNetwork === "all networks" ? tokens : tokens.filter(token => getNetworkName(token.network) === selectedNetwork); return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "assets-grid", className: `product-grid ${showNetwork ? "lrt-grid" : "lst-grid"}`, children: (filteredTokens || []).map(t =>/*#__PURE__*/(0, jsx_runtime.jsx)(ProductCard_AssetsCard, { token: t, showNetwork: showNetwork }, `${t?.id}${t.network}`)) }) };/* harmony default export */ const AssetsGrid_AssetsGrid = (AssetsGrid);
        ;// ./src/hooks/usePools.ts
        const useCamelotPools = () => { const pools = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + "/camelot-pools"); return pools }; const useSingleCamelotPool = poolAddress => { const pool = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + "/camelot-pool/" + poolAddress); return pool }; const useSinglePool = poolAddress => { const pool = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + "/pool/" + poolAddress); return pool }; const usePools = () => { const pools = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + "/pools"); return pools };/* harmony default export */ const hooks_usePools = (usePools);
        ;// ./src/components/ProductGrid/ProductGrid.tsx
        const ComingSoonGrid = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "strategies-grid", children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "coming-soon", children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "coming-soon" }) }) }) }) }) }; const LstStrategiesGrid = () => { const tokens = hooks_useTokensLst(); if (tokens.length === 0) return /*#__PURE__*/(0, jsx_runtime.jsx)(ComingSoonGrid, {}); return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetsGrid_AssetsGrid, { tokens: tokens }) }; const LrstStrategiesGrid = () => { const selectedNetwork = (0, dist/* useOutletContext */.KC)(); const tokens = hooks_useTokensLrst(); if (tokens.length === 0) return /*#__PURE__*/(0, jsx_runtime.jsx)(ComingSoonGrid, {}); return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetsGrid_AssetsGrid, { tokens: tokens, showNetwork: true, selectedNetwork: selectedNetwork }) }; const DefiStrategiesGrid = () => { const strategies = hooks_usePools(); const camelotPools = useCamelotPools(); if (strategies.length === 0) return /*#__PURE__*/(0, jsx_runtime.jsx)(ComingSoonGrid, {}); return /*#__PURE__*/(0, jsx_runtime.jsx)(DefiGrid_DefiGrid, { strategies: strategies, camelotPools: camelotPools }) }; const ProductGrid = ({ selectedNetwork }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Outlet */.sv, { context: selectedNetwork }) }) }) };/* harmony default export */ const ProductGrid_ProductGrid = (ProductGrid);
        ;// ./src/data/Arbitrum/camelotPools.json
        const camelotPools_namespaceObject = /*#__PURE__*/JSON.parse('[{"network":"0xa4b1","address":"0xb355ccE5CBAF411bd56e3b092F5AA10A894083ae","pos":"0xF00Bf7c33eE9106d10661F7ecF5efc73F4C911E1","nftAddress":"0x907F788AB0d47D7fcB5c48a9a1c05A4B35aC0b82","bptName":"rsETH-ETH","symbolTokens":["rseth","eth"],"autolayerMultiplier":"1","eigenLayerMultiplier":"1","kelpMultiplier":"2","description":"Gamma/Camelot Boosted rsETH/ETH strategy: Staking Rewards, EigenLayer Points, Kelp Miles, AutoLayer Points, $GRAIL/ $esGRAIL emissions and Camelot Trading Fees","image":"https://i.imgur.com/v9sE5xh.jpeg","opengraph":"Gamma/Camelot Boosted rsETH/ETH strategy: Staking Rewards, EigenLayer Points, Kelp Miles, AutoLayer Points, $GRAIL/ $esGRAIL emissions and Camelot Trading Fees"},{"network":"0xa4b1","address":"0xaA45265A94C93802BE9511E426933239117E658f","pos":"0xc0aeE8d1b04948f24beD717e92ec567521A24CDF","nftAddress":"0xF9C3D8eF07bDE55f358c1793D0Ed55cd78eeb50C","bptName":"ezETH-ETH","symbolTokens":["ezeth","eth"],"autolayerMultiplier":"1","eigenLayerMultiplier":"1","renzoMultiplier":"2","description":"Gamma/Camelot Boosted ezETH/ETH strategy: Staking Rewards, EigenLayer Points, Renzo Points, AutoLayer Points, $GRAIL/ $esGRAIL emissions and Camelot Trading Fees","image":"https://i.imgur.com/oe0ZWOu.jpeg","opengraph":"Gamma/Camelot Boosted ezETH/ETH strategy: Staking Rewards, EigenLayer Points, Renzo Points, AutoLayer Points, $GRAIL/ $esGRAIL emissions and Camelot Trading Fees"}]');
        ;// ./src/data/Arbitrum/pools.json
        const pools_namespaceObject = /*#__PURE__*/JSON.parse('[{"network":"0xa4b1","address":"0xb61371ab661b1acec81c699854d2f911070c059e","bptName":"ezETH/wstETH","symbolTokens":["ezeth","wsteth"],"id":"0xb61371ab661b1acec81c699854d2f911070c059e000000000000000000000516","autolayerMultiplier":"1","eigenLayerMultiplier":"1","renzoMultiplier":"4","description":"The Boosted Renzo Balancer Pool is an 80/20 Balancer Pool with EZETH/WSTETH with an AutoLayer Boost. Get staking rewards, EigenLayer Points, Renzo Points with a 2x multiplier, AutoLayer Points, and swap fees. Experience five layers of yield and participation in three airdrops, all in just one product.","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":"The Boosted Renzo Balancer Pool is an 80/20 Balancer Pool with EZETH/WSTETH with an AutoLayer Boost. Get staking rewards, EigenLayer Points, Renzo Points with a 2x multiplier, AutoLayer Points, and swap fees. Experience five layers of yield and participation in three airdrops, all in just one product.","featured":true},{"network":"0xa4b1","address":"0x9791d590788598535278552eecd4b211bfc790cb","bptName":"wstETH-WETH-BPT","symbolTokens":["wsteth","weth"],"id":"0x9791d590788598535278552eecd4b211bfc790cb000000000000000000000498","autolayerMultiplier":"1","eigenLayerMultiplier":"1","description":"","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":""},{"network":"0xa4b1","address":"0x3fd4954a851ead144c2ff72b1f5a38ea5976bd54","bptName":"ankrETH/wstETH-BPT","symbolTokens":["ankreth","wsteth"],"id":"0x3fd4954a851ead144c2ff72b1f5a38ea5976bd54000000000000000000000480","autolayerMultiplier":"1","eigenLayerMultiplier":"1","description":"","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":""},{"network":"0xa4b1","address":"0xade4a71bb62bec25154cfc7e6ff49a513b491e81","bptName":"rETH-WETH-BPTT","symbolTokens":["reth","weth"],"id":"0xade4a71bb62bec25154cfc7e6ff49a513b491e81000000000000000000000497","autolayerMultiplier":"1","eigenLayerMultiplier":"1","description":"","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":""},{"network":"0xa4b1","address":"0x4a2f6ae7f3e5d715689530873ec35593dc28951b","bptName":"wstETH/rETH/cbETH-BPT","symbolTokens":["cbeth","reth","wsteth"],"id":"0x4a2f6ae7f3e5d715689530873ec35593dc28951b000000000000000000000481","autolayerMultiplier":"1","eigenLayerMultiplier":"1","description":"","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":""},{"network":"0xa4b1","address":"0x0c8972437a38b389ec83d1e666b69b8a4fcf8bfd","bptName":"wstETH/rETH/sfrxETH-BPT","symbolTokens":["wsteth","reth","sfrxeth"],"id":"0x0c8972437a38b389ec83d1e666b69b8a4fcf8bfd00000000000000000000049e","autolayerMultiplier":"1","eigenLayerMultiplier":"1","description":"","image":"https://i.imgur.com/IWhrf9e.jpeg","opengraph":""}]');
        ;// ./src/data/Arbitrum/tokens.json
        const Arbitrum_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC.e","address":"0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8","decimals":"6","name":"USD Coin Bridged"},{"id":"USDT","address":"0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9","decimals":"6","name":"Tether USD"},{"id":"ARB","address":"0x912ce59144191c1204e64559fe8253a0e49e6548","decimals":"18","name":"Arbitrum"},{"id":"WETH","address":"0x82aF49447D8a07e3bd95BD0d56f35241523fBab1","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f","decimals":"8","name":"Wrapped BTC"},{"id":"DAI","address":"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1","decimals":"18","name":"Dai Stablecoin"},{"id":"LDO","address":"0x13Ad51ed4F1B7e9Dc168d8a00cB3f4dDD85EfA60","decimals":"18","name":"Lido DAO Token"},{"id":"UNI","address":"0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0","decimals":"18","name":"Uniswap"},{"id":"BAL","address":"0x040d1EdC9569d4Bab2D15287Dc5A4F10F56a56B8","decimals":"18","name":"Balancer"},{"id":"GMX","address":"0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a","decimals":"18","name":"GMX"},{"id":"LINK","address":"0xf97f4df75117a78c1A5a0DBb814Af92458539FB4","decimals":"18","name":"Chainlink"},{"id":"RDNT","address":"0x3082CC23568eA640225c2467653dB90e9250AaA0","decimals":"18","name":"Radient"},{"id":"RPL","address":"0xB766039cc6DB368759C1E56B79AFfE831d0Cc507","decimals":"18","name":"Rocket Pool Protocol"},{"id":"CRV","address":"0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978","decimals":"18","name":"Curve DAO Token"},{"id":"auraBAL","address":"0x223738a747383d6F9f827d95964e4d8E8AC754cE","decimals":"18","name":"Aura Balancer"},{"id":"GRT","address":"0x9623063377AD1B27544C965cCd7342f7EA7e88C7","name":"Graph Token","decimals":"18"},{"id":"VSTA","address":"0xa684cd057951541187f288294a1e1C2646aA2d24","decimals":"18","name":"Vesta"},{"id":"DOLA","address":"0x6A7661795C374c0bFC635934efAddFf3A7Ee23b6","decimals":"18","name":"Dola"},{"id":"SYNO","address":"0x577Fd586c9E6BA7f2E85E025D5824DBE19896656","decimals":"18","name":"Synonym Finance"},{"id":"GOLD","address":"0x8b5e4C9a188b1A187f2D1E80b1c2fB17fA2922e1","decimals":"18","name":"GoldenBoys"},{"id":"STG","address":"0x6694340fc020c5E6B96567843da2df01b2CE1eb6","decimals":"18","name":"Stargate Token"}]');
        ;// ./src/data/Arbitrum/tokensLRS.json
        const Arbitrum_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"rsETH","address":"0x4186BFC76E2E237523CBC30FD220FE055156b41F","name":"Kelp DAO Restaked ETH (rsETH)","decimals":"18","network":"0xa4b1","type":"LRT","multipliers":{"autoLayer":1,"kelp":1},"image":"https://i.imgur.com/dCtZ8nq.jpeg","description":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking.","opengraph":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking."},{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0xa4b1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0xa4b1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"inETH","address":"0x5A7a183B6B44Dc4EC2E3d2eF43F98C5152b1d76d","name":"Inception ETH (inETH)","decimals":"18","network":"0xa4b1","type":"LRT","multipliers":{"autoLayer":1},"image":"https://imgur.com/TqBCHcV.jpeg","description":"InceptionLRT restaked ETH (InETH) Token, inETH mirrors the value of the underlying staked ETH, giving holders a tradable asset that reflects their staking contributions and accrued rewards.","opengraph":"The inETH Token mirrors the value of your staked ETH, offering a tradable asset that reflects your staking rewards. Enjoy greater liquidity and freedom with inETH as it moves and trades effortlessly across supported dapps and exchanges."},{"id":"sfrxETH","address":"0x95aB45875cFFdba1E5f451B950bC2E42c0053f39","name":"Staked Frax ETH (sfrxETH)","decimals":"18","network":"0xa4b1","type":"LST","image":"https://i.imgur.com/fcBfkoW.jpeg","multipliers":{"autoLayer":1},"description":"Introducing sfrxETH: the liquid staked token developed by FRAX. Holding sfrxETH entitles you to a percentage claim on the growing assets within the frxETH Vault. Staking rewards are divided among sfrxETH holders in proportion to their share of the total sfrxETH, leading to compounding ETH staking yields over time.","opengraph":"Discover Frax Liquid Staked Ethereum (sfrxETH) - FRAX\'s token. Holding sfrxETH gives you a stake in the growing frxETH Vault, earning you a share of staking rewards proportional to your holdings. Experience the power of compounded ETH staking yields over time with sfrxETH!"},{"id":"rETH","address":"0xEC70Dcb4A1EFa46b8F2D97C310C9c4790ba5ffA8","name":"Rocket Pool ETH (rETH)","decimals":"18","network":"0xa4b1","type":"LST","image":"https://i.imgur.com/7UeJFKl.jpeg","multipliers":{"autoLayer":1},"description":"Introducing rETH by Rocket Pool: representing a tokenized staking deposit and its accrued rewards within the Rocket Pool network over time. This token seamlessly integrates into a range of DeFi applications, empowering DEXs and wallets to offer instant staking services.","opengraph":"Introducing Rocket Pool\'s rETH token: Your gateway to tokenized staking deposits and rewards within our ecosystem. Instantly usable in DeFi apps, rETH empowers DEXs and wallets to provide instant staking services. Join the revolution with Rocket Pool!"},{"id":"cbETH","address":"0x1DEBd73E752bEaF79865Fd6446b0c970EaE7732f","name":"Coinbase Wrapped Staked ETH (cbETH)","decimals":"18","network":"0xa4b1","type":"LST","image":"https://i.imgur.com/R8lb1yn.jpeg","multipliers":{"autoLayer":1},"description":"Discover cbETH, your key to unlocking the full potential of staked Ethereum 2 (ETH2) holdings through Coinbase. With cbETH, your locked staked ETH becomes tradable and usable across DeFi and other dapps. Enjoy the benefits of staking without the hassle of lockups or unbonding periods.","opengraph":"Introducing Coinbase\'s cbETH: Unlock the power of Ethereum 2 (ETH2) stakes with this utility token. Trade, move, and leverage in DeFi and dapps instantly. Enjoy staking benefits without lockups or unbonding periods!"},{"id":"wstETH","address":"0x5979D7b546E38E414F7E9822514be443A4800529","name":"Wrapped Liquid Staked Ether 2.0 (wstETH)","decimals":"18","network":"0xa4b1","type":"LST","image":"https://i.imgur.com/HzCfClv.jpeg","multipliers":{"autoLayer":1},"description":"Introducing wstETH by Lido, a wrapped version of stETH. Lido, the largest DeFi protocol by Total Value Locked (TVL), adjusts your stETH balance daily with incoming staking rewards. wstETH maintains a stable stETH balance while utilizing a share system to reflect staking rewards accurately.","opengraph":"Lido\'s wstETH: Unleash the power of stETH in a wrapped version by LIDO, the leading DeFi protocol by TVL. As staking rewards fluctuate daily, wstETH ensures a stable balance while reflecting your staking rewards with an innovative share system!"},{"id":"ankrETH","address":"0xe05A08226c49b636ACf99c40Da8DC6aF83CE5bB3","name":"Ankr Staked ETH (ankrETH)","decimals":"18","network":"0xa4b1","type":"LST","image":"https://i.imgur.com/zcvyFu4.jpeg","description":"Introducing ankrETH, ankrETH is a reward-bearing token developed by ANKR, providing built-in rewards. Ankr Staking presents Ethereum token holders with the chance to stake ETH and receive Ethereum Liquid Staking tokens in return—ankrETH.","opengraph":"Introducing ankrETH: Your ticket to built-in rewards, developed by ANKR. Join Ankr Staking, stake your ETH, and earn Ethereum Liquid Staking tokens - ankrETH. Don\'t miss out on maximizing your rewards with ankrETH!"},{"id":"rsETH","address":"0x4186BFC76E2E237523CBC30FD220FE055156b41F","name":"Kelp DAO Restaked ETH (rsETH)","decimals":"18","network":"0xa4b1","type":"LRT","image":"https://i.imgur.com/dCtZ8nq.jpeg","description":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking.","opengraph":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking."},{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0xa4b1","type":"LRT","image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x35751007a407ca6FEFfE80b3cB397736D2cf4dbe","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0xa4b1","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"inETH","address":"0x5A7a183B6B44Dc4EC2E3d2eF43F98C5152b1d76d","name":"Inception ETH (inETH)","decimals":"18","network":"0xa4b1","type":"LRT","image":"https://imgur.com/TqBCHcV.jpeg","description":"InceptionLRT restaked ETH (InETH) Token, inETH mirrors the value of the underlying staked ETH, giving holders a tradable asset that reflects their staking contributions and accrued rewards.","opengraph":"The inETH Token mirrors the value of your staked ETH, offering a tradable asset that reflects your staking rewards. Enjoy greater liquidity and freedom with inETH as it moves and trades effortlessly across supported dapps and exchanges.","multipliers":{"autoLayer":1}}]');
        ;// ./src/data/Arbitrum/index.ts
        const Arbitrum_lrtTokens = Arbitrum_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Arbitrum_newTokens = Arbitrum_tokens_namespaceObject.slice(0, 3).concat(Arbitrum_lrtTokens).concat(Arbitrum_tokens_namespaceObject.slice(3)); const Arbitrum_ArbitrumData = { pools: pools_namespaceObject, camelotPools: camelotPools_namespaceObject, tokens: Arbitrum_newTokens, tokensLRS: Arbitrum_tokensLRS_namespaceObject };
        ;// ./src/contracts/abis/AutoLayerAbis/swapAbiArbitrumDEV.json
        const swapAbiArbitrumDEV_namespaceObject = /*#__PURE__*/JSON.parse('[{"type":"constructor","inputs":[{"name":"autoLayerPointsAddress_","type":"address","internalType":"address"},{"name":"routerAddress_","type":"address","internalType":"address"},{"name":"ETHUSDPriceFeedAdress_","type":"address","internalType":"address"},{"name":"balancerVaultAddress_","type":"address","internalType":"address"},{"name":"tokenProxyAddress_","type":"address","internalType":"address"},{"name":"gammaProxyAddress_","type":"address","internalType":"address"}],"stateMutability":"nonpayable"},{"type":"receive","stateMutability":"payable"},{"type":"function","name":"addLiquidityToBalancer","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"tokensWithBpt_","type":"address[]","internalType":"address[]"},{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"addLiquidityToCamelot","inputs":[{"name":"swapData0_","type":"bytes","internalType":"bytes"},{"name":"swapData1_","type":"bytes","internalType":"bytes"},{"name":"pos","type":"address","internalType":"address"},{"name":"minIn","type":"uint256[4]","internalType":"uint256[4]"},{"name":"nftPool","type":"address","internalType":"address"},{"name":"lockDuration","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"blackListTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"changeTokenBoost","inputs":[{"name":"tokenAddress_","type":"address","internalType":"address"},{"name":"newBoost","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBptAddress","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAddress","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"onERC721Received","inputs":[{"name":"operator","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bytes4","internalType":"bytes4"}],"stateMutability":"pure"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidityFromBalancer","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"},{"name":"bptToken_","type":"address","internalType":"address"},{"name":"tokenOut_","type":"address","internalType":"address"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"minAmountsOut_","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokens","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokensWithETH","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"tokenBoost","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unbindCamelotPosition","inputs":[{"name":"positionAddress","type":"address","internalType":"address"},{"name":"sharesAmount","type":"uint256","internalType":"uint256"},{"name":"minAmounts","type":"uint256[4]","internalType":"uint256[4]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"whitelistTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"withdrawFromCamelotPosition","inputs":[{"name":"nftPool","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"amountToWithdraw","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"AddressInsufficientBalance","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"FailedInnerCall","inputs":[]},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"SafeERC20FailedOperation","inputs":[{"name":"token","type":"address","internalType":"address"}]}]');
        ;// ./src/contracts/abis/AutoLayerAbis/swapAbiArbitrumPRO.json
        const swapAbiArbitrumPRO_namespaceObject = /*#__PURE__*/JSON.parse('[{"type":"constructor","inputs":[{"name":"autoLayerPointsAddress_","type":"address","internalType":"address"},{"name":"routerAddress_","type":"address","internalType":"address"},{"name":"ETHUSDPriceFeedAdress_","type":"address","internalType":"address"},{"name":"balancerVaultAddress_","type":"address","internalType":"address"},{"name":"tokenProxyAddress_","type":"address","internalType":"address"},{"name":"gammaProxyAddress_","type":"address","internalType":"address"}],"stateMutability":"nonpayable"},{"type":"receive","stateMutability":"payable"},{"type":"function","name":"addLiquidityToBalancer","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"tokensWithBpt_","type":"address[]","internalType":"address[]"},{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"addLiquidityToCamelot","inputs":[{"name":"swapData0_","type":"bytes","internalType":"bytes"},{"name":"swapData1_","type":"bytes","internalType":"bytes"},{"name":"pos","type":"address","internalType":"address"},{"name":"minIn","type":"uint256[4]","internalType":"uint256[4]"},{"name":"nftPool","type":"address","internalType":"address"},{"name":"lockDuration","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"blackListTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"changeTokenBoost","inputs":[{"name":"tokenAddress_","type":"address","internalType":"address"},{"name":"newBoost","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBptAddress","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAddress","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"onERC721Received","inputs":[{"name":"operator","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bytes4","internalType":"bytes4"}],"stateMutability":"pure"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidityFromBalancer","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"},{"name":"bptToken_","type":"address","internalType":"address"},{"name":"tokenOut_","type":"address","internalType":"address"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"minAmountsOut_","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokens","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokensWithETH","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"tokenBoost","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unbindCamelotPosition","inputs":[{"name":"positionAddress","type":"address","internalType":"address"},{"name":"sharesAmount","type":"uint256","internalType":"uint256"},{"name":"minAmounts","type":"uint256[4]","internalType":"uint256[4]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"whitelistTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"withdrawFromCamelotPosition","inputs":[{"name":"nftPool","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"amountToWithdraw","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"AddressInsufficientBalance","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"FailedInnerCall","inputs":[]},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"SafeERC20FailedOperation","inputs":[{"name":"token","type":"address","internalType":"address"}]}]');
        ;// ./src/contracts/abis/AutoLayerAbis/swapAbiEthereumDEV.json
        const swapAbiEthereumDEV_namespaceObject = /*#__PURE__*/JSON.parse('[{"type":"constructor","inputs":[{"name":"autoLayerPointsAddress_","type":"address","internalType":"address"},{"name":"routerAddress_","type":"address","internalType":"address"},{"name":"ETHUSDPriceFeedAdress_","type":"address","internalType":"address"},{"name":"balancerVaultAddress_","type":"address","internalType":"address"},{"name":"tokenProxyAddress_","type":"address","internalType":"address"},{"name":"gammaProxyAddress_","type":"address","internalType":"address"}],"stateMutability":"nonpayable"},{"type":"receive","stateMutability":"payable"},{"type":"function","name":"addLiquidityToBalancer","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"tokensWithBpt_","type":"address[]","internalType":"address[]"},{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"addLiquidityToCamelot","inputs":[{"name":"swapData0_","type":"bytes","internalType":"bytes"},{"name":"swapData1_","type":"bytes","internalType":"bytes"},{"name":"pos","type":"address","internalType":"address"},{"name":"minIn","type":"uint256[4]","internalType":"uint256[4]"},{"name":"nftPool","type":"address","internalType":"address"},{"name":"lockDuration","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"blackListTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"changeTokenBoost","inputs":[{"name":"tokenAddress_","type":"address","internalType":"address"},{"name":"newBoost","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBptAddress","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAddress","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"onERC721Received","inputs":[{"name":"operator","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bytes4","internalType":"bytes4"}],"stateMutability":"pure"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidityFromBalancer","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"},{"name":"bptToken_","type":"address","internalType":"address"},{"name":"tokenOut_","type":"address","internalType":"address"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"minAmountsOut_","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokens","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokensWithETH","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"tokenBoost","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unbindCamelotPosition","inputs":[{"name":"positionAddress","type":"address","internalType":"address"},{"name":"sharesAmount","type":"uint256","internalType":"uint256"},{"name":"minAmounts","type":"uint256[4]","internalType":"uint256[4]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"whitelistTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"withdrawFromCamelotPosition","inputs":[{"name":"nftPool","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"amountToWithdraw","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"AddressInsufficientBalance","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"FailedInnerCall","inputs":[]},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"SafeERC20FailedOperation","inputs":[{"name":"token","type":"address","internalType":"address"}]}]');
        ;// ./src/contracts/abis/AutoLayerAbis/swapAbiEthereumPRO.json
        const swapAbiEthereumPRO_namespaceObject = /*#__PURE__*/JSON.parse('[{"type":"constructor","inputs":[{"name":"autoLayerPointsAddress_","type":"address","internalType":"address"},{"name":"routerAddress_","type":"address","internalType":"address"},{"name":"ETHUSDPriceFeedAdress_","type":"address","internalType":"address"},{"name":"balancerVaultAddress_","type":"address","internalType":"address"},{"name":"tokenProxyAddress_","type":"address","internalType":"address"},{"name":"gammaProxyAddress_","type":"address","internalType":"address"}],"stateMutability":"nonpayable"},{"type":"receive","stateMutability":"payable"},{"type":"function","name":"addLiquidityToBalancer","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"tokensWithBpt_","type":"address[]","internalType":"address[]"},{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"addLiquidityToCamelot","inputs":[{"name":"swapData0_","type":"bytes","internalType":"bytes"},{"name":"swapData1_","type":"bytes","internalType":"bytes"},{"name":"pos","type":"address","internalType":"address"},{"name":"minIn","type":"uint256[4]","internalType":"uint256[4]"},{"name":"nftPool","type":"address","internalType":"address"},{"name":"lockDuration","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"payable"},{"type":"function","name":"blackListTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"changeTokenBoost","inputs":[{"name":"tokenAddress_","type":"address","internalType":"address"},{"name":"newBoost","type":"uint8","internalType":"uint8"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"getBptAddress","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"}],"outputs":[{"name":"bptAddress","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"onERC721Received","inputs":[{"name":"operator","type":"address","internalType":"address"},{"name":"from","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"","type":"bytes4","internalType":"bytes4"}],"stateMutability":"pure"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeLiquidityFromBalancer","inputs":[{"name":"poolId_","type":"bytes32","internalType":"bytes32"},{"name":"bptToken_","type":"address","internalType":"address"},{"name":"tokenOut_","type":"address","internalType":"address"},{"name":"tokens_","type":"address[]","internalType":"address[]"},{"name":"minAmountsOut_","type":"uint256[]","internalType":"uint256[]"},{"name":"bptAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokens","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"nonpayable"},{"type":"function","name":"swapTokensWithETH","inputs":[{"name":"swapData_","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"swappedAmount","type":"uint256","internalType":"uint256"}],"stateMutability":"payable"},{"type":"function","name":"tokenBoost","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint8","internalType":"uint8"}],"stateMutability":"view"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"unbindCamelotPosition","inputs":[{"name":"positionAddress","type":"address","internalType":"address"},{"name":"sharesAmount","type":"uint256","internalType":"uint256"},{"name":"minAmounts","type":"uint256[4]","internalType":"uint256[4]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"whitelistTokens","inputs":[{"name":"tokenAddresses_","type":"address[]","internalType":"address[]"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"withdrawFromCamelotPosition","inputs":[{"name":"nftPool","type":"address","internalType":"address"},{"name":"tokenId","type":"uint256","internalType":"uint256"},{"name":"amountToWithdraw","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"AddressEmptyCode","inputs":[{"name":"target","type":"address","internalType":"address"}]},{"type":"error","name":"AddressInsufficientBalance","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"FailedInnerCall","inputs":[]},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]},{"type":"error","name":"SafeERC20FailedOperation","inputs":[{"name":"token","type":"address","internalType":"address"}]}]');
        ;// ./src/contracts/abis/AutoLayerAbis/CamelotPoolsInfoAbi.json
        const CamelotPoolsInfoAbi_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getCamelotPoolsData","outputs":[{"components":[{"components":[{"internalType":"uint256","name":"total0","type":"uint256"},{"internalType":"uint256","name":"total1","type":"uint256"}],"internalType":"struct AutoLayerCamelotInfo.TotalAmountPool","name":"totalAmounts","type":"tuple"},{"internalType":"uint256","name":"totalSupply","type":"uint256"},{"internalType":"uint256","name":"userLPs","type":"uint256"},{"internalType":"address","name":"poolAddress","type":"address"},{"internalType":"address","name":"nftContract","type":"address"}],"internalType":"struct AutoLayerCamelotInfo.PoolResult[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalAmounts","outputs":[{"components":[{"internalType":"uint256","name":"total0","type":"uint256"},{"internalType":"uint256","name":"total1","type":"uint256"}],"internalType":"struct AutoLayerCamelotInfo.TotalAmountPool[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalSupply","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserLPs","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"pools","outputs":[{"internalType":"address","name":"poolAddress","type":"address"},{"internalType":"address","name":"nftContract","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]');
        ;// ./src/contracts/abis/AutoLayerAbis/pointsAbi.json
        const pointsAbi_namespaceObject = /*#__PURE__*/JSON.parse('[{"type":"constructor","inputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"addPoints","inputs":[{"name":"userAddress_","type":"address","internalType":"address"},{"name":"pointsAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"isAllowed","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"bool","internalType":"bool"}],"stateMutability":"view"},{"type":"function","name":"owner","inputs":[],"outputs":[{"name":"","type":"address","internalType":"address"}],"stateMutability":"view"},{"type":"function","name":"removeAllowed","inputs":[{"name":"notAllowedAddress_","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"removePoints","inputs":[{"name":"userAddress_","type":"address","internalType":"address"},{"name":"pointsAmount_","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"renounceOwnership","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"setAllowed","inputs":[{"name":"allowedAddress_","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"transferOwnership","inputs":[{"name":"newOwner","type":"address","internalType":"address"}],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"userPoints","inputs":[{"name":"","type":"address","internalType":"address"}],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"event","name":"OwnershipTransferred","inputs":[{"name":"previousOwner","type":"address","indexed":true,"internalType":"address"},{"name":"newOwner","type":"address","indexed":true,"internalType":"address"}],"anonymous":false},{"type":"error","name":"OwnableInvalidOwner","inputs":[{"name":"owner","type":"address","internalType":"address"}]},{"type":"error","name":"OwnableUnauthorizedAccount","inputs":[{"name":"account","type":"address","internalType":"address"}]}]');
        ;// ./src/contracts/abis/tokenAbi.json
        const tokenAbi_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_owner","type":"address"},{"indexed":true,"internalType":"address","name":"_spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"_value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"_from","type":"address"},{"indexed":true,"internalType":"address","name":"_to","type":"address"},{"indexed":false,"internalType":"uint256","name":"_value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"address","name":"_spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"_addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_from","type":"address"},{"internalType":"address","name":"_to","type":"address"},{"internalType":"uint256","name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"}]');
        ;// ./src/contracts/abis/BalancerVault.json
        const BalancerVault_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[{"internalType":"contract IAuthorizer","name":"authorizer","type":"address"},{"internalType":"contract IWETH","name":"weth","type":"address"},{"internalType":"uint256","name":"pauseWindowDuration","type":"uint256"},{"internalType":"uint256","name":"bufferPeriodDuration","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"name":"AuthorizerChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ExternalBalanceTransfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"contract IFlashLoanRecipient","name":"recipient","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"feeAmount","type":"uint256"}],"name":"FlashLoan","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"int256","name":"delta","type":"int256"}],"name":"InternalBalanceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bool","name":"paused","type":"bool"}],"name":"PausedStateChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"liquidityProvider","type":"address"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"indexed":false,"internalType":"int256[]","name":"deltas","type":"int256[]"},{"indexed":false,"internalType":"uint256[]","name":"protocolFeeAmounts","type":"uint256[]"}],"name":"PoolBalanceChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"assetManager","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"token","type":"address"},{"indexed":false,"internalType":"int256","name":"cashDelta","type":"int256"},{"indexed":false,"internalType":"int256","name":"managedDelta","type":"int256"}],"name":"PoolBalanceManaged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"poolAddress","type":"address"},{"indexed":false,"internalType":"enum IVault.PoolSpecialization","name":"specialization","type":"uint8"}],"name":"PoolRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"RelayerApprovalChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":true,"internalType":"contract IERC20","name":"tokenIn","type":"address"},{"indexed":true,"internalType":"contract IERC20","name":"tokenOut","type":"address"},{"indexed":false,"internalType":"uint256","name":"amountIn","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amountOut","type":"uint256"}],"name":"Swap","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"TokensDeregistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"poolId","type":"bytes32"},{"indexed":false,"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"indexed":false,"internalType":"address[]","name":"assetManagers","type":"address[]"}],"name":"TokensRegistered","type":"event"},{"inputs":[],"name":"WETH","outputs":[{"internalType":"contract IWETH","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"uint256","name":"assetInIndex","type":"uint256"},{"internalType":"uint256","name":"assetOutIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.BatchSwapStep[]","name":"swaps","type":"tuple[]"},{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"},{"internalType":"int256[]","name":"limits","type":"int256[]"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"batchSwap","outputs":[{"internalType":"int256[]","name":"assetDeltas","type":"int256[]"}],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"deregisterTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address payable","name":"recipient","type":"address"},{"components":[{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"internalType":"uint256[]","name":"minAmountsOut","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.ExitPoolRequest","name":"request","type":"tuple"}],"name":"exitPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IFlashLoanRecipient","name":"recipient","type":"address"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"amounts","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"}],"name":"flashLoan","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"selector","type":"bytes4"}],"name":"getActionId","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getAuthorizer","outputs":[{"internalType":"contract IAuthorizer","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDomainSeparator","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"}],"name":"getInternalBalance","outputs":[{"internalType":"uint256[]","name":"balances","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getNextNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPausedState","outputs":[{"internalType":"bool","name":"paused","type":"bool"},{"internalType":"uint256","name":"pauseWindowEndTime","type":"uint256"},{"internalType":"uint256","name":"bufferPeriodEndTime","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"}],"name":"getPool","outputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"enum IVault.PoolSpecialization","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20","name":"token","type":"address"}],"name":"getPoolTokenInfo","outputs":[{"internalType":"uint256","name":"cash","type":"uint256"},{"internalType":"uint256","name":"managed","type":"uint256"},{"internalType":"uint256","name":"lastChangeBlock","type":"uint256"},{"internalType":"address","name":"assetManager","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"}],"name":"getPoolTokens","outputs":[{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"uint256[]","name":"balances","type":"uint256[]"},{"internalType":"uint256","name":"lastChangeBlock","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getProtocolFeesCollector","outputs":[{"internalType":"contract ProtocolFeesCollector","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"address","name":"relayer","type":"address"}],"name":"hasApprovedRelayer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"components":[{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"internalType":"uint256[]","name":"maxAmountsIn","type":"uint256[]"},{"internalType":"bytes","name":"userData","type":"bytes"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"}],"internalType":"struct IVault.JoinPoolRequest","name":"request","type":"tuple"}],"name":"joinPool","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"enum IVault.PoolBalanceOpKind","name":"kind","type":"uint8"},{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"internalType":"struct IVault.PoolBalanceOp[]","name":"ops","type":"tuple[]"}],"name":"managePoolBalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"enum IVault.UserBalanceOpKind","name":"kind","type":"uint8"},{"internalType":"contract IAsset","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address payable","name":"recipient","type":"address"}],"internalType":"struct IVault.UserBalanceOp[]","name":"ops","type":"tuple[]"}],"name":"manageUserBalance","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"uint256","name":"assetInIndex","type":"uint256"},{"internalType":"uint256","name":"assetOutIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.BatchSwapStep[]","name":"swaps","type":"tuple[]"},{"internalType":"contract IAsset[]","name":"assets","type":"address[]"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"}],"name":"queryBatchSwap","outputs":[{"internalType":"int256[]","name":"","type":"int256[]"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"enum IVault.PoolSpecialization","name":"specialization","type":"uint8"}],"name":"registerPool","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"contract IERC20[]","name":"tokens","type":"address[]"},{"internalType":"address[]","name":"assetManagers","type":"address[]"}],"name":"registerTokens","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"contract IAuthorizer","name":"newAuthorizer","type":"address"}],"name":"setAuthorizer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"paused","type":"bool"}],"name":"setPaused","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"relayer","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setRelayerApproval","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"bytes32","name":"poolId","type":"bytes32"},{"internalType":"enum IVault.SwapKind","name":"kind","type":"uint8"},{"internalType":"contract IAsset","name":"assetIn","type":"address"},{"internalType":"contract IAsset","name":"assetOut","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bytes","name":"userData","type":"bytes"}],"internalType":"struct IVault.SingleSwap","name":"singleSwap","type":"tuple"},{"components":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"bool","name":"fromInternalBalance","type":"bool"},{"internalType":"address payable","name":"recipient","type":"address"},{"internalType":"bool","name":"toInternalBalance","type":"bool"}],"internalType":"struct IVault.FundManagement","name":"funds","type":"tuple"},{"internalType":"uint256","name":"limit","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountCalculated","type":"uint256"}],"stateMutability":"payable","type":"function"},{"stateMutability":"payable","type":"receive"}]');
        ;// ./src/contracts/abis/gammaContract.json
        const gammaContract_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[{"internalType":"address","name":"_clearance","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"clearance","outputs":[{"internalType":"contract IClearing","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"deposit0","type":"uint256"},{"internalType":"uint256","name":"deposit1","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"pos","type":"address"},{"internalType":"uint256[4]","name":"minIn","type":"uint256[4]"}],"name":"deposit","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"pos","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"_deposit","type":"uint256"}],"name":"getDepositAmount","outputs":[{"internalType":"uint256","name":"amountStart","type":"uint256"},{"internalType":"uint256","name":"amountEnd","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newClearance","type":"address"}],"name":"transferClearance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}]');
        ;// ./src/contracts/abis/nftPoolCamelot.json
        const nftPoolCamelot_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"AddToPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"CreatePosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"EmergencyWithdraw","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"pending","type":"uint256"}],"name":"HarvestPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"LockPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256[]","name":"tokenIds","type":"uint256[]"}],"name":"MergePositions","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"lastRewardTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"accRewardsPerShare","type":"uint256"}],"name":"PoolUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"boostPoints","type":"uint256"}],"name":"SetBoost","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"maxGlobalMultiplier","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxBoostMultiplier","type":"uint256"}],"name":"SetBoostMultiplierSettings","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bool","name":"emergencyUnlock","type":"bool"}],"name":"SetEmergencyUnlock","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"maxLockDuration","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"maxLockMultiplier","type":"uint256"}],"name":"SetLockMultiplierSettings","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"operator","type":"address"}],"name":"SetOperator","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"isAdded","type":"bool"}],"name":"SetUnlockOperator","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"xGrailRewardsShare","type":"uint256"}],"name":"SetXGrailRewardsShare","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"splitAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"newTokenId","type":"uint256"}],"name":"SplitPosition","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"WithdrawFromPosition","type":"event"},{"inputs":[],"name":"MAX_BOOST_MULTIPLIER_LIMIT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MAX_GLOBAL_MULTIPLIER_LIMIT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MAX_LOCK_MULTIPLIER_LIMIT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amountToAdd","type":"uint256"}],"name":"addToPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"boost","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"createPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"emergencyUnlock","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"emergencyWithdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"exists","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"boostPoints","type":"uint256"}],"name":"getMultiplierByBoostPoints","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"getMultiplierByLockDuration","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getMultiplierSettings","outputs":[{"internalType":"uint256","name":"maxGlobalMultiplier","type":"uint256"},{"internalType":"uint256","name":"maxLockDuration","type":"uint256"},{"internalType":"uint256","name":"maxLockMultiplier","type":"uint256"},{"internalType":"uint256","name":"maxBoostMultiplier","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPoolInfo","outputs":[{"internalType":"address","name":"lpToken","type":"address"},{"internalType":"address","name":"grailToken","type":"address"},{"internalType":"address","name":"xGrailToken","type":"address"},{"internalType":"uint256","name":"lastRewardTime","type":"uint256"},{"internalType":"uint256","name":"accRewardsPerShare","type":"uint256"},{"internalType":"uint256","name":"lpSupply","type":"uint256"},{"internalType":"uint256","name":"lpSupplyWithMultiplier","type":"uint256"},{"internalType":"uint256","name":"allocPoint","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getStakingPosition","outputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint256","name":"amountWithMultiplier","type":"uint256"},{"internalType":"uint256","name":"startLockTime","type":"uint256"},{"internalType":"uint256","name":"lockDuration","type":"uint256"},{"internalType":"uint256","name":"lockMultiplier","type":"uint256"},{"internalType":"uint256","name":"rewardDebt","type":"uint256"},{"internalType":"uint256","name":"boostPoints","type":"uint256"},{"internalType":"uint256","name":"totalMultiplier","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"harvestPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"address","name":"to","type":"address"}],"name":"harvestPositionTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"tokenIds","type":"uint256[]"},{"internalType":"address","name":"to","type":"address"}],"name":"harvestPositionsTo","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"hasDeposits","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"contract ICamelotMaster","name":"master_","type":"address"},{"internalType":"contract IERC20","name":"grailToken","type":"address"},{"internalType":"contract IXGrailToken","name":"xGrailToken","type":"address"},{"internalType":"contract IERC20","name":"lpToken","type":"address"}],"name":"initialize","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"initialized","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_operator","type":"address"}],"name":"isUnlockOperator","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isUnlocked","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"lastTokenId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"lockPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"master","outputs":[{"internalType":"contract ICamelotMaster","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256[]","name":"tokenIds","type":"uint256[]"},{"internalType":"uint256","name":"lockDuration","type":"uint256"}],"name":"mergePositions","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"operator","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"pendingRewards","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"renewLockPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"maxGlobalMultiplier","type":"uint256"},{"internalType":"uint256","name":"maxBoostMultiplier","type":"uint256"}],"name":"setBoostMultiplierSettings","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bool","name":"emergencyUnlock_","type":"bool"}],"name":"setEmergencyUnlock","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"maxLockDuration","type":"uint256"},{"internalType":"uint256","name":"maxLockMultiplier","type":"uint256"}],"name":"setLockMultiplierSettings","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator_","type":"address"}],"name":"setOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_operator","type":"address"},{"internalType":"bool","name":"add","type":"bool"}],"name":"setUnlockOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"xGrailRewardsShare_","type":"uint256"}],"name":"setXGrailRewardsShare","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"splitAmount","type":"uint256"}],"name":"splitPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"index","type":"uint256"}],"name":"tokenOfOwnerByIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"unboost","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"unlockOperator","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"unlockOperatorsLength","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"updatePool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"uint256","name":"amountToWithdraw","type":"uint256"}],"name":"withdrawFromPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"xGrailRewardsShare","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"yieldBooster","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}]');
        ;// ./src/contracts/abis/camelotLp.json
        const camelotLp_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[{"internalType":"address","name":"_pool","type":"address"},{"internalType":"address","name":"_owner","type":"address"},{"internalType":"string","name":"name","type":"string"},{"internalType":"string","name":"symbol","type":"string"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"shares","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"Deposit","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"int24","name":"tick","type":"int24"},{"indexed":false,"internalType":"uint256","name":"totalAmount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalAmount1","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"feeAmount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"feeAmount1","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalSupply","type":"uint256"}],"name":"Rebalance","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"newFee","type":"uint8"}],"name":"SetFee","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"shares","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"Withdraw","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint8","name":"fee","type":"uint8"},{"indexed":false,"internalType":"uint256","name":"fees0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"fees1","type":"uint256"}],"name":"ZeroBurn","type":"event"},{"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"PRECISION","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"},{"internalType":"uint256[2]","name":"inMin","type":"uint256[2]"}],"name":"addLiquidity","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"algebraMintCallback","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseLower","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseUpper","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256[4]","name":"inMin","type":"uint256[4]"}],"name":"compound","outputs":[{"internalType":"uint128","name":"baseToken0Owed","type":"uint128"},{"internalType":"uint128","name":"baseToken1Owed","type":"uint128"},{"internalType":"uint128","name":"limitToken0Owed","type":"uint128"},{"internalType":"uint128","name":"limitToken1Owed","type":"uint128"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"currentTick","outputs":[{"internalType":"int24","name":"tick","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"subtractedValue","type":"uint256"}],"name":"decreaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"deposit0","type":"uint256"},{"internalType":"uint256","name":"deposit1","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256[4]","name":"inMin","type":"uint256[4]"}],"name":"deposit","outputs":[{"internalType":"uint256","name":"shares","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"deposit0Max","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"deposit1Max","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"directDeposit","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"fee","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"feeRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBasePosition","outputs":[{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLimitPosition","outputs":[{"internalType":"uint128","name":"liquidity","type":"uint128"},{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalAmounts","outputs":[{"internalType":"uint256","name":"total0","type":"uint256"},{"internalType":"uint256","name":"total1","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"addedValue","type":"uint256"}],"name":"increaseAllowance","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"limitLower","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"limitUpper","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxTotalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"pool","outputs":[{"internalType":"contract IAlgebraPool","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"int24","name":"tickLower","type":"int24"},{"internalType":"int24","name":"tickUpper","type":"int24"},{"internalType":"uint128","name":"shares","type":"uint128"},{"internalType":"uint256[2]","name":"amountMin","type":"uint256[2]"}],"name":"pullLiquidity","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"int24","name":"_baseLower","type":"int24"},{"internalType":"int24","name":"_baseUpper","type":"int24"},{"internalType":"int24","name":"_limitLower","type":"int24"},{"internalType":"int24","name":"_limitUpper","type":"int24"},{"internalType":"address","name":"_feeRecipient","type":"address"},{"internalType":"uint256[4]","name":"inMin","type":"uint256[4]"},{"internalType":"uint256[4]","name":"outMin","type":"uint256[4]"}],"name":"rebalance","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"removeWhitelisted","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint8","name":"newFee","type":"uint8"}],"name":"setFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"int24","name":"newTickSpacing","type":"int24"}],"name":"setTickSpacing","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_address","type":"address"}],"name":"setWhitelist","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tickSpacing","outputs":[{"internalType":"int24","name":"","type":"int24"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"toggleDirectDeposit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"token0","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"token1","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"whitelistedAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"shares","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256[4]","name":"minAmounts","type":"uint256[4]"}],"name":"withdraw","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}]');
        ;// ./src/contracts/abis/AutoLayerAbis/TokenBalanceManager.json
        const TokenBalanceManager_namespaceObject = /*#__PURE__*/JSON.parse('[{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address[]","name":"tokenAddresses","type":"address[]"}],"name":"getBalanceForAddressesList","outputs":[{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"address","name":"token","type":"address"}],"name":"getSingleBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}]');
        ;// ./src/contracts/abis/index.ts
        const AUTOLAYER_ABIS = { "0xa4b1": { swapContract: constants/* IS_DEV */.HL ? swapAbiArbitrumDEV_namespaceObject : swapAbiArbitrumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject }, "0x1": { swapContract: constants/* IS_DEV */.HL ? swapAbiEthereumDEV_namespaceObject : swapAbiEthereumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject }, "0x38": { swapContract: constants/* IS_DEV */.HL ? swapAbiEthereumDEV_namespaceObject : swapAbiEthereumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject }, "0x2105": { swapContract: constants/* IS_DEV */.HL ? swapAbiEthereumDEV_namespaceObject : swapAbiEthereumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject }, "0xe708": { swapContract: constants/* IS_DEV */.HL ? swapAbiEthereumDEV_namespaceObject : swapAbiEthereumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject }, "0xa": { swapContract: constants/* IS_DEV */.HL ? swapAbiEthereumDEV_namespaceObject : swapAbiEthereumPRO_namespaceObject, pointsContract: pointsAbi_namespaceObject } }; const abis_GENERIC_ABIS = { gammaContractAbi: gammaContract_namespaceObject, nftPoolCamelotAbi: nftPoolCamelot_namespaceObject, camelotLpAbi: camelotLp_namespaceObject, token: tokenAbi_namespaceObject, balancerVault: BalancerVault_namespaceObject, CamelotPoolsInfoAbi: CamelotPoolsInfoAbi_namespaceObject, tokenBalanceManagerAbi: TokenBalanceManager_namespaceObject };
        ;// ./src/contracts/addresses.ts
        const CAMELOT_POOLS_INFO = "0x5652b1aDcA3047ee1518c8893A4E3670A32f6A66"; const swapContractDEV = "0x9235f91630D49344FbFD2f975decc78c313f008E"; const pointsContractDEV = "0xcC9fD3a26A657635016148DBa8C3C00DbC175757"; const pointsMultipleSeasonArbDEV = "0x583a137D927ab7D183f12b3CD53cDE3062777E94"; const referalArbDEV = "0xB73C0c4E238455bD0cf27a790D2b4315A3170e55"; const swapContractPROD = "0x7d71F03B550D7373F965098c2E618005ff580740"; const pointsContractPROD = "0x052a9b2D41207ecCb1b63Af90236AFA4F515a217"; const pointsMultipleSeasonArbPRO = "0xEE7c5DAa083b6e5867b8d708Aa82B20328be2EA8"; const referalArbPRO = "0x65740Ce1a059094DeA19e2Aa6d11219dE5fCC275"; const swapContractEthDEV = "0x05854f7fb3E21760184C768B2a6fE0363EAFaFBE"; const pointsContractEthDEV = "0x9566D8998a47D53C948803744864e63456177353"; const swapContractEthereumPROD = "0x51591b8e88739B8f823307dcA92220f479709868"; const pointsContractEthereumPROD = "0x9566D8998a47D53C948803744864e63456177353"; const pointsMultipleSeasonEthPRO = "0x0066d7600Ee5A01BA2D1194723523d0D701a9938"; const referalEthPRO = "0x14D33B74Ed2ef1bdf8AF49B6C0f221877ccafCE3"; const swapContractBnbDEV = "0xA6C83520610D5d9399568be60D4B3cC9AC951286"; const pointsContractBnbDEV = "0x0f69682Bb7E6269225B0349A67cC5dc8BDC94fC9"; const pointsMultipleSeasonBnbDEV = "0xc10ae42be523093976f5fed67b39e22403200113"; const referalBnbDEV = "0x9864294b35e6531E2ea82caE81B573092194EF74"; const swapContractBnbPROD = "0x25c3388ffB182187b3B1A0A6DbB5D6C9e3F5Df09"; const pointsContractBnbPROD = "0x9566D8998a47D53C948803744864e63456177353"; const pointsMultipleSeasonBnbPRO = "0x05854f7fb3E21760184C768B2a6fE0363EAFaFBE"; const referalBnbPRO = "0xfF89342C737Ae850d620842089073a0E94a8C7BB"; const pointsOptimismDEV = "0x6ffC92822FBeC64c250e6B76e16c331c3d22d391"; const multipleSeasonOptimismDEV = "0x611d9DaBfe93Da81bA35324C76e4DB88B09c5456"; const referalOptimismDEV = "0x53DeA76df3dA9f27C1313CE186fA90C46e1E4427"; const swapContractOptimismDEV = "0x4d3Cb5EC44C609dB073786448E13bB9616f8d2d5"; const pointsOptimismPRO = "0x9566D8998a47D53C948803744864e63456177353"; const multipleSeasonOptimismPRO = "0xBC28FC02568EB3A74f84E21b8976cC8DE34a315F"; const referalOptimismPRO = "0x1B5AA205e1f216d49d0b7d3313C0b9037AF66845"; const swapContractOptimismPRO = "0x8f73B8303198C30Df10E02257EfBd17f7eC929a8"; const pointsBaseDEV = "0xA735BDE3dcb77F4442Ee90b10868A70346Fc7DAf"; const multipleSeasonBaseDEV = "0xe7350651d22bd1843531De9631735620a83cF792"; const referalBaseDEV = "0xd5dC90100777f800F1adAB275435Dfffda6B49b0"; const swapContracBaseDEV = "0x85C031266b4bfc52219ED285660196C3608a98F4"; const pointsBasePRO = "0x9566D8998a47D53C948803744864e63456177353"; const multipleSeasonBasePRO = "0xBC28FC02568EB3A74f84E21b8976cC8DE34a315F"; const referalBasePRO = "0x1B5AA205e1f216d49d0b7d3313C0b9037AF66845"; const swapContracBasePRO = "0x8f73B8303198C30Df10E02257EfBd17f7eC929a8"; const pointsModeDEV = "0x33e034CF6f0847cDFCf92737F22552d329098fE6"; const multipleSeasonModeDEV = "0xbefA54f940101476998D546553993f434E1Df7Fe"; const pointsScrollDEV = "0x33e034CF6f0847cDFCf92737F22552d329098fE6"; const multipleSeasonScrollDEV = "0xbefA54f940101476998D546553993f434E1Df7Fe"; const SWAPS_CONTRACT = { "0xa4b1": constants/* IS_DEV */.HL ? swapContractDEV : swapContractPROD, "0x1": constants/* IS_DEV */.HL ? swapContractEthDEV : swapContractEthereumPROD, "0x38": constants/* IS_DEV */.HL ? swapContractBnbDEV : swapContractBnbPROD, "0xa": constants/* IS_DEV */.HL ? swapContractOptimismDEV : swapContractOptimismPRO, "0x2105": constants/* IS_DEV */.HL ? swapContracBaseDEV : swapContracBasePRO, "0xe708": constants/* IS_DEV */.HL ? "a" : "b", "0x868b": constants/* IS_DEV */.HL ? "a" : "b", "0x82750": constants/* IS_DEV */.HL ? "a" : "b" }; const POINTS_CONTRACT = { "0xa4b1": constants/* IS_DEV */.HL ? pointsContractDEV : pointsContractPROD, "0x1": constants/* IS_DEV */.HL ? pointsContractEthDEV : pointsContractEthereumPROD, "0x38": constants/* IS_DEV */.HL ? pointsContractBnbDEV : pointsContractBnbPROD, "0xa": constants/* IS_DEV */.HL ? pointsOptimismDEV : pointsOptimismPRO, "0x2105": constants/* IS_DEV */.HL ? pointsBaseDEV : pointsBasePRO, "0xe708": constants/* IS_DEV */.HL ? "a" : "b", "0x868b": constants/* IS_DEV */.HL ? pointsModeDEV : "b", "0x82750": constants/* IS_DEV */.HL ? pointsScrollDEV : "b" }; const POINTS_SEASON2_CONTRACT = { "0xa4b1": constants/* IS_DEV */.HL ? pointsMultipleSeasonArbDEV : pointsMultipleSeasonArbPRO, "0x1": pointsMultipleSeasonEthPRO, "0x38": constants/* IS_DEV */.HL ? pointsMultipleSeasonBnbDEV : pointsMultipleSeasonBnbPRO, "0xa": constants/* IS_DEV */.HL ? multipleSeasonOptimismDEV : multipleSeasonOptimismPRO, "0x2105": constants/* IS_DEV */.HL ? multipleSeasonBaseDEV : multipleSeasonBasePRO, "0xe708": constants/* IS_DEV */.HL ? "a" : "b", "0x868b": constants/* IS_DEV */.HL ? multipleSeasonModeDEV : multipleSeasonModeDEV, "0x82750": constants/* IS_DEV */.HL ? multipleSeasonScrollDEV : multipleSeasonScrollDEV }; const REFERALS_CONTRACT = { "0xa4b1": constants/* IS_DEV */.HL ? referalArbDEV : referalArbPRO, "0x38": constants/* IS_DEV */.HL ? referalBnbDEV : referalBnbPRO, "0x1": referalEthPRO, "0xa": constants/* IS_DEV */.HL ? referalOptimismDEV : referalOptimismPRO, "0x2105": constants/* IS_DEV */.HL ? referalBaseDEV : referalBasePRO, "0xe708": constants/* IS_DEV */.HL ? "a" : "b", "0x868b": constants/* IS_DEV */.HL ? "a" : "b", "0x82750": constants/* IS_DEV */.HL ? "a" : "b" };
        // EXTERNAL MODULE: ./node_modules/web3/lib/esm/index.js + 250 modules
        var esm = __webpack_require__(52380);
        ;// ./src/contracts/web3.ts
        const web3Instances = new Map; const rpcSelector = networkName => { switch (networkName) { case "arbitrum": return constants/* ARBITRUM */.x1.rpcUrls[0]; case "binance": return constants/* BINANCE */.dO.rpcUrls[0]; case "ethereum": return constants/* ETHEREUM */.yK.rpcUrls[0]; case "linea": return constants/* LINEA */.OD.rpcUrls[0]; case "mode": return constants/* MODE */.g.rpcUrls[0]; case "optimism": return constants/* OPTIMISM */.zC.rpcUrls[0]; case "scroll": return constants/* SCROLL */.u.rpcUrls[0]; case "base": return constants/* BASE */.Wm.rpcUrls[0]; default: return constants/* ETHEREUM */.yK.rpcUrls[0] } }; const web3_getWeb3 = networkName => { if (!web3Instances.has(networkName)) { const rpc = rpcSelector(networkName); const web3 = new esm/* default */.Ay$(rpc); web3Instances.set(networkName, web3) } return web3Instances.get(networkName) };/* harmony default export */ const contracts_web3 = (web3_getWeb3);
        ;// ./src/contracts/getAutoLayerPoints.ts
        const getAutolayerPoints = async userAddress => { const arbWeb3 = contracts_web3("arbitrum"); const ethWeb3 = contracts_web3("ethereum"); const bnbWeb3 = contracts_web3("binance"); const optimismWeb3 = contracts_web3("optimism"); const baseWeb3 = contracts_web3("base"); const pointsAddressArb = POINTS_CONTRACT[Networks.arbitrum]; const pointAddressEth = POINTS_CONTRACT[Networks.ethereum]; const pointAddressBnb = POINTS_CONTRACT[Networks.binance]; const pointAddressOptimism = POINTS_CONTRACT[Networks.optimism]; const pointAddressBase = POINTS_CONTRACT[Networks.base]; const pointsAbi = AUTOLAYER_ABIS["0x1"].pointsContract; const pointsContractArb = new arbWeb3.eth.Contract(pointsAbi, pointsAddressArb); const pointsContractEth = new ethWeb3.eth.Contract(pointsAbi, pointAddressEth); const pointsContractBnb = new bnbWeb3.eth.Contract(pointsAbi, pointAddressBnb); const pointsContractOptimism = new optimismWeb3.eth.Contract(pointsAbi, pointAddressOptimism); const pointsContractBase = new baseWeb3.eth.Contract(pointsAbi, pointAddressBase); const userPointsWeiArb = await pointsContractArb.methods.userPoints(userAddress).call(); const userPointsWeiEth = await pointsContractEth.methods.userPoints(userAddress).call(); const userPointsWeiBnb = await pointsContractBnb.methods.userPoints(userAddress).call(); const userPointsWeiOptimism = await pointsContractOptimism.methods.userPoints(userAddress).call(); const userPointsWeiBase = await pointsContractBase.methods.userPoints(userAddress).call(); const userPointsArb = arbWeb3.utils.fromWei(userPointsWeiArb.toString(), "ether"); const userPointsEth = ethWeb3.utils.fromWei(userPointsWeiEth.toString(), "ether"); const userPointsBnb = bnbWeb3.utils.fromWei(userPointsWeiBnb.toString(), "ether"); const userPointsOptimism = optimismWeb3.utils.fromWei(userPointsWeiOptimism.toString(), "ether"); const userPointsBase = baseWeb3.utils.fromWei(userPointsWeiBase.toString(), "ether"); const total = parseFloat(userPointsArb) + parseFloat(userPointsEth) + parseFloat(userPointsBnb) + parseFloat(userPointsOptimism) + parseFloat(userPointsBase); return total.toFixed(5) };/* harmony default export */ const getAutoLayerPoints = (getAutolayerPoints); const getAutolayerPointsAfterTx = (sendSwapTx, wallet, isDeposit = true, outputAddress) => { if (!isDeposit) { const isForPoints = Arbitrum_ArbitrumData.tokensLRS.some(token => token.address.toLowerCase() === outputAddress.toLowerCase()); if (!isForPoints) { return { transactionHash: sendSwapTx?.transactionHash, points: "0" } } } const arbWeb3 = contracts_web3("arbitrum"); const pointTopic = "0x235c18fe54960bc2b1072d9a404e225ef54b523b788af3cb8510696cd28d1621"; const logs = sendSwapTx?.logs; const filterdLogsByTopic = logs?.filter(log => log?.topics.includes(pointTopic)); const decodedData = filterdLogsByTopic?.map(log => arbWeb3.eth.abi.decodeParameters([{ type: "address", name: "user" }, { type: "uint256", name: "points" }], log?.data)); const info = decodedData.find(info => info.user.toLowerCase() === wallet); const pointsWei = info.points; const points = arbWeb3.utils.fromWei(pointsWei, "ether"); return { transactionHash: sendSwapTx?.transactionHash, points } };
        ;// ./src/hooks/usePromise.ts
        const cacheTime = 3e4; const activeCalls = []; function findCall(func, args) { for (const call of activeCalls) { if (call.func !== func) continue; if (call.args.length !== args.length) continue; if (call.args.some((a, i) => a !== args[i])) continue; return call } return null } function cleanupCalls() { const now = Date.now(); let i = 0; let j = 0; while (i < activeCalls.length) { const val = activeCalls[i]; const isInactive = val.state !== "pending" && val.uses === 0 && now - val.resolvedDate >= cacheTime; if (!isInactive) activeCalls[j++] = val; i++ } activeCalls.length = j } function getCacheSize() { return activeCalls.length } function usePromise_usePromise(promiseCreator, ...args) { const found = findCall(promiseCreator, args); (0, react.useEffect)(() => { if (found) { found.uses++; return () => { found.uses--; setTimeout(cleanupCalls, cacheTime) } } }, [found]); if (found) { if (found.state === "resolved") { return found.value } else if (found.state === "rejected") { throw found.error } else { throw found.promise } } const status = { func: promiseCreator, args, uses: 0, state: "pending", promise: promiseCreator(...args) }; activeCalls.push(status); status.promise.finally(() => { status.resolvedDate = Date.now(); setTimeout(cleanupCalls, cacheTime) }).then(v => { status.state = "resolved"; status.value = v }).catch(e => { status.state = "rejected"; status.error = e }); throw status.promise }/* harmony default export */ const hooks_usePromise = (usePromise_usePromise);
        ;// ./src/hooks/useWallet.ts
        function useWallet_useWallet() { const userAddress = (0, es/* useSelector */.d4)(state => state.wallet?.address || null); return userAddress }
        ;// ./src/hooks/useAutolayerPoints.ts
        function useAutolayerPoints(refreshKey) { const wallet = useWallet_useWallet(); const points = hooks_usePromise(getAutoLayerPoints, wallet, refreshKey); return { points } }
        ;// ./src/hooks/useCoingecko.ts
        const useCoingecko = () => { const route = "/prices/variation"; const pricesVariation = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + route); return pricesVariation };/* harmony default export */ const hooks_useCoingecko = (useCoingecko);
        ;// ./src/data/Ethereum/tokensLRS.json
        const Ethereum_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"swBTC","address":"0x8DB2350D78aBc13f5673A411D4700BCF87864dDE","name":"Swell BTC (swBTC)","decimals":"8","network":"0x1","type":"LRT","image":"https://i.imgur.com/wpoqefL.jpeg","description":"Swell has launched the first Bitcoin LRT to offer restaking rewards from the Ethereum ecosystem! Swell Restaked BTC (swBTC) holders will earn restaking yield from Symbiotic, EigenLayer, and Karak — with the opportunity to further boost yield in DeFi. swBTC joins swETH and rswETH as another restaking primitive supporting Swell L2 – the upcoming restaking yield layer for Ethereum.","opengraph":"Introducing Swell\'s latest innovation: the first Bitcoin LRT offering restaking rewards from the Ethereum ecosystem! 🚀 \\nHold Swell Restaked BTC (swBTC) and earn restaking yields from Symbiotic, EigenLayer, and Karak — with opportunities to boost your yield even further in DeFi. 💰 \\nJoin the restaking revolution with swBTC, alongside swETH and rswETH, as we build Swell L2 — the upcoming restaking yield layer for Ethereum."},{"id":"pzETH","address":"0x8c9532a60E0E7C6BbD2B2c1303F63aCE1c3E9811","name":"Renzo Restaked LST (pzETH)","decimals":"18","network":"0x1","type":"LRT","image":"https://i.imgur.com/n7N17i0.jpeg","description":"$pzETH is a liquid restaking token representing a user’s restaked position within the Symbiotic ecosystem. Users can deposit $stETH, $wstETH, $wETH, or $ETH to receive $pzETH in return. Serving as the interface to the Symbiotic ecosystem, $ezETH secures Actively Validated Services (AVSs) to generate both staking and restaking rewards.","opengraph":"Introducing $pzETH: a liquid restaking token for the Symbiotic ecosystem. Deposit $stETH, $wstETH, $wETH, or $ETH to receive $pzETH. Secure AVSs and earn staking and restaking rewards."},{"id":"rsETH","address":"0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7","name":"Kelp DAO Restaked ETH (rsETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"kelp":1},"image":"https://i.imgur.com/dCtZ8nq.jpeg","description":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking.","opengraph":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking."},{"id":"ezETH","address":"0xbf5495Efe5DB9ce00f80364C8B423567e58d2110","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/oAskLTj.jpeg","description":"weETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"eETH","address":"0x35fA164735182de50811E8e2E824cFb9B6118ac2","name":"ether.fi ETH (eETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/oAskLTj.jpeg","description":"eETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"eETH integrates seamlessly with the Ethereum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"inETH","address":"0xf073bAC22DAb7FaF4a3Dd6c6189a70D54110525C","name":"Inception ETH (inETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1},"image":"https://imgur.com/TqBCHcV.jpeg","description":"InceptionLRT restaked ETH (InETH) Token, inETH mirrors the value of the underlying staked ETH, giving holders a tradable asset that reflects their staking contributions and accrued rewards.","opengraph":"The inETH Token mirrors the value of your staked ETH, offering a tradable asset that reflects your staking rewards. Enjoy greater liquidity and freedom with inETH as it moves and trades effortlessly across supported dapps and exchanges."},{"id":"pufETH","address":"0xD9A442856C234a39a81a089C06451EBAa4306a72","name":"Puffer ETH (pufETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/oYFLYM5.jpeg","description":"pufETH is implemented as a reward-bearing ERC20 token, following ERC4626 standard and inspired by Compound\'s cToken design for optimal DeFi compatibility. It represents a novel approach in the liquid staking domain, introducing several features that enhance stakers\' rewards and interaction with DeFi protocols.","opengraph":"pufETH is implemented as a reward-bearing ERC20 token, following ERC4626 standard and inspired by Compound\'s cToken design for optimal DeFi compatibility. It represents a novel approach in the liquid staking domain, introducing several features that enhance stakers\' rewards and interaction with DeFi protocols."},{"id":"rswETH","address":"0xFAe103DC9cf190eD75350761e95403b7b8aFa6c0","name":"Swell ETH (rswETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/Ziiw2UK.jpeg","description":"rswETH gives you uncapped access to EigenLayer, giving you unlimited access to future restaking rewards by contributing economic security to a range of different protocols.","opengraph":"rswETH gives you uncapped access to EigenLayer, giving you unlimited access to future restaking rewards by contributing economic security to a range of different protocols."},{"id":"uniETH","address":"0xF1376bceF0f78459C0Ed0ba5ddce976F1ddF51F4","name":"Bedrock Restaked ETH (uniETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/TdCqwSm.jpeg","description":"uniETH represents the staked ETH in Bedrock plus all future staking rewards. uniETH is non-rebasing, i.e. does not grow in quantity over time but grows in value instead. In other words, 1 uniETH will be worth more than 1 ETH as time goes on, and its value will continue to increase as more time passes.","opengraph":"uniETH represents the staked ETH in Bedrock plus all future staking rewards. uniETH is non-rebasing, i.e. does not grow in quantity over time but grows in value instead. In other words, 1 uniETH will be worth more than 1 ETH as time goes on, and its value will continue to increase as more time passes."},{"id":"primeETH","address":"0x6ef3D766Dfe02Dc4bF04aAe9122EB9A0Ded25615","name":"Prime staked ETH (primeETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1},"image":"https://i.imgur.com/S8gYasI.jpeg","description":"Prime Staked ETH (primeETH) is a liquid restaked token (LRT) that provides liquidity for assets that have been deposited into EigenLayer. By converting staked ETH into primeETH, users can stack ETH staking yield, EigenLayer points, and primeETH XP points all while remaining liquid.","opengraph":"Prime Staked ETH (primeETH) is a liquid restaked token (LRT) that provides liquidity for assets that have been deposited into EigenLayer. By converting staked ETH into primeETH, users can stack ETH staking yield, EigenLayer points, and primeETH XP points all while remaining liquid."},{"id":"inETH","address":"0xf073bAC22DAb7FaF4a3Dd6c6189a70D54110525C","name":"Inception ETH (inETH)","decimals":"18","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"renzo":1.5,"symbiotic":1,"mellow":1},"image":"https://i.imgur.com/n7N17i0.jpeg","description":"$pzETH is a liquid restaking token representing a user’s restaked position within the Symbiotic ecosystem. Users can deposit $stETH, $wstETH, $wETH, or $ETH to receive $pzETH in return. Serving as the interface to the Symbiotic ecosystem, $ezETH secures Actively Validated Services (AVSs) to generate both staking and restaking rewards.","opengraph":"Introducing $pzETH: a liquid restaking token for the Symbiotic ecosystem. Deposit $stETH, $wstETH, $wETH, or $ETH to receive $pzETH. Secure AVSs and earn staking and restaking rewards."},{"id":"swBTC","address":"0x8DB2350D78aBc13f5673A411D4700BCF87864dDE","name":"Swell BTC LRT (swBTC)","decimals":"8","network":"0x1","type":"LRT","multipliers":{"autoLayer":1,"swell":3,"symbiotic":1,"karak":1,"eigenLayer":1},"image":"https://i.imgur.com/wpoqefL.jpeg","description":"Swell has launched the first Bitcoin LRT to offer restaking rewards from the Ethereum ecosystem! Swell Restaked BTC (swBTC) holders will earn restaking yield from Symbiotic, EigenLayer, and Karak — with the opportunity to further boost yield in DeFi. swBTC joins swETH and rswETH as another restaking primitive supporting Swell L2 – the upcoming restaking yield layer for Ethereum.","opengraph":"Introducing Swell\'s latest innovation: the first Bitcoin LRT offering restaking rewards from the Ethereum ecosystem! 🚀 \\nHold Swell Restaked BTC (swBTC) and earn restaking yields from Symbiotic, EigenLayer, and Karak — with opportunities to boost your yield even further in DeFi. 💰 \\nJoin the restaking revolution with swBTC, alongside swETH and rswETH, as we build Swell L2 — the upcoming restaking yield layer for Ethereum."}]');
        ;// ./src/data/Ethereum/tokens.json
        const Ethereum_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC","address":"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48","decimals":"6","name":"USD Coin"},{"id":"USDT","address":"0xdac17f958d2ee523a2206206994597c13d831ec7","decimals":"6","name":"Tether USD"},{"id":"ankrETH","address":"0xe95a203b1a91a908f9b9ce46459d101078c2c3cb","name":"Ankr Staked ETH","decimals":"18"},{"id":"sfrxETH","address":"0xac3E018457B222d93114458476f3E3416Abbe38F","name":"Staked Frax ETH","decimals":"18"},{"id":"rETH","address":"0xae78736cd615f374d3085123a210448e74fc6393","name":"Rocket Pool ETH","decimals":"18"},{"id":"cbETH","address":"0xbe9895146f7af43049ca1c1ae358b0541ea49704","name":"Coinbase Wrapped Staked ETH","decimals":"18"},{"id":"wstETH","address":"0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0","name":"Wrapped liquid staked Ether 2.0","decimals":"18"},{"id":"PENDLE","address":"0x808507121b80c02388fad14726482e061b8da827","decimals":"18","name":"Pendle"},{"id":"ARB","address":"0xB50721BCf8d664c30412Cfbc6cf7a15145234ad1","decimals":"18","name":"Arbitrum"},{"id":"WETH","address":"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0x2260fac5e5542a773aa44fbcfedf7c193bc2c599","decimals":"8","name":"Wrapped BTC"},{"id":"DAI","address":"0x6b175474e89094c44da98b954eedeac495271d0f","decimals":"18","name":"Dai Stablecoin"},{"id":"LDO","address":"0x5a98fcbea516cf06857215779fd812ca3bef1b32","decimals":"18","name":"Lido DAO Token"},{"id":"UNI","address":"0x1f9840a85d5af5bf1d1762f925bdaddc4201f984","decimals":"18","name":"Uniswap"},{"id":"BAL","address":"0xba100000625a3754423978a60c9317c58a424e3D","decimals":"18","name":"Balancer"},{"id":"LINK","address":"0x514910771af9ca656af840dff83e8264ecf986ca","decimals":"18","name":"Chainlink"},{"id":"RNDR","address":"0x6De037ef9aD2725EB40118Bb1702EBb27e4Aeb24","decimals":"18","name":"Render Token"},{"id":"RDNT","address":"0x137dDB47Ee24EaA998a535Ab00378d6BFa84F893","decimals":"18","name":"Radient"},{"id":"RPL","address":"0xd33526068d116ce69f19a9ee46f0bd304f21a51f","decimals":"18","name":"Rocket Pool Protocol"},{"id":"CRV","address":"0xD533a949740bb3306d119CC777fa900bA034cd52","decimals":"18","name":"Curve DAO Token"},{"id":"NEAR","address":"0x85F17Cf997934a597031b2E18a9aB6ebD4B9f6a4","decimals":"18","name":"Near"},{"id":"TRX","address":"0x50327c6c5a14DCaDE707ABad2E27eB517df87AB5","decimals":"18","name":"Tron"}]');
        ;// ./src/data/Ethereum/index.ts
        const Ethereum_lrtTokens = Ethereum_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Ethereum_newTokens = Ethereum_tokens_namespaceObject.slice(0, 3).concat(Ethereum_lrtTokens).concat(Ethereum_tokens_namespaceObject.slice(3)); const EthereumData = { tokensLRS: Ethereum_tokensLRS_namespaceObject, tokens: Ethereum_newTokens };
        ;// ./src/data/Linea/tokensLRS.json
        const Linea_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"rsETH","address":"0x4186BFC76E2E237523CBC30FD220FE055156b41F","name":"Kelp DAO Restaked ETH (rsETH)","decimals":"18","network":"0xe708","type":"LRT","image":"https://i.imgur.com/dCtZ8nq.jpeg","description":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking.","opengraph":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking."},{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0xe708","type":"LRT","image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x1Bf74C010E6320bab11e2e5A532b5AC15e0b8aA6","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0xe708","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"uniETH","address":"0x15EEfE5B297136b8712291B632404B66A8eF4D25","name":"Bedrock Restaked ETH (uniETH)","decimals":"18","network":"0xe708","type":"LRT","image":"https://i.imgur.com/TdCqwSm.jpeg","description":"uniETH represents the staked ETH in Bedrock plus all future staking rewards. uniETH is non-rebasing, i.e. does not grow in quantity over time but grows in value instead. In other words, 1 uniETH will be worth more than 1 ETH as time goes on, and its value will continue to increase as more time passes.","opengraph":"uniETH represents the staked ETH in Bedrock plus all future staking rewards. uniETH is non-rebasing, i.e. does not grow in quantity over time but grows in value instead. In other words, 1 uniETH will be worth more than 1 ETH as time goes on, and its value will continue to increase as more time passes."}]');
        ;// ./src/data/Linea/tokens.json
        const Linea_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC","address":"0x176211869cA2b568f2A7D4EE941E073a821EE1ff","decimals":"6","name":"USDC"},{"id":"USDT","address":"0xA219439258ca9da29E9Cc4cE5596924745e12B93","decimals":"6","name":"Tether USD"},{"id":"WETH","address":"0xe5D7C2a44FfDDf6b295A15c148167daaAf5Cf34f","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0x3aAB2285ddcDdaD8edf438C1bAB47e1a9D05a9b4","decimals":"8","name":"Wrapped BTC"},{"id":"DAI","address":"0x4AF15ec2A0BD43Db75dd04E62FAA3B8EF36b00d5","decimals":"18","name":"DAI Stablecoin"},{"id":"LINK","address":"0x5B16228B94b68C7cE33AF2ACc5663eBdE4dCFA2d","decimals":"18","name":"Chainlink Token"},{"id":"BNB","address":"0xf5C6825015280CdfD0b56903F9F8B5A2233476F5","decimals":"18","name":"Binance Coin"}]');
        ;// ./src/data/Linea/index.ts
        const Linea_lrtTokens = Linea_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Linea_newTokens = Linea_tokens_namespaceObject.slice(0, 3).concat(Linea_lrtTokens).concat(Linea_tokens_namespaceObject.slice(3)); const LineaData = { tokensLRS: Linea_tokensLRS_namespaceObject, tokens: Linea_newTokens };
        ;// ./src/data/Mode/tokensLRS.json
        const Mode_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0x868b","type":"LRT","image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0x868b","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"}]');
        ;// ./src/data/Mode/tokens.json
        const Mode_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC","address":"0xd988097fb8612cc24eeC14542bC03424c656005f","decimals":"6","name":"USDC"},{"id":"USDT","address":"0xf0F161fDA2712DB8b566946122a5af183995e2eD","decimals":"6","name":"Tether USD"},{"id":"WETH","address":"0x4200000000000000000000000000000000000006","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0xcDd475325D6F564d27247D1DddBb0DAc6fA0a5CF","decimals":"8","name":"Wrapped BTC"},{"id":"Mode","address":"0xDfc7C877a950e49D2610114102175A06C2e3167a","decimals":"18","name":"Mode token"}]');
        ;// ./src/data/Mode/index.ts
        const Mode_lrtTokens = Mode_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Mode_newTokens = Mode_tokens_namespaceObject.slice(0, 3).concat(Mode_lrtTokens).concat(Mode_tokens_namespaceObject.slice(3)); const ModeData = { tokensLRS: Mode_tokensLRS_namespaceObject, tokens: Mode_newTokens };
        ;// ./src/data/Base/tokensLRS.json
        const Base_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"rsETH","address":"0x1Bc71130A0e39942a7658878169764Bbd8A45993","name":"Kelp DAO Restaked ETH (rsETH)","decimals":"18","network":"0x2105","type":"LRT","image":"https://i.imgur.com/dCtZ8nq.jpeg","description":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking.","opengraph":"Discover rsETH by Kelp DAO: rsETH is designed to offer liquidity to illiquid assets deposited into restaking platforms, such as EigenLayer. It aims to address the risks and challenges posed by the current offering of restaking."},{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0x2105","type":"LRT","image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"weETH","address":"0x04C0599Ae5A44757c0af6F9eC3b93da8976c150A","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0x2105","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"}]');
        ;// ./src/data/Base/tokens.json
        const Base_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC","address":"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913","decimals":"6","name":"USDC"},{"id":"WETH","address":"0x4200000000000000000000000000000000000006","decimals":"18","name":"Wrapped Ether"},{"id":"DAI","address":"0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb","decimals":"18","name":"DAI Stablecoin"},{"id":"USDbC","address":"0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA","decimals":"6","name":"USD Base Coin"},{"id":"CRV","address":"0x8Ee73c484A26e0A5df2Ee2a4960B789967dd0415","decimals":"18","name":"Curve DAO Token"}]');
        ;// ./src/data/Base/index.ts
        const Base_lrtTokens = Base_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Base_newTokens = Base_tokens_namespaceObject.slice(0, 3).concat(Base_lrtTokens).concat(Base_tokens_namespaceObject.slice(3)); const BaseData = { tokensLRS: Base_tokensLRS_namespaceObject, tokens: Base_newTokens };
        ;// ./src/data/Optimism/tokensLRS.json
        const Optimism_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"weETH","address":"0x346e03F8Cce9fE01dCB3d0Da3e9D00dC2c0E08f0","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0xa","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"},{"id":"ezETH","address":"0x2416092f143378750bb29b79eD961ab195CcEea5","name":"Renzo Restaked ETH (ezETH)","decimals":"18","network":"0xa","type":"LRT","image":"https://i.imgur.com/XNo74yX.jpeg","description":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators.","opengraph":"ezETH is the liquid restaking token for users\' positions at Renzo, an LRT and Strategy Manager for EigenLayer. Renzo secures AVSs and offers higher yields than ETH staking, abstracting complexity for effortless collaboration between users and EigenLayer node operators."},{"id":"inETH","address":"0x5A7a183B6B44Dc4EC2E3d2eF43F98C5152b1d76d","name":"Inception ETH (inETH)","decimals":"18","network":"0xa","type":"LRT","image":"https://imgur.com/TqBCHcV.jpeg","description":"InceptionLRT restaked ETH (InETH) Token, inETH mirrors the value of the underlying staked ETH, giving holders a tradable asset that reflects their staking contributions and accrued rewards.","opengraph":"The inETH Token mirrors the value of your staked ETH, offering a tradable asset that reflects your staking rewards. Enjoy greater liquidity and freedom with inETH as it moves and trades effortlessly across supported dapps and exchanges."}]');
        ;// ./src/data/Optimism/tokens.json
        const Optimism_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC.e","address":"0x7F5c764cBc14f9669B88837ca1490cCa17c31607","decimals":"6","name":"USDC bridge Ethereum"},{"id":"USDT","address":"0x94b008aA00579c1307B0EF2c499aD98a8ce58e58","decimals":"6","name":"Tether USD"},{"id":"WETH","address":"0x4200000000000000000000000000000000000006","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0x68f180fcCe6836688e9084f035309E29Bf0A2095","decimals":"8","name":"Wrapped BTC"},{"id":"DAI","address":"0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1","decimals":"18","name":"DAI Stablecoin"},{"id":"LINK","address":"0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6","decimals":"18","name":"Chainlink Token"},{"id":"OP","address":"0x4200000000000000000000000000000000000042","decimals":"18","name":"Optimism Token"},{"id":"PENDLE","address":"0xBC7B1Ff1c6989f006a1185318eD4E7b5796e66E1","decimals":"18","name":"Pendle Token"},{"id":"NEXT","address":"0x58b9cB810A68a7f3e1E4f8Cb45D1B9B3c79705E8","decimals":"18","name":"Everclear"}]');
        ;// ./src/data/Optimism/index.ts
        const Optimism_lrtTokens = Optimism_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Optimism_newTokens = Optimism_tokens_namespaceObject.slice(0, 3).concat(Optimism_lrtTokens).concat(Optimism_tokens_namespaceObject.slice(3)); const OptimismData = { tokensLRS: Optimism_tokensLRS_namespaceObject, tokens: Optimism_newTokens };
        ;// ./src/data/Scroll/tokensLRS.json
        const Scroll_tokensLRS_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"weETH","address":"0x01f0a31698C4d065659b9bdC21B3610292a1c506","name":"Ether.fi Wrapped ETH (weETH)","decimals":"18","network":"0x82750","type":"LRT","image":"https://i.imgur.com/HZ9xoNl.jpeg","description":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space","opengraph":"weETH integrates seamlessly with the Arbitrum ecosystem, offering users a flexible and secure way to contribute to network validation and participate in the DeFi space"}]');
        ;// ./src/data/Scroll/tokens.json
        const Scroll_tokens_namespaceObject = /*#__PURE__*/JSON.parse('[{"id":"ETH","address":"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE","decimals":"18","name":"ETH"},{"id":"USDC","address":"0x06eFdBFf2a14a7c8E15944D1F4A48F9F95F663A4","decimals":"6","name":"USDC"},{"id":"USDT","address":"0xf55BEC9cafDbE8730f096Aa55dad6D22d44099Df","decimals":"6","name":"Tether USD"},{"id":"WETH","address":"0x5300000000000000000000000000000000000004","decimals":"18","name":"Wrapped Ether"},{"id":"WBTC","address":"0x3C1BCa5a656e69edCD0D4E36BEbb3FcDAcA60Cf1","decimals":"8","name":"Wrapped BTC"},{"id":"DAI","address":"0xcA77eB3fEFe3725Dc33bccB54eDEFc3D9f764f97","decimals":"18","name":"DAI Stablecoin"},{"id":"CRV","address":"0xB755039eDc7910C1F1BD985D48322E55A31AC0bF","decimals":"18","name":"Curve DAO Token"}]');
        ;// ./src/data/Scroll/index.ts
        const Scroll_lrtTokens = Scroll_tokensLRS_namespaceObject.map(t => ({ address: t.address, id: t.id, name: t.name, decimals: t.decimals })); const Scroll_newTokens = Scroll_tokens_namespaceObject.slice(0, 3).concat(Scroll_lrtTokens).concat(Scroll_tokens_namespaceObject.slice(3)); const ScrollData = { tokensLRS: Scroll_tokensLRS_namespaceObject, tokens: Scroll_newTokens };
        ;// ./src/data/index.ts
        const defaultNetworkData = { tokens: [], tokensLRS: [], camelotPools: [], pools: [] }; const data_networkData = chainId => { if (!chainId) { return DEFAULT_NETWORK_DATA } else if (chainId?.toLowerCase() === Networks.ethereum.toLowerCase()) { return EthereumData } else if (chainId?.toLowerCase() === Networks.arbitrum.toLowerCase()) { return Arbitrum_ArbitrumData } else if (chainId?.toLowerCase() === Networks.binance.toLowerCase()) { return BinanceData } else if (chainId?.toLowerCase() === Networks.linea.toLowerCase()) { return LineaData } else if (chainId?.toLowerCase() === Networks.mode.toLowerCase()) { return ModeData } else if (chainId?.toLowerCase() === Networks.base.toLowerCase()) { return BaseData } else if (chainId?.toLowerCase() === Networks.optimism.toLowerCase()) { return OptimismData } else if (chainId?.toLowerCase() === Networks.scroll.toLowerCase()) { return ScrollData } else { return defaultNetworkData } };
        ;// ./src/contracts/getBalance/getBalanceFromTokenManager.ts
        const TOKEN_BALANCE_MANAGER = { "0x1": "0x9825A225ceB7E759bB117D2a19e2FC88ECD535A5", "0xa4b1": "0x28a8e8d4aD238dB7c61b0677bAbdB4FBcDa2b16f", "0x38": "0xf31bC28d0dAc6Bec888206eC1B062b588C1da507", "0xa": "0xbefA54f940101476998D546553993f434E1Df7Fe", "0x2105": "0x98998257bDe09006D366405245C6b8d4226A99e3", "0xe708": "0x98998257bDe09006D366405245C6b8d4226A99e3", "0x868b": "0x98998257bDe09006D366405245C6b8d4226A99e3", "0x82750": "0x98998257bDe09006D366405245C6b8d4226A99e3" }; const getManagerInstance = networkName => { const networkId = getNetworkIdByName(networkName); const tokenManagerAddress = TOKEN_BALANCE_MANAGER[networkId]; const dataNetwork = data_networkData(networkId); const abi = abis_GENERIC_ABIS.tokenBalanceManagerAbi; const web3 = contracts_web3(networkName); const tokenManagerContract = new web3.eth.Contract(abi, tokenManagerAddress); return { tokenManagerContract, web3, dataNetwork } }; const getSingleBalanceFromTokenManager = async (networkName, userAddress, tokenAddress) => { const { tokenManagerContract, web3, dataNetwork } = getManagerInstance(networkName); const balanceWei = await tokenManagerContract.methods.getSingleBalance(userAddress.toLowerCase(), tokenAddress.toLowerCase()).call(); const balance = web3.utils.fromWei(balanceWei, "ether"); const id = dataNetwork.tokensLRS.find(t => t.address.toLowerCase() === tokenAddress.toLowerCase())?.id; return { balance, id, balanceWei, address: tokenAddress, networkName } }; const getBalanceListFromTokenManager = async (networkName, userAddress, allList = true, tokensList = []) => { const { tokenManagerContract, web3, dataNetwork } = getManagerInstance(networkName); const tokens = allList ? dataNetwork.tokensLRS.map(t => t.address.toLowerCase()) : tokensList; const balancesWei = await tokenManagerContract.methods.getBalanceForAddressesList(userAddress, tokens).call(); const result = tokens.map((token, i) => { const balance = web3.utils.fromWei(balancesWei[i], "ether"); const id = dataNetwork.tokensLRS.find(t => t.address.toLowerCase() === token.toLowerCase())?.id; return { balance, id, balanceWei: balancesWei[i], address: token } }); return result };
        ;// ./src/hooks/useTokensLRTValueUsd.ts
        const useTokensLRTValueUsd = chainId => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const coingeckoData = hooks_useCoingecko(); const address = wallet?.address ? wallet.address : null; const networkName = getNetworkName(chainId); const balancesTokens = hooks_usePromise(getBalanceListFromTokenManager, networkName, address); const tokensUsdValue = balancesTokens?.reduce((acc, b) => { const currentPrice = coingeckoData.find(c => c.symbol?.toLowerCase() === b.id?.toLowerCase())?.current_price; const balance = parseFloat(b.balance) || 0; if (!currentPrice) return acc; return acc + balance * currentPrice || 0 }, 0) ?? 0; return { tokensUsdValue, balancesTokens } };/* harmony default export */ const hooks_useTokensLRTValueUsd = (useTokensLRTValueUsd);
        ;// ./src/contracts/getBalance/getBalanceListBatch.ts
        const getTokensLRTBalanceListBatch = async (tokensList, address, chainId) => { const userAddress = address; if (!userAddress) return []; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); const batchRequest = new web3.BatchRequest; const weiBalance = tokensList.map((token, index) => { const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, token?.address); const data = tokenContract.methods.balanceOf(userAddress).encodeABI(); const jsonRpc = { jsonrpc: "2.0", method: "eth_call", params: [{ to: token?.address, data, from: userAddress }, "latest"], id: index }; return batchRequest.add(jsonRpc) }); let balancesWei = []; try { await batchRequest.execute(); balancesWei = await Promise.all(weiBalance) } catch (error) { console.error("Error getting balances in batch", error) } const balancesEth = balancesWei?.map(balance => web3.utils.fromWei(balance, "ether")); const balancesResult = tokensList.map((token, i) => { const info = { balance: parseFloat(balancesEth[i]).toString(), id: token.id, name: token.name, address: token.address }; return info }); return balancesResult }; const getPoolsBalanceListBatch = async (pools, address) => { const userAddress = address; if (!userAddress) return []; const web3 = contracts_web3("arbitrum"); const batchRequest = new web3.BatchRequest; const weiBalance = pools.map((token, index) => { const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, token?.address); const data = tokenContract.methods.balanceOf(userAddress).encodeABI(); const jsonRpc = { jsonrpc: "2.0", method: "eth_call", params: [{ to: token?.address, data }], id: index }; return batchRequest.add(jsonRpc) }); await batchRequest.execute(); const balancesWei = await Promise.all(weiBalance); const balancesEth = balancesWei.map(balance => web3.utils.fromWei(balance, "ether")); const balancesResult = pools.map((token, i) => { const info = { balance: balancesEth[i], id: token.id, name: token.name, address: token.address }; return info }); return balancesResult };
        ;// ./src/utils/tokenAddressToName.ts
        const tokenAddressToName = (tokenAddress, chainId) => { const networkInfo = networkData(chainId); const token = networkInfo.tokens?.find(t => t.address?.toLowerCase() === tokenAddress?.toLowerCase()); if (token) { return token?.name } else return "" };/* harmony default export */ const utils_tokenAddressToName = ((/* unused pure expression or super */ null && (tokenAddressToName))); const tokenAddressToSymbol = (tokenAddress, chainId) => { const networkInfo = data_networkData(chainId); const token = networkInfo.tokens?.find(t => t.address?.toLowerCase() === tokenAddress?.toLowerCase()); if (token) { return token?.id } else return "" };
        ;// ./src/contracts/Camelot/calculateLpValues.ts
        const calculateLpValues = (data, coingeckoData) => { const web3 = contracts_web3("arbitrum"); const completeInfo = data.map(d => { const token0Symbol = tokenAddressToSymbol(d.token0, Networks.arbitrum); const token1Symbol = tokenAddressToSymbol(d.token1, Networks.arbitrum); const token0Price = coingeckoData.find(data => data.symbol.toLowerCase() === token0Symbol.toLowerCase())?.current_price; const token1Price = coingeckoData.find(data => data.symbol.toLowerCase() === token1Symbol.toLowerCase())?.current_price; const amount0 = parseFloat(web3.utils.fromWei(d.totalAmount[0], "ether")); const amount1 = parseFloat(web3.utils.fromWei(d.totalAmount[1], "ether")); const liquidityUSD = amount0 * token0Price + amount1 * token1Price; const lpPrice = liquidityUSD / parseFloat(web3.utils.fromWei(d.totalSupply, "ether")); const lpEthAmount = parseFloat(web3.utils.fromWei(d.userLPs, "ether")); const usdUserValue = lpEthAmount * lpPrice; return { ...d, usdUserValue, lpPrice, liquidityUSD } }); return completeInfo };/* harmony default export */ const Camelot_calculateLpValues = (calculateLpValues);
        ;// ./src/contracts/Camelot/getFullCamelotData.ts
        const poolsTokens = [{ token0: "0x4186BFC76E2E237523CBC30FD220FE055156b41F", token1: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1" }, { token0: "0x2416092f143378750bb29b79eD961ab195CcEea5", token1: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1" }]; const getFullCamelotData = async user => { if (!user) return; const web3 = contracts_web3("arbitrum"); const contract = new web3.eth.Contract(abis_GENERIC_ABIS.CamelotPoolsInfoAbi, CAMELOT_POOLS_INFO); const data = await contract.methods.getCamelotPoolsData(user).call(); const formatedData = data.map((d, i) => ({ nftContractAddress: d.nftContract, poolAddress: d.poolAddress, totalSupply: d.totalSupply, userLPs: d.userLPs, totalAmount: [d.totalAmounts.total0, d.totalAmounts.total1], token0: poolsTokens[i].token0, token1: poolsTokens[i].token1 })); return formatedData };/* harmony default export */ const Camelot_getFullCamelotData = (getFullCamelotData);
        ;// ./src/hooks/useDepositUsdPoints.ts
        const useDepositUsdPoints = () => { const wallet = (0, es/* useSelector */.d4)(s => s?.wallet); const coingeckoData = hooks_useCoingecko(); const { tokensUsdValue } = hooks_useTokensLRTValueUsd(Networks.arbitrum); const pools = hooks_usePools(); const poolsList = (0, react.useMemo)(() => Arbitrum_ArbitrumData.pools, []); const balanceBPT = hooks_usePromise(getPoolsBalanceListBatch, poolsList, wallet?.address); const poolsWithBalance = pools.map(pool => { const bptBalance = balanceBPT.find(b => b.address.toLowerCase() === pool.address.toLowerCase())?.balance || 0; const bptPrice = parseFloat(pool.liquidity) / parseFloat(pool.totalShares); const bptUserUsdValue = bptPrice * bptBalance; return { ...pool, bptBalance, bptPrice: bptPrice?.toFixed(2), bptUserUsdValue } }); const balancerUsdValue = poolsWithBalance?.reduce((acc, p) => acc + p.bptUserUsdValue, 0) ?? 0; const poolsFullData = hooks_usePromise(Camelot_getFullCamelotData, wallet?.address); const camelotPoolsWithUserUsdValue = Camelot_calculateLpValues(poolsFullData, coingeckoData); const camelotUsdValue = camelotPoolsWithUserUsdValue?.reduce((acc, p) => acc + p.usdUserValue, 0); return tokensUsdValue + balancerUsdValue + camelotUsdValue };/* harmony default export */ const hooks_useDepositUsdPoints = (useDepositUsdPoints);
        ;// ./src/components/Points/PointsDashboard/PointsInfo/PointsInfo.tsx
        const PointsInfo = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "points-info", children:/*#__PURE__*/(0, jsx_runtime.jsx)("a", { target: "_blank", rel: "noopener noreferrer", href: "https://docs.autolayer.io/autolayer/welcome/introduction/points-system", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "?" }) }) }) };/* harmony default export */ const PointsInfo_PointsInfo = (PointsInfo);
        ;// ./src/components/Points/PointsDashboard/CommonPoints/CommonPoints.tsx
        function CommonPoints({ amount = 0, children, type, withInfo = false, inlineLogo = false }) { const DECIMALS = amount < 1e3 ? 2 : 3; const finalAmount = useCompactNumbers(); const value = finalAmount(amount, DECIMALS); const title = amount === -1 ? "coming soon" : amount < 1 ? amount.toFixed(5) : amount.toFixed(2); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "inside-container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `dashboard.${type}` }) }), withInfo ?/*#__PURE__*/(0, jsx_runtime.jsx)(PointsInfo_PointsInfo, {}) : null] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h3", { title: title, children: [type === "your-deposit" ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "currency", children: "$" }) : "", +value === -1 ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { id: "coming-soon", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "coming-soon" }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: value })] }), inlineLogo ? children : null] })] }) }
        ;// ./src/components/Points/PointsDashboard/TopPointsDashboard.tsx
        function TopPointsDashboard(props) { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: `points-item-dashboard points-item-${props.type}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(CommonPoints, { ...props }),/*#__PURE__*/(0, jsx_runtime.jsx)("footer", { className: props.grouped ? "group" : "", children: props.children })] }) }
        // EXTERNAL MODULE: ./node_modules/@gluedigital/modal/es/index.js
        var modal_es = __webpack_require__(63353);
        ;// ./src/helpers/addTokensWeightForPools.ts
        const addTokensWeightForPools = (poolsWithBalance, coingeckoData) => { const poolsWithTokenWeight = poolsWithBalance.map(pool => { const tokens = pool.filteredTokens; const totalLiquidity = Number(pool.liquidity); const updatedTokens = tokens.map(token => { const tokenBalance = Number(token.balance); try { const { current_price: usdPrice, price_change_percentage_24h: priceChangePercentage24h } = coingeckoData.find(c => c.symbol?.toLowerCase() === token.symbol?.toLowerCase()); const usdValue = usdPrice ? tokenBalance * usdPrice : 0; const tokenWeight = usdValue / totalLiquidity; return { ...token, weight: tokenWeight, usdPrice, usdValue, priceVariation24h: priceChangePercentage24h } } catch (error) { return { ...token, weight: 0, usdPrice: 0, usdValue: 0, priceVariation24h: 0 } } }); const previousWeights = updatedTokens.slice(0, tokens.length - 1).reduce((acc, t) => acc + t.weight, 0); const lastToken = updatedTokens[updatedTokens.length - 1]; lastToken.weight = 1 - previousWeights; const realTokens = updatedTokens.filter(t => t.weight !== 0); const totalPriceVariation = realTokens.reduce((acc, t) => acc + t.priceVariation24h * t.weight, 0); const priceVariation = totalPriceVariation / realTokens.length; return { ...pool, filteredTokens: updatedTokens, priceVariation } }); return poolsWithTokenWeight };/* harmony default export */ const helpers_addTokensWeightForPools = (addTokensWeightForPools);
        ;// ./src/hooks/usePortfolio.ts
        const useAssetsPortfolio = chainId => { const wallet = (0, es/* useSelector */.d4)(s => s?.wallet); const networkInfo = (0, react.useMemo)(() => data_networkData(chainId), [chainId]); const balanceCoins = hooks_usePromise(getTokensLRTBalanceListBatch, networkInfo.tokensLRS, wallet?.address, chainId); const networkName = getNetworkName(chainId); const priceVariation = hooks_useCoingecko(); const tokens = balanceCoins.map(coin => { const coingeckoData = priceVariation.find(p => p.symbol?.toLowerCase() === coin?.id?.toLowerCase()); const usdValue = coingeckoData?.current_price * coin.balance; const type = networkInfo.tokensLRS.find(t => t.address?.toLowerCase() === coin?.address?.toLowerCase())?.type; return { ...coin, usdValue, type, priceVariation: coingeckoData?.price_change_percentage_24h, networkName } }); const tokensFiltered = tokens.filter(t => t.balance > 0 || t.usdValue > 0); if (tokensFiltered.length === 0) { return { tokens, totalVariation24h: "0.00", totalUsdValue: 0 } } const tokensTotalPortfolioUsdValue = tokensFiltered.reduce((acc, t) => acc + t.usdValue, 0); const accPriceVariation = tokensFiltered.reduce((acc, t) => { const usdPercentage = t.usdValue / tokensTotalPortfolioUsdValue; return acc + t.priceVariation * usdPercentage }, 0); const totalVariation = (accPriceVariation / tokensFiltered?.length)?.toFixed(2); const result = { tokens: tokensFiltered, totalVariation24h: totalVariation, totalUsdValue: tokensTotalPortfolioUsdValue }; return result }; const useStrategiesPortfolio = () => { const wallet = (0, es/* useSelector */.d4)(s => s?.wallet); const networkInfo = data_networkData(Networks.arbitrum); const pools = hooks_usePools(); const coingeckoData = hooks_useCoingecko(); const balanceBPT = hooks_usePromise(getPoolsBalanceListBatch, networkInfo.pools, wallet?.address); const poolsWithBalance = pools.map(pool => { const bptBalance = balanceBPT.find(b => b.address.toLowerCase() === pool.address.toLowerCase())?.balance || 0; const bptPrice = parseFloat(pool.liquidity) / parseFloat(pool.totalShares); const bptUserUsdValue = bptPrice * bptBalance; return { ...pool, bptBalance, bptPrice: bptPrice?.toFixed(2), bptUserUsdValue } }); const poolsWithTokenWeight = helpers_addTokensWeightForPools(poolsWithBalance, coingeckoData); const totalStrategiesUsdValue = poolsWithTokenWeight.reduce((acc, p) => acc + p.bptUserUsdValue, 0); const totalVariation = totalStrategiesUsdValue === 0 ? 0 : poolsWithTokenWeight.reduce((acc, p) => acc + p.priceVariation * p.bptUserUsdValue / totalStrategiesUsdValue, 0); return { strategies: poolsWithTokenWeight, totalVariation24h: totalVariation.toFixed(2), totalUsdValue: totalStrategiesUsdValue } }; const useCamelotPortfolio = () => { const camelotPools = useCamelotPools(); const wallet = (0, es/* useSelector */.d4)(s => s?.wallet); const coingeckoData = hooks_useCoingecko(); const poolsFullData = hooks_usePromise(Camelot_getFullCamelotData, wallet?.address); const camelotPoolsWithUserUsdValue = Camelot_calculateLpValues(poolsFullData, coingeckoData); const camelotCompleteInfo = camelotPools.map(p => { const poolInfo = camelotPoolsWithUserUsdValue.find(c => c.nftContractAddress.toLowerCase() === p.nftAddress.toLowerCase()); return { ...p, ...poolInfo } }); const totalUserUsdValue = camelotCompleteInfo.reduce((acc, c) => acc + c.usdUserValue, 0); const poolsWithPriceVariation = camelotCompleteInfo.map(p => { const totalPriceVariation = p.filteredTokens.reduce((acc, t) => acc + t.priceVariation24h * t.weight, 0); const priceVariation = totalPriceVariation / p.filteredTokens.length; return { ...p, priceVariation } }); const totalVariation = totalUserUsdValue === 0 ? 0 : poolsWithPriceVariation.reduce((acc, c) => acc + c.priceVariation * c.usdUserValue / totalUserUsdValue, 0); return { camelot: camelotCompleteInfo, totalUsdValue: totalUserUsdValue, totalVariation24h: totalVariation.toFixed(2) } }; const usePortfolio = () => { const arbitrumAssets = useAssetsPortfolio(Networks.arbitrum); const ethereumAssets = useAssetsPortfolio(Networks.ethereum); const binanceAssets = useAssetsPortfolio(Networks.binance); const baseAssets = useAssetsPortfolio(Networks.base); const optimismAssets = useAssetsPortfolio(Networks.optimism); const modeAssets = useAssetsPortfolio(Networks.mode); const scrollAssets = useAssetsPortfolio(Networks.scroll); const allTokens = [...arbitrumAssets.tokens, ...ethereumAssets.tokens, ...binanceAssets.tokens, ...baseAssets.tokens, ...optimismAssets.tokens, ...modeAssets.tokens, ...scrollAssets.tokens]; const strategies = useStrategiesPortfolio(); const camelot = useCamelotPortfolio(); const totalPortfolioUsdValue = arbitrumAssets.totalUsdValue + ethereumAssets.totalUsdValue + binanceAssets.totalUsdValue + strategies.totalUsdValue + camelot.totalUsdValue; const totalVariation = (parseFloat(arbitrumAssets?.totalVariation24h) + parseFloat(ethereumAssets?.totalVariation24h) + parseFloat(binanceAssets?.totalVariation24h) + parseFloat(strategies?.totalVariation24h) + parseFloat(camelot?.totalVariation24h))?.toFixed(2); return { tokens: allTokens, strategies: strategies.strategies, camelot: camelot.camelot, totalVariation24h: totalVariation, totalUsdValue: totalPortfolioUsdValue } };/* harmony default export */ const hooks_usePortfolio = (usePortfolio);
        ;// ./src/components/modals/PortfolioModal/AssetBodyTable/AssetBodyTable.tsx
        const AssetRow = ({ card }) => { const { balance, id, name, usdValue, type, priceVariation, networkName } = card; const modal = (0, modal_es/* useModal */.hS)(); const navigate = (0, dist/* useNavigate */.Zp)(); const handleRow = () => { navigate(`/info/${type.toLowerCase()}/${networkName}/${id.toLowerCase()}`); modal.hide() }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { className: "asset-row port-folio-grid-row", id: `asset-row-${id}`, onClick: () => handleRow(), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-token", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: id, src: getTokenImage(id.toLowerCase()), alt: id }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("td", { className: "row-title", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { title: name, children: name }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { title: id, className: "token-id", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: id }), " - ", networkName] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-amount", children:/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { title: balance.toString(), children: (+balance).toFixed(5) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("td", { className: "row-usd-value", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "amount", title: "$" + usdValue.toString(), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "dollar-symbol", children: "$" }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: usdValue.toFixed(2) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { title: priceVariation.toString() + "%", className: priceVariation > 0 ? "variation" : "variation red", children: ["(", (priceVariation > 0 ? "+" : "") + priceVariation?.toFixed(2), "%)"] })] })] }, id + networkName) }; const AssetBodyTable = () => { const arbData = useAssetsPortfolio(Networks.arbitrum); const bnbData = useAssetsPortfolio(Networks.binance); const baseAssets = useAssetsPortfolio(Networks.base); const optimismAssets = useAssetsPortfolio(Networks.optimism); const modeAssets = useAssetsPortfolio(Networks.mode); const scrollAssets = useAssetsPortfolio(Networks.scroll); const ethData = useAssetsPortfolio(Networks.ethereum); const tokens = [...arbData.tokens, ...ethData.tokens, ...bnbData.tokens, ...baseAssets.tokens, ...optimismAssets.tokens, ...modeAssets.tokens, ...scrollAssets.tokens]; const assets = tokens.filter(d => d.balance > 0 || d.usdValue > 0); return /*#__PURE__*/(0, jsx_runtime.jsxs)("table", { className: "portfolio-table", id: "asset-table", cellSpacing: 0, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("colgroup", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-token" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-title" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-amount" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-usd-value" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("thead", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-token", children: "Token" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-title", children: "Title" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-amount", children: "Amount" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-usd-value", children: "USD Value" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("tbody", { children: assets.map(d =>/*#__PURE__*/(0, jsx_runtime.jsx)(AssetRow, { card: d }, `${d.id}-${d.networkName}`)) })] }) };/* harmony default export */ const AssetBodyTable_AssetBodyTable = (AssetBodyTable);
        ;// ./src/components/Loading/Spinner/Spinner.tsx
        const Spinner = () =>/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "spinner" });/* harmony default export */ const Spinner_Spinner = (Spinner);
        ;// ./src/components/modals/PortfolioModal/PortfolioHeader/PortfolioHeader.tsx
        const YourDeposit = () => { const portfolioData = hooks_usePortfolio(); const totalUsdValue = portfolioData?.totalUsdValue; const DECIMALS = totalUsdValue < 1e3 ? 2 : 3; const finalAmount = useCompactNumbers(); const totalVariation = portfolioData?.totalVariation24h; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "your-deposit", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "currency", children: "$ " }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: finalAmount(totalUsdValue, DECIMALS) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [totalVariation, "%"] })] }) }; const PortfolioHeader = () => { const modal = (0, modal_es/* useModal */.hS)(); return /*#__PURE__*/(0, jsx_runtime.jsx)("header", { id: "masthead-portfolio", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "header-container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: () => modal.hide(), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_left" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "back-text", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "back-to-dashboard" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "your-portfolio" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "error", children: "Error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(YourDeposit, {}) }) })] }) }) };/* harmony default export */ const PortfolioHeader_PortfolioHeader = (PortfolioHeader);
        ;// ./src/hooks/useWindowDimensions.ts
        const getWindowDimensions = () => { if (false) { } const { innerWidth: width, innerHeight: height } = window; return { width, height } }; const useWindowDimensions = () => { const [windowDimensions, setWindowDimensions] = (0, react.useState)(getWindowDimensions()); (0, react.useEffect)(() => { const handleResize = () => { setWindowDimensions(getWindowDimensions()) }; window.addEventListener("resize", handleResize); return () => window.removeEventListener("resize", handleResize) }, []); return windowDimensions };/* harmony default export */ const hooks_useWindowDimensions = (useWindowDimensions);
        ;// ./src/hooks/useIsResponsive.ts
        const useIsResponsive = () => { const { width, height } = hooks_useWindowDimensions(); const isResponsive = width < 1024 && height < 1280; return isResponsive };/* harmony default export */ const hooks_useIsResponsive = (useIsResponsive);
        ;// ./src/components/modals/PortfolioModal/DefiBodyTable/DefiBodyTable.tsx
        const DefiRow = ({ strategy, camelotPools }) => { const name = strategy ? strategy.name : camelotPools.name; const lpUserUsdValue = strategy ? strategy.bptUserUsdValue : camelotPools.usdUserValue; const apy = strategy ? strategy.apy : camelotPools.apy; const tokens = strategy ? strategy.filteredTokens : camelotPools.filteredTokens; const provider = strategy ? strategy.provider : camelotPools.provider; const address = strategy ? strategy.address : camelotPools.pos; const lpName = strategy ? strategy.bptName : camelotPools.bptName; const modal = (0, modal_es/* useModal */.hS)(); const navigate = (0, dist/* useNavigate */.Zp)(); const isResponsive = hooks_useIsResponsive(); const networkName = "arbitrum"; const handleRow = () => { navigate(`/info/defi-strategies/${networkName}/${address.toLowerCase()}`); modal.hide() }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { className: "defi-row port-folio-grid-row", id: `defi-row-${lpName}`, onClick: () => handleRow(), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("td", { className: "row-title", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { title: name, children: name }), isResponsive &&/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `protocol ${provider?.toLocaleLowerCase()}`, children: provider })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-token", children:/*#__PURE__*/(0, jsx_runtime.jsx)(TokenImageList_TokenImageList, { tokens: tokens, mini: true }) }), !isResponsive &&/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-protocol", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `protocol ${provider?.toLocaleLowerCase()}`, children: provider }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-apy", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { title: apy?.toString() + "%", className: "apy", children: [(+apy)?.toFixed(2), "%"] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "row-usd-value", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "amount", title: "$" + lpUserUsdValue?.toString(), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "dollar-symbol", children: "$" }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: lpUserUsdValue?.toFixed(2) })] }) })] }) }; const DefiBodyTable = () => { const data = hooks_usePortfolio(); const isResponsive = hooks_useIsResponsive(); const strategies = data.strategies.filter(d => d.bptBalance > 0 || d.bptUserUsdValue > 0); const camelotPools = data.camelot.filter(d => d.balanceLp > 0 || d.usdUserValue > 0); return /*#__PURE__*/(0, jsx_runtime.jsxs)("table", { className: "portfolio-table", id: "defi-table", cellSpacing: 0, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("colgroup", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-title" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-tokens" }), !isResponsive &&/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-protocol" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-apy" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-usd-value" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("thead", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-title", children: "Title" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-token", children: "Tokens" }), !isResponsive &&/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-protocol", children: "Protocol" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-apy", children: "Apy" }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { className: "row-usd-value", children: "USD Value" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("tbody", { children: [strategies.map(d =>/*#__PURE__*/(0, jsx_runtime.jsx)(DefiRow, { strategy: d }, d.id)), camelotPools.map(d =>/*#__PURE__*/(0, jsx_runtime.jsx)(DefiRow, { camelotPools: d }, d.id))] })] }) };/* harmony default export */ const DefiBodyTable_DefiBodyTable = (DefiBodyTable);
        ;// ./src/hooks/useEigenLayerPoints.ts
        const useReducedRenzoPoints = () => { const userAddress = useWallet_useWallet(); const renzoPointsInfo = (0, index_esm/* useFetch */.st)(`${constants/* dataMicroserviceUrl */.dF}/lrst/ezeth/points/${userAddress}`); const { totals } = renzoPointsInfo; const { eigenLayerPoints, renzoPoints } = totals; return { eigenLayerPoints: eigenLayerPoints.toString() || "0", points: renzoPoints.toString() || "0" } }; const useRenzoPoints = () => { const userAddress = useWallet_useWallet(); const renzoPointsInfo = (0, index_esm/* useFetch */.st)(`${constants/* dataMicroserviceUrl */.dF}/lrst/ezeth/points/${userAddress}`); const { totals, breakdown } = renzoPointsInfo; const { eigenLayerPoints, renzoPoints, symbioticPoints, mellowPoints } = totals; const newTotals = { eigenLayerPoints: eigenLayerPoints.toString() || "0", renzoPoints: renzoPoints.toString() || "0", symbioticPoints: symbioticPoints.toString() || "0", mellowPoints: mellowPoints.toString() || "0" }; const pointsBreakdown = breakdown?.materialView?.pointsBreakdown || []; const balanceRenzoInfo = pointsBreakdown.find(type => type.id === "balancer"); const camelotRenzoInfo = pointsBreakdown.find(type => type.id === "camelot"); const walletRenzoInfo = pointsBreakdown.find(type => type.id === "wallet"); const balancer = { eigenLayerPoints: balanceRenzoInfo?.eigenLayerPoints?.toString() || "0", renzoPoints: balanceRenzoInfo?.renzoPoints?.toString() || "0", symbioticPoints: balanceRenzoInfo?.symbioticPoints?.toString() || "0", mellowPoints: balanceRenzoInfo?.mellowPoints?.toString() || "0" }; const camelot = { eigenLayerPoints: camelotRenzoInfo?.eigenLayerPoints?.toString() || "0", renzoPoints: camelotRenzoInfo?.renzoPoints?.toString() || "0", symbioticPoints: camelotRenzoInfo?.symbioticPoints?.toString() || "0", mellowPoints: camelotRenzoInfo?.mellowPoints?.toString() || "0" }; const tokenHold = { eigenLayerPoints: walletRenzoInfo.eigenLayerPoints.toString() || "0", renzoPoints: walletRenzoInfo.renzoPoints.toString() || "0", symbioticPoints: walletRenzoInfo?.symbioticPoints?.toString() || "0", mellowPoints: walletRenzoInfo?.mellowPoints?.toString() || "0" }; return { totals: newTotals, balancer, camelot, tokenHold } }; const useKelpPoints = () => { const userAddress = useWallet_useWallet(); const res = (0, index_esm/* useFetch */.st)(`https://common.kelpdao.xyz/km-el-points/user/${userAddress}`); const eigenLayerPoints = parseFloat(res?.value?.elPoints)?.toString(); const points = parseFloat(res?.value?.kelpMiles)?.toString(); return { eigenLayerPoints, points } }; const useReducedEtherFiPoints = () => { const wallet = useWallet_useWallet(); const result = (0, index_esm/* useFetch */.st)(`${constants/* dataMicroserviceUrl */.dF}/lrst/etherfi/points/${wallet}`); const { totalEigenLayerPoints, totalEtherFiPoints: points } = result.total; return { eigenLayerPoints: totalEigenLayerPoints, points } }; const useEtherFiPoints = () => { const wallet = useWallet_useWallet(); const result = (0, index_esm/* useFetch */.st)(`${constants/* dataMicroserviceUrl */.dF}/lrst/etherfi/points/${wallet}`); return result }; const usePufferPoints = () => { const wallet = useWallet_useWallet(); const result = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + "/lrst/puffer/points/" + wallet); const { pufferPoints: points, eigenLayerPoints } = result; return { points, eigenLayerPoints } }; const useSwellPoints = () => { const wallet = useWallet_useWallet(); const url = `https://v3-lst.svc.swellnetwork.io/swell.v3.VoyageService/VoyageUser?connect=v1&encoding=json&message=%7B%22address%22%3A%22${wallet}%22%7D`; const res = (0, index_esm/* useFetch */.st)(url); const points = isNaN(+res?.points) ? 0 : +res?.points; return { points: points.toString() } }; const useBedrockPoints = () => { const wallet = useWallet_useWallet(); const result = (0, index_esm/* useFetch */.st)(`${constants/* dataMicroserviceUrl */.dF}/lrst/bedrock/points/${wallet}`); const { uniethPoints: points, eigenLayerPoints } = result; if (!points || !eigenLayerPoints) { return { points: "0", eigenLayerPoints: "0" } } return { points: points.toString(), eigenLayerPoints: eigenLayerPoints.toString() } }; const useClaystackpoints = () => { const wallet = useWallet(); const result = useFetch(`${dataMicroserviceUrl}/lrst/clay/points/${wallet}`); const { clayPoints: points, eigenLayerPoints } = result; return { points, eigenLayerPoints } }; const usePrimestakedPoints = () => {
          const wallet = useWallet_useWallet(); const query = `query UserPoints($address: String) {
    lrtPointRecipients(
      limit: 1
      orderBy: pointsDate_DESC
      where: {id_containsInsensitive: $address}
    ) {
      id
      balance
      points
      pointsDate
      referralPoints
      elPoints
    }
    }`; const url = "https://squid.subsquid.io/prime-eth-squid/graphql"; const options = { method: "POST", headers: { "Content-Type": "application/json" }, body: { query, variables: { address: wallet } } }; const res = (0, index_esm/* useFetch */.st)(url, options); if (res?.data?.lrtPointRecipients?.length === 0) { return { points: "0", eigenLayerPoints: "0" } } const points = parseFloat(res?.data?.lrtPointRecipients[0]?.points) / 10 ** 18; const eigenLayerPoints = parseFloat(res?.data?.lrtPointRecipients[0]?.elPoints) / 10 ** 18; return { points: points.toString(), eigenLayerPoints: eigenLayerPoints.toString() }
        }; const useInceptionPoints = () => { let eigenLayerPoints = "0"; const wallet = useWallet_useWallet(); const url = `https://api.missionshub.xyz/v1/users/user-pts/5472336f-fc0e-477f-9e60-670195792264/${wallet}`; const resultTotems = (0, index_esm/* useFetch */.st)(url); const points = resultTotems?.data?.toFixed(2); try { const urlEigenLayer = `https://api.genesislrt.com/v1/balance?stakerAddress=${wallet}&symbol=ineth`; const resultEigenLayer = (0, index_esm/* useFetch */.st)(urlEigenLayer); eigenLayerPoints = resultEigenLayer?.ElPoints?.toFixed(2) } catch (error) { console.warn("Not available EigenLayer points corresponding to inETH  for ", wallet) } return { points, eigenLayerPoints } }; const useSwBtcPoints = () => { const wallet = useWallet_useWallet(); const userAddress = wallet; const url = `https://v3-lst.svc.swellnetwork.io/swell.v3.WalletService/BtcLrtUser?connect=v1&encoding=json&message=%7B%22walletAddress%22%3A%22${userAddress}%22%7D`; const res = (0, index_esm/* useFetch */.st)(url); const blackPearlsPoints = res.blackPearls ?? 0; return { points: blackPearlsPoints.toString() } }; const useTotalEigenLayerPointsAndOtherPoints = () => { let totalPoints = 0; let totalEigenLayerPoints = 0; const hooks = [useKelpPoints, useReducedRenzoPoints, useBedrockPoints, usePufferPoints, useReducedEtherFiPoints, usePrimestakedPoints, useInceptionPoints]; for (const useHook of hooks) { try { const { eigenLayerPoints, points } = useHook(); const isValidOtherPoints = !isNaN(parseFloat(points)); const isValidEigenLayer = !isNaN(parseFloat(eigenLayerPoints)); totalPoints += isValidOtherPoints ? parseFloat(points) : 0; totalEigenLayerPoints += isValidEigenLayer ? parseFloat(eigenLayerPoints) : 0 } catch (e) { if (e instanceof Promise) throw e; console.error(e) } } const { mellowPoints, symbioticPoints } = useRenzoPoints().totals; totalPoints += parseFloat(mellowPoints) + parseFloat(symbioticPoints); return { totalEigenLayerPoints, totalOtherPoints: totalPoints } }; const useTotalEigenLayerPoints = () => { const { totalEigenLayerPoints } = useTotalEigenLayerPointsAndOtherPoints(); return { points: totalEigenLayerPoints.toString() } }; const useOtherEigenLayerPoints = () => { const { totalOtherPoints } = useTotalEigenLayerPointsAndOtherPoints(); return { points: totalOtherPoints.toString() } }; const useTotalEtherFiPoints = () => { const { total } = useEtherFiPoints(); return { points: total.totalEtherFiPoints } }; const useMellowPoints = () => { const { totals } = useRenzoPoints(); return { points: totals.mellowPoints } }; const useTotalRenzoPoints = () => { const { totals } = useRenzoPoints(); return { points: totals.renzoPoints } }; const useSymbioticPoints = () => { const { totals } = useRenzoPoints(); return { points: totals.symbioticPoints } };
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/LRT/useLrtPoints.ts
        function useLrtEtherPoints() { const result = useEtherFiPoints(); const { networkName } = (0, dist/* useParams */.g)(); let etherFiPoints = result?.eethPoints.loyaltyPoints; if (networkName === "arbitrum") { etherFiPoints = result?.weethArbPoints.loyaltyPoints } else if (networkName === "binance") { etherFiPoints = result?.bscPoints.loyaltyPoints } return { points: etherFiPoints } } function useLrtRenzoLeftPoints() { const { tokenHold } = useRenzoPoints(); const renzoPoints = tokenHold.renzoPoints; return { points: renzoPoints } } function useLrtMellowPoints() { const { tokenHold } = useRenzoPoints(); const mellowPoints = tokenHold.mellowPoints; return { points: mellowPoints } } function useLrtSymbioticPoints() { const { tokenHold } = useRenzoPoints(); const symbioticPoints = tokenHold.symbioticPoints; return { points: symbioticPoints } }
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/EigenLayer/useLeftPointsEigenLayer.tsx
        function useLeftEigenLayer() { const { tokenHold } = useRenzoPoints(); const eigenLayerPoints = tokenHold.eigenLayerPoints; return { points: eigenLayerPoints } } function useLeftEigenLayerEtherFiPoints() { const result = useEtherFiPoints(); const { networkName } = (0, dist/* useParams */.g)(); let eigenLayerPoints = result?.eethPoints.eigenlayerPoints; if (networkName === "arbitrum") { eigenLayerPoints = result?.weethArbPoints.eigenlayerPoints } else if (networkName === "binance") { eigenLayerPoints = result?.bscPoints.eigenlayerPoints } return { points: eigenLayerPoints } }
        ;// ./src/components/Points/index.ts
        const productsPointsWithoutAutoLayerAndEigenLayer = { renzo: useTotalRenzoPoints, kelp: useKelpPoints, puffer: usePufferPoints, swell: useSwellPoints, ether: useTotalEtherFiPoints, bedrock: useBedrockPoints, primestaked: usePrimestakedPoints, inception: useInceptionPoints, mellow: useMellowPoints, symbiotic: useSymbioticPoints, swbtc: useSwBtcPoints }; const productsPointsWithoutAutoLayer = { eigenLayer: useTotalEigenLayerPoints, ...productsPointsWithoutAutoLayerAndEigenLayer }; const productPoints = { autoLayer: useAutolayerPoints, eigenLayer: useTotalEigenLayerPoints, ...productsPointsWithoutAutoLayerAndEigenLayer }; const productPointsLrt = { renzo: useLrtRenzoLeftPoints, swbtc: useSwBtcPoints, kelp: useKelpPoints, puffer: usePufferPoints, swell: useSwellPoints, primestaked: usePrimestakedPoints, bedrock: useBedrockPoints, inception: useInceptionPoints, mellow: useLrtMellowPoints, symbiotic: useLrtSymbioticPoints, ether: useLrtEtherPoints }; const productsPointsEigenLayer = { eigenLayer: useLeftEigenLayer, kelp: useKelpPoints, puffer: usePufferPoints, bedrock: useBedrockPoints, primestaked: usePrimestakedPoints, inception: useInceptionPoints, ether: useLeftEigenLayerEtherFiPoints };
        ;// ./src/components/Points/Icons/PointsIcons.tsx
        const icons = { autoLayer: { alt: "Autolayer icon", title: "AutoLayer" }, eigenLayer: { alt: "EigenLayer icon", title: "EigenLayer" }, renzo: { alt: "Renzo icon", title: "Renzo" }, kelp: { alt: "Kelp DAO icon", title: "Kelp DAO" }, puffer: { alt: "Puffer Finance icon", title: "Puffer Finance" }, swell: { alt: "Swell Network icon", title: "Swell Network" }, ether: { alt: "Ether icon", title: "Ether" }, bedrock: { alt: "Bedrock icon", title: "Bedrock" }, primestaked: { alt: "Primestaked icon", title: "Primestaked" }, inception: { alt: "Inception icon", title: "Inception" }, mellow: { alt: "Mellow icon", title: "Mellow" }, symbiotic: { alt: "Symbiotic icon", title: "Symbiotic" }, swbtc: { alt: "Swell Btc icon", title: "Swell Btc" } }; function PointsIcon({ type }) { const { alt, title } = icons[type]; const src = WhiteIcons[type]; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: `points-symbol ${type}-symbol`, children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", title: title, src: src, alt: alt }) }) }
        ;// ./src/components/Points/PointsBox/PointsBox.tsx
        const PointsBox = ({ points, type }) => { const finalValue = useCompactNumbers(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `${type}-points-box points-box`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `dashboard.${type}` }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `${type}-amount row`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("strong", { className: "staking-rewards", children: [" ", finalValue(+points, 2)] }),/*#__PURE__*/(0, jsx_runtime.jsx)(PointsIcon, { type: type })] })] }) };/* harmony default export */ const PointsBox_PointsBox = (PointsBox);
        ;// ./src/components/Points/PointsBox/DefaultPointsBox.tsx
        const DefaultPointsBox_DefaultPointsBox = ({ type = "default" }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `${type}-points-box points-box`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children: type === "error" ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-warning" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [" ",/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error" })] })] }) :/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "loading" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "autolayer-amount row", children: type === "error" ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error-loading-your-values" }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}) })] }) };/* harmony default export */ const PointsBox_DefaultPointsBox = (DefaultPointsBox_DefaultPointsBox);
        ;// ./src/components/Points/PointsPortfolio/PointsPortfolio.tsx
        function PointsPortfolio({ type, useFetchPoints }) { const { points } = useFetchPoints(); return /*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_PointsBox, { points: +points, type: type }) } function PointsPortfolioWrapper({ type, useFetchPoints }) { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: type }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsPortfolio, { type: type, useFetchPoints: useFetchPoints }) }) }) }
        ;// ./src/components/modals/PortfolioModal/PortfolioModal.tsx
        const PortfolioModal = ({ darkMode = false }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `portfolio-modal modal-content ${darkMode ? "dark-theme" : "light-theme"}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(PortfolioHeader_PortfolioHeader, {}),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "points-container-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "points-container", children: Object.entries(productPoints).map(([type, fetchPoints]) =>/*#__PURE__*/(0, jsx_runtime.jsx)(PointsPortfolioWrapper, { type: type, useFetchPoints: fetchPoints }, type)) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "portfolio-content", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "portfolio-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "assets" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "error", children: "Error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AssetBodyTable_AssetBodyTable, {}) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "portfolio-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "strategies" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "error", children: "Error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(DefiBodyTable_DefiBodyTable, {}) }) })] })] })] }) }; (0, modal_es/* registerModal */.Ju)("portfolio-modal", PortfolioModal);
        ;// ./src/components/Portfolio/Portfolio.tsx
        const Portfolio = () => { const modal = (0, modal_es/* useModal */.hS)(); return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "portfolio", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: () => modal.show("portfolio-modal"), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "more-info" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-plus" })] }) }) };/* harmony default export */ const Portfolio_Portfolio = (Portfolio);
        ;// ./src/components/Points/PointsDashboard/PointsDashboardError/PointsDashboardError.tsx
        function PointsDashboardError() { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "points-item-dashboard points-item-error", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "inside-container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-warning" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error" }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error-loading-your-values" }), ".", " "] }) })] }) }
        ;// ./src/components/Points/PointsDashboard/PointsDashboardFallback/PointsDashboardFallback.tsx
        function PointsDashboardLoading({ type }) { const isResponsive = hooks_useIsResponsive(); return /*#__PURE__*/(0, jsx_runtime.jsx)("article", { className: `points-item-dashboard points-item-${type || "loading"}`, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "inside-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "loading" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { mini: isResponsive })] }) }) }
        ;// ./src/components/Points/PointsDashboard/YourDepositPoints/YourDepositPoints.tsx
        const YourDepositPoints = () => { const totalArbitrumUsd = hooks_useDepositUsdPoints(); const { tokensUsdValue } = hooks_useTokensLRTValueUsd(Networks.ethereum); const { tokensUsdValue: bnbUsd } = hooks_useTokensLRTValueUsd(Networks.binance); const { tokensUsdValue: opUsd } = hooks_useTokensLRTValueUsd(Networks.optimism); const { tokensUsdValue: baseUsd } = hooks_useTokensLRTValueUsd(Networks.base); const total = tokensUsdValue + totalArbitrumUsd + bnbUsd + opUsd + baseUsd; return /*#__PURE__*/(0, jsx_runtime.jsx)(TopPointsDashboard, { amount: total, type: "your-deposit", children:/*#__PURE__*/(0, jsx_runtime.jsx)(Portfolio_Portfolio, {}) }) }; const YourDepositPointsWrapper = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardError, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardLoading, { type: "your-deposit" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(YourDepositPoints, {}) }) }) };/* harmony default export */ const YourDepositPoints_YourDepositPoints = (YourDepositPointsWrapper);
        ;// ./src/components/Points/Icons/PointsIconList/PointsIconList.tsx
        const PointsIconList = ({ list }) => { const slicedList = list?.slice(0, 5) || []; const length = list?.length; if (!length) return /*#__PURE__*/(0, jsx_runtime.jsx)("div", {}); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "points-icon-list", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "points-list", children: slicedList?.map((type, i) =>/*#__PURE__*/(0, jsx_runtime.jsx)(PointsIcon, { type: type }, i)) }), length > 5 &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "rest-points", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: `+${length - 5}` }) })] }) };/* harmony default export */ const PointsIconList_PointsIconList = (PointsIconList);
        ;// ./src/components/Points/PointsDashboard/OtherPoints.tsx
        const OtherPoints = () => { const { points } = useOtherEigenLayerPoints(); return /*#__PURE__*/(0, jsx_runtime.jsx)(TopPointsDashboard, { amount: +points, type: "other-points", children:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsIconList_PointsIconList, { list: ["renzo", "kelp", "puffer", "swell", "ether", "bedrock", "primestaked", "inception", "mellow", "symbiotic", "swbtc"] }) }) }; const OtherPointsWrapper = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardError, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardLoading, { type: "other-points" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(OtherPoints, {}) }) }) };/* harmony default export */ const PointsDashboard_OtherPoints = (OtherPointsWrapper);
        ;// ./src/components/Points/PointsDashboard/PointsDashboardWrapper.tsx
        function PointsDashboardWrapper({ children, type }) { return /*#__PURE__*/(0, jsx_runtime.jsx)("article", { className: `points-item-dashboard points-item-${type}`, children: children }) }
        ;// ./src/components/Points/PointsDashboard/ReducedPointsDashboard.tsx
        function ReducedPointsDashboard(props) { return /*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardWrapper, { type: props.type, children:/*#__PURE__*/(0, jsx_runtime.jsx)(CommonPoints, { ...props, inlineLogo: true }) }) }
        ;// ./src/components/Points/PointsDashboard/PointsDashboard.tsx
        function PointsDashboard({ useFetchPoints, type, top }) { const { points } = useFetchPoints(); return top ?/*#__PURE__*/(0, jsx_runtime.jsx)(TopPointsDashboard, { withInfo: true, amount: +points, type: type, children:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsIcon, { type: type }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(ReducedPointsDashboard, { withInfo: true, amount: +points, type: type, children:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsIcon, { type: type }) }) } function PointsDashboard_PointsDashboardWrapper({ type, useFetchPoints, top }) { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardError, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboardLoading, { type: type }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboard, { type: type, useFetchPoints: useFetchPoints, top: top }) }) }) }
        ;// ./src/components/Points/PointsDashboard/SoonPoints/SoonPoints.tsx
        function SoonPoints() { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "points-item-more points-item-dashboard", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "inside-container", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "more-coming-soon" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("footer", {})] }) }
        ;// ./src/routes/Dashboard/DashboardPointsGrid/DashboardPointsGrid.tsx
        const DashboardPointsGrid = () => { const [openGrid, setOpenGrid] = (0, react.useState)(false); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "dashboard-points-grid", className: openGrid ? "open-grid" : "", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "points-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(YourDepositPoints_YourDepositPoints, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboard_PointsDashboardWrapper, { type: "autoLayer", useFetchPoints: useAutolayerPoints, top: true }),/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboard_PointsDashboardWrapper, { type: "eigenLayer", useFetchPoints: useTotalEigenLayerPoints, top: true }),/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboard_OtherPoints, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "sub", children: [Object.entries(productsPointsWithoutAutoLayerAndEigenLayer).map(([points, fetch]) =>/*#__PURE__*/(0, jsx_runtime.jsx)(PointsDashboard_PointsDashboardWrapper, { type: points, useFetchPoints: fetch }, points)),/*#__PURE__*/(0, jsx_runtime.jsx)(SoonPoints, {})] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: () => setOpenGrid(!openGrid), children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `icon icon-angle_${!openGrid ? "down" : "up"}` }) })] }) };/* harmony default export */ const DashboardPointsGrid_DashboardPointsGrid = (DashboardPointsGrid);
        ;// ./src/static/images/iconsSmall/oneClickRST-black.svg
        const oneClickRST_black_namespaceObject = __webpack_require__.p + "static/oneClickRST-black.855ecf452e798e938ae8.svg";
        ;// ./src/static/images/iconsSmall/oneClickRST-white.svg
        const oneClickRST_white_namespaceObject = __webpack_require__.p + "static/oneClickRST-white.bb274d617b905bb07be7.svg";
        ;// ./src/static/images/iconsSmall/strategiesRST-black.svg
        const strategiesRST_black_namespaceObject = __webpack_require__.p + "static/strategiesRST-black.41ed7130b4081323c6c6.svg";
        ;// ./src/static/images/iconsSmall/strategiesRST-white.svg
        const strategiesRST_white_namespaceObject = __webpack_require__.p + "static/strategiesRST-white.ad6e3f1ff5f4d299b5f2.svg";
        ;// ./src/static/images/iconsSmall/wallet-white.svg
        const wallet_white_namespaceObject = __webpack_require__.p + "static/wallet-white.0a499d64d3991ac0cb4d.svg";
        ;// ./src/static/images/iconsSmall/wallet-black.svg
        const wallet_black_namespaceObject = __webpack_require__.p + "static/wallet-black.a46c3eae959d2005257c.svg";
        ;// ./src/static/images/iconsSmall/whiteCheckIcon.svg
        const whiteCheckIcon_namespaceObject = __webpack_require__.p + "static/whiteCheckIcon.1c517c9a8668030d1156.svg";
        ;// ./src/static/images/iconsSmall/whiteCrossIcon.svg
        const whiteCrossIcon_namespaceObject = __webpack_require__.p + "static/whiteCrossIcon.c0e73ceda1220bd379d3.svg";
        ;// ./src/static/images/iconsSmall/link-icon-grey.svg
        const link_icon_grey_namespaceObject = __webpack_require__.p + "static/link-icon-grey.5172bcadc349e5391a1f.svg";
        ;// ./src/static/images/iconsSmall/share.svg
        const share_namespaceObject = __webpack_require__.p + "static/share.8db8014979fea4255b29.svg";
        ;// ./src/static/images/iconsSmall/gift.svg
        const gift_namespaceObject = __webpack_require__.p + "static/gift.ad820709ce2fa1264d56.svg";
        ;// ./src/static/images/iconsSmall/index.ts
        const SmallIcons = { oneClickRstBlack: oneClickRST_black_namespaceObject, oneClickRsWhite: oneClickRST_white_namespaceObject, strategiesRSTBlack: strategiesRST_black_namespaceObject, strategiesRSTWhite: strategiesRST_white_namespaceObject, walletWhite: wallet_white_namespaceObject, walletBlack: wallet_black_namespaceObject, whiteCheckIcon: whiteCheckIcon_namespaceObject, whiteCrossIcon: whiteCrossIcon_namespaceObject, linkGrey: link_icon_grey_namespaceObject, share: share_namespaceObject, gift: gift_namespaceObject };
        ;// ./src/components/Welcome/Welcome.tsx
        const Welcome = () => { const navigate = (0, dist/* useNavigate */.Zp)(); const clickButton = () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.connect()).then(() => navigate("/lrt")) }; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "welcome-connect", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "landing.hero-banner.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "landing.hero-banner.text" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: clickButton, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: SmallIcons.walletWhite, alt: "wallet" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "connect-wallet" }) })] })] }) }) };/* harmony default export */ const Welcome_Welcome = (Welcome);
        ;// ./src/data/community.json
        const community_namespaceObject = /*#__PURE__*/JSON.parse('[{"name":"telegram","href":"https://t.me/+DlInSb5slQUwOWI0"},{"name":"discord","href":" http://discord.gg/autolayer-899973803239686174"}]');
        ;// ./src/data/social.json
        const social_namespaceObject = /*#__PURE__*/JSON.parse('[{"name":"x","href":"https://twitter.com/AutoLayer"}]');
        ;// ./src/components/SocialLinks/SocialLinks.tsx
        var LinkType; (function (LinkType) { LinkType["All"] = "all"; LinkType["Community"] = "community"; LinkType["Social"] = "social" })(LinkType || (LinkType = {})); const SocialLinks = ({ type = "all" }) => { const linkMappings = { ["all"]: [...community_namespaceObject, ...social_namespaceObject], ["community"]: community_namespaceObject, ["social"]: social_namespaceObject }; const links = linkMappings[type] || []; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "social-links", children: links.map(c =>/*#__PURE__*/(0, jsx_runtime.jsx)("a", { target: "_blank", rel: "noreferrer noopener", className: `icon icon-${c.name}`, href: c.href, title: `${c.name} link` }, c.name)) }) };/* harmony default export */ const SocialLinks_SocialLinks = (SocialLinks);
        ;// ./src/components/Footer/Footer.tsx
        const Footer = ({ darkMode = false }) => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); return /*#__PURE__*/(0, jsx_runtime.jsx)("footer", { id: "colophon", className: `${wallet ? "with-wallet" : ""} ${darkMode ? "dark-theme" : "light-theme"}`, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "general-links", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "https://legacy.autolayer.io/fast-mode/products", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "footer.legacy", defaultMessage: "Legacy Access (Tortle Ninja)" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "https://docs.autolayer.io/autolayer/latest-app-infos/privacy-policy/terms-of-use", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "footer.legal.terms", defaultMessage: "Terms of Use" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "https://docs.autolayer.io/autolayer/latest-app-infos/privacy-policy", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "footer.legal.privacy" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "https://docs.autolayer.io/", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "footer.info.docs" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "https://docs.autolayer.io/autolayer/welcome/faqs-and-troubleshooting", children: "FAQs" }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "link", target: "_blank", href: "http://discord.gg/autolayer-899973803239686174", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "footer.help.feed-back", defaultMessage: "Send Feedback" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "social-links-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)(SocialLinks_SocialLinks, {}) })] }) }) };/* harmony default export */ const Footer_Footer = (Footer);
        ;// ./src/components/CustomSelect/CustomSelect.tsx
        var KeyboardNavigation; (function (KeyboardNavigation) { KeyboardNavigation["ENTER"] = "Enter"; KeyboardNavigation["ARROWUP"] = "ArrowUp"; KeyboardNavigation["ARROWDOWN"] = "ArrowDown"; KeyboardNavigation["ESCAPE"] = "Escape" })(KeyboardNavigation || (KeyboardNavigation = {})); const CustomSelect = ({ onChange: { add, remove }, value, options, OptionComponent, LabelComponent }) => { const [ddIndex, setDdIndex] = (0, react.useState)(-1); const [searchValue, setSearchValue] = (0, react.useState)(""); const ulRef = (0, react.useRef)(null); const selectRef = (0, react.useRef)(null); const isMultiSelect = Array.isArray(value); (0, react.useEffect)(() => { !isMultiSelect && setDdIndex(options.findIndex(option => option.value === value)) }, [value, options, isMultiSelect]); (0, react.useEffect)(() => { const timeout = setTimeout(() => setSearchValue(""), 1e3); return () => clearTimeout(timeout) }, [searchValue]); const actualOption = options.find(option => option.value === value); const blurActiveElement = () => { selectRef.current?.parentElement?.focus() }; const handleChange = item => { if (isMultiSelect) { value.includes(item) ? remove && remove(item) : add(item) } else { add(item); blurActiveElement() } }; const handleKeyPress = event => { event.preventDefault(); const { code, key } = event; if (!Object.values(KeyboardNavigation).includes(code) && (code.startsWith("Key") || code.startsWith("Digit"))) { setSearchValue(prevValue => { const newValue = prevValue + key; const elementIndex = options.findIndex((option, index) => index > 0 && newValue.localeCompare(option.value) === -1); if (elementIndex >= 0) { const element = ulRef.current.children[elementIndex]; element.focus(); setDdIndex(elementIndex) } return newValue }); return } if (code === "Enter") { handleChange(options[ddIndex].value); return } if (code === "Escape") { blurActiveElement(); return } const offset = code === "ArrowDown" ? ddIndex + 1 : ddIndex - 1; if (offset >= options.length || offset < 0) return; const element = ulRef.current.children[offset]; element.focus(); setDdIndex(offset) }; const handleBlur = event => { if (isMultiSelect) { setDdIndex(-1) } else if (ddIndex >= 0 && !event.currentTarget.contains(event.relatedTarget)) { handleChange(options[ddIndex].value) } }; const handleOptionClick = () => !isMultiSelect && blurActiveElement(); const handleHeaderBlur = event => { if (selectRef.current.contains(document.activeElement)) { event.preventDefault(); blurActiveElement() } }; const handleOptionMouseDown = index => { setDdIndex(index); if (isMultiSelect) { handleChange(options[index].value) } }; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { tabIndex: 0, className: "custom-select-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "custom-select", "data-testid": "custom-select", tabIndex: 0, ref: selectRef, onBlur: handleBlur, onKeyDown: handleKeyPress, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "custom-select-header", onMouseDown: handleHeaderBlur, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "custom-select-info", children: LabelComponent || actualOption &&/*#__PURE__*/(0, jsx_runtime.jsx)(OptionComponent, { option: actualOption }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_down" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { ref: ulRef, className: "custom-select-list", children: options.map((option, index) =>/*#__PURE__*/(0, jsx_runtime.jsx)("li", { tabIndex: 0, className: "custom-select-row", onClick: handleOptionClick, onMouseDown: event => { event.stopPropagation(); event.preventDefault(); handleOptionMouseDown(index) }, children:/*#__PURE__*/(0, jsx_runtime.jsx)(OptionComponent, { option: option, checked: isMultiSelect && value.includes(option.value) }) }, index)) })] }) }) };/* harmony default export */ const CustomSelect_CustomSelect = (CustomSelect);
        ;// ./src/components/common/Network/networkChoice.json
        const networkChoice_namespaceObject = /*#__PURE__*/JSON.parse('{"arbitrum":{"label":"Arbitrum","id":"0xa4b1"},"ethereum":{"label":"Ethereum","id":"0x1"},"binance":{"label":"BNB Chain","id":"0x38"},"base":{"label":"Base","id":"0x2015"},"scroll":{"label":"Scroll","id":"0x82750"},"optimism":{"label":"Optimism","id":"0xa"},"linea":{"label":"Linea","id":"0xe708"},"mode":{"label":"Mode","id":"0x868b"}}');
        ;// ./src/components/common/Network/SelectNewtork/SelectNetwork.tsx
        const networks = Object.entries(networkChoice_namespaceObject).map(([value, { label }]) => ({ value, label })); const filteredNetwork = networks.filter(({ value }) => value !== "linea" && value !== "mode" && value !== "scroll"); const options = [{ value: "all networks", label: "All Networks" }, ...filteredNetwork]; const Option = ({ option }) =>/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "selected-network", children: [option.value === "all networks" ? null :/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: networkLogos[option.value], alt: `${option.label} icon`, loading: "lazy" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: option.label })] }); function SelectNetwork({ handleNetworkChange, selectedNetwork }) { return /*#__PURE__*/(0, jsx_runtime.jsx)(CustomSelect_CustomSelect, { OptionComponent: Option, onChange: { add: handleNetworkChange }, options: options, value: selectedNetwork }) }
        ;// ./src/static/vectors/menu.svg
        const menu_namespaceObject = __webpack_require__.p + "static/menu.a9d3446d662b95720bae.svg";
        ;// ./src/components/NonModalLayout/NonModalLayout.tsx
        function NonModalLayout({ children, image: { alt, src } }) { const handleMouseDown = event => { if (event.currentTarget !== document.activeElement) { return } const t = event.currentTarget; setTimeout(() => t.blur(), 0) }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "non-modal-layout", tabIndex: 0, onMouseDown: handleMouseDown, role: "dialog", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: src, alt: alt, role: "button" }), children,/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "veil" })] }) }
        ;// ./src/routes/Referrals/ReferralsButtons/ReferralsButtons.tsx
        var ReferralsEnum; (function (ReferralsEnum) { ReferralsEnum["TRADERS"] = "traders"; ReferralsEnum["AFFILIATES"] = "affiliates" })(ReferralsEnum || (ReferralsEnum = {})); const ReferralsButtons = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "refferrals-tab-buttons", children: Object.values(ReferralsEnum).map(r =>/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* NavLink */.k2, { className: ({ isActive }) => isActive ? `button button-${r} choosen` : `button button-${r}`, to: `/referrals/${r}`, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `refferrals-tab-buttons-${r}` }) }, r)) }) };/* harmony default export */ const ReferralsButtons_ReferralsButtons = (ReferralsButtons);
        ;// ./src/components/GoToReferrals/GoToReferrals.tsx
        const GoToReferrals = () => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const navigate = (0, dist/* useNavigate */.Zp)(); const clickButton = async () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.connect()).then(() => navigate(`/referrals/${ReferralsEnum.AFFILIATES}`)) }; const content =/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals" }) }); if (!wallet) { return /*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: clickButton, id: "go-to-referrals", className: "button", children: content }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* Link */.N_, { to: `/referrals/${ReferralsEnum.AFFILIATES}`, id: "go-to-referrals", className: "button", children: content }) };/* harmony default export */ const GoToReferrals_GoToReferrals = (GoToReferrals);
        ;// ./src/components/GoToAirdrops/GoToAirdrops.tsx
        const GoToAirdrops = () => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const navigate = (0, dist/* useNavigate */.Zp)(); const clickButton = async () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.connect()).then(() => navigate("/airdrop")) }; const content =/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: SmallIcons.gift, alt: "present" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "airdrop-header.title" }) })] }); if (!wallet) { return /*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: clickButton, id: "go-to-airdrops", className: "button", children: content }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* Link */.N_, { to: "/airdrop", id: "go-to-airdrops", className: "button", children: content }) };/* harmony default export */ const GoToAirdrops_GoToAirdrops = (GoToAirdrops);
        ;// ./src/static/vectors/fire-without-bg.svg
        const fire_without_bg_namespaceObject = __webpack_require__.p + "static/fire-without-bg.8dad1b77cd728505ce9d.svg";
        ;// ./src/components/StakeBanner/NavigateStake/NavigateStake.tsx
        function NavigateStake() { const navigate = (0, dist/* useNavigate */.Zp)(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("button", { role: "link", title: "Navigate to Stake", className: "navigate-to-stake", onClick: () => navigate(`/stake`), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: fire_without_bg_namespaceObject, alt: "fire icon" }), "Stake my $LAY3R"] }) }
        ;// ./src/components/NavigationMenu/NavigationMenu.tsx
        const NavigationMenu = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children:/*#__PURE__*/(0, jsx_runtime.jsx)(NonModalLayout, { image: { src: menu_namespaceObject, alt: "menu icon" }, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "navigation-menu-bubble", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(NavigateStake, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(GoToReferrals_GoToReferrals, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(GoToAirdrops_GoToAirdrops, {})] }) }) }) };/* harmony default export */ const NavigationMenu_NavigationMenu = (NavigationMenu);
        // EXTERNAL MODULE: ./node_modules/@gluedigital/markdown-message/es/index.js
        var markdown_message_es = __webpack_require__(67877);
        // EXTERNAL MODULE: ./src/utils/web3.ts
        var web3 = __webpack_require__(22648);
        ;// ./src/utils/walletHelpers.tsx
        const getNetworkParams = networkId => { let networkParams; switch (networkId) { case Networks.arbitrum: networkParams = constants/* ARBITRUM */.x1; break; case Networks.ethereum: networkParams = constants/* ETHEREUM */.yK; break; case Networks.binance: networkParams = constants/* BINANCE */.dO; break; case Networks.base: networkParams = constants/* BASE */.Wm; break; case Networks.scroll: networkParams = constants/* SCROLL */.u; break; case Networks.linea: networkParams = constants/* LINEA */.OD; break; case Networks.optimism: networkParams = constants/* OPTIMISM */.zC; break; case Networks.mode: networkParams = constants/* MODE */.g; break; default: if (constants/* ENV_ENVIROMENT */.Ab === Environments.mainnetPro) { networkParams = constants/* mainnetArbitrumPro */.iY } else { networkParams = constants/* mainnetArbitrumCandidate */.os } break }return networkParams }; const changeChain = async (networkId = "0xa4b1") => { const networkParams = getNetworkParams(networkId); const chainParams = { chainId: networkParams?.chainId, chainName: networkParams?.chainName, rpcUrls: networkParams?.rpcUrls, blockExplorerUrls: networkParams?.blockExplorerUrls, nativeCurrency: networkParams?.nativeCurrency }; return web3/* default */.A.currentProvider.request({ method: "wallet_addEthereumChain", params: [chainParams] }) };
        ;// ./src/hooks/useCopy.ts
        const useCopy = () => { const [showCopied, setShowCopied] = (0, react.useState)(false); const copyClipBoard = (e, text) => { e.stopPropagation(); navigator?.clipboard?.writeText(text).then(() => setShowCopied(true)).catch(err => console.error(err.message)); setTimeout(() => setShowCopied(false), 1500) }; return { copyClipBoard, showCopied } };
        ;// ./src/static/images/settings-menu/copy.svg
        const copy_namespaceObject = __webpack_require__.p + "static/copy.d1aa5e434ee06f348c4f.svg";
        ;// ./src/static/images/settings-menu/arbiscan.svg
        const arbiscan_namespaceObject = __webpack_require__.p + "static/arbiscan.c14d4a300a4a271e7203.svg";
        ;// ./src/components/ConnectWallet/AccountDataWallet/AccountDataWallet.tsx
        const AccountDataWallet = ({ wallet }) => { const { showCopied, copyClipBoard } = useCopy(); const networkId = (0, es/* useSelector */.d4)(s => s.network); const { address } = wallet; const networkParams = getNetworkParams(networkId); const { scanName } = getItemByNetwork(networkId); const handleDisconnect = () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.disconnect()) }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "account-actions", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "account-number", onClick: e => copyClipBoard(e, address), children: showCopied ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "copied-bubble.text" }) }) :/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "account-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: copy_namespaceObject, alt: "copy symbol" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: address.slice(0, 6) + "..." + address.slice(-4) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: `${networkParams.blockExplorerUrls}/address/${address}`, target: "_blank", rel: "noopener noreferrer", className: "button", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: arbiscan_namespaceObject, alt: "moon icon" }),/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "account-data.view", values: { scan: scanName } })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { id: "disconnect", onClick: handleDisconnect, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "disconnect" }) })] }) };/* harmony default export */ const AccountDataWallet_AccountDataWallet = (AccountDataWallet);
        ;// ./src/components/ConnectWallet/ConnectButton/ConnectButton.tsx
        function ConnectButton({ darkMode = false, text = "default-text" }) { const clickButton = async () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.connect()) }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("button", { className: `connect-wallet ${darkMode ? "dark-theme" : "light-theme"}`, onClick: clickButton, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: darkMode ? SmallIcons.walletWhite : SmallIcons.walletBlack, alt: "wallet" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `connect-wallet.${text}` }) })] }) }
        ;// ./src/components/ConnectWallet/ConnectWallet.tsx
        const ConnectWallet = ({ text = "default-text", darkMode = false }) => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); return !wallet ?/*#__PURE__*/(0, jsx_runtime.jsx)(ConnectButton, { darkMode: darkMode, text: text }) :/*#__PURE__*/(0, jsx_runtime.jsx)(AccountDataWallet_AccountDataWallet, { wallet: wallet }) };/* harmony default export */ const ConnectWallet_ConnectWallet = (ConnectWallet);
        // EXTERNAL MODULE: ./node_modules/universal-scripts/index.js
        var universal_scripts = __webpack_require__(27942);
        ;// ./src/locales/choices.json
        const choices_namespaceObject = /*#__PURE__*/JSON.parse('{"en":"English","es":"Español","zh":"中文","vi":"Tiếng Việt","ko":"한국어","uk":"українська","fr":"Français","in":"Bahasa Indonesia","jp":"日本語","th":"แบบไทย","tk":"Türkçe","ind":"हिंदी","ru":"Русский"}');
        ;// ./src/components/common/LanguageSelectorDialog/languageImages.json
        const languageImages_namespaceObject = /*#__PURE__*/JSON.parse('{"en":"/images/language/en.png","zh":"/images/language/zh.png","es":"/images/language/es.png","ko":"/images/language/ko.png","vi":"/images/language/vi.png","uk":"/images/language/uk.png","fr":"/images/language/fr.png","in":"/images/language/in.png","jp":"/images/language/jp.png","th":"/images/language/th.png","tk":"/images/language/tk.png","ind":"/images/language/ind.png","ru":"/images/language/ru.png"}');
        ;// ./src/components/common/LanguageSelectorDialog/LanguageSelectorDialog.tsx
        const LanguageSelectorDialog = ({ chooseLanguage, setChooseLanguage }) => { const dispatch = (0, es/* useDispatch */.wA)(); const languages = Object.keys(choices_namespaceObject); const currentLang = (0, es/* useSelector */.d4)(s => s.intl.locale); const handleLang = language => { dispatch((0, universal_scripts.setLang)(language)); document.cookie = "lang=" + language }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("dialog", { className: "language-selector-dialog", open: chooseLanguage, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "language-selector.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close", onClick: () => setChooseLanguage(false) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { className: "language-selector-list", children: languages.map(language =>/*#__PURE__*/(0, jsx_runtime.jsxs)("li", { className: `language-item ${currentLang === language ? "selected" : ""}`, onClick: () => handleLang(language), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: languageImages_namespaceObject[language], alt: `${language} flag` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "text", children: choices_namespaceObject[language] })] }, language)) })] }) };/* harmony default export */ const LanguageSelectorDialog_LanguageSelectorDialog = (LanguageSelectorDialog);
        ;// ./src/static/images/connectwallet/gears.svg
        const gears_namespaceObject = __webpack_require__.p + "static/gears.d1d6b7b13e7ab9c4c25d.svg";
        ;// ./src/static/images/settings-menu/language.svg
        const language_namespaceObject = __webpack_require__.p + "static/language.eb37bba5e7492ac21e99.svg";
        ;// ./src/hooks/useNetworkName.ts
        const useNetworkName = () => { const network = (0, es/* useSelector */.d4)(s => s.network); const networkName = Object.keys(Networks).find(key => Networks[key] === network); return networkName };
        ;// ./src/components/common/Network/NetworkSelectorDialog/NetworkSelectorDialog.tsx
        const NetworkSelectorDialog = ({ handleShow, showDialog }) => { const networkId = (0, es/* useSelector */.d4)(s => s.network); const networks = Object.entries(networkChoice_namespaceObject); const filteredNetworks = networks.filter(([key]) => key !== "linea" && key !== "mode" && key !== "scroll"); const selectedNetwork = useNetworkName(); const handleNetwork = async id => { try { await changeChain(id) } catch (err) { console.error(err) } }; (0, react.useEffect)(() => { setTimeout(() => handleShow(false), 300) }, [networkId]); return /*#__PURE__*/(0, jsx_runtime.jsxs)("dialog", { className: "network-selector-dialog", open: showDialog, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "network-selector.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close", onClick: () => handleShow(false) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { className: "language-selector-list", children: filteredNetworks.map(([key, { id, label }]) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("li", { className: `network-item ${selectedNetwork === key ? "selected" : ""}`, onClick: () => handleNetwork(id), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: selectedNetwork === key ? networkVectorsWhite[key] : networkVectors[key], alt: `${label} icon` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "text", children: label })] }, label) }) })] }) };/* harmony default export */ const NetworkSelectorDialog_NetworkSelectorDialog = (NetworkSelectorDialog);
        ;// ./src/components/SettingsMenu/SettingsMenu.tsx
        const SettingsMenu = () => { const [dialogElement, setDialogElement] = (0, react.useState)("none"); const selectedNetwork = useNetworkName(); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(NonModalLayout, { image: { src: gears_namespaceObject, alt: "gear icon" }, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "bubble", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { className: "language-selector", onClick: () => setDialogElement("language"), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: language_namespaceObject, alt: "language symbol" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "language-selector.text" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "network-section", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "network-selector.actual" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: networkVectors[selectedNetwork] ?? networkVectors[DEFAULT_NETWORK_NAME], alt: `${networkChoice_namespaceObject[selectedNetwork]?.label ?? DEFAULT_NETWORK_NAME} Logo` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: networkChoice_namespaceObject[selectedNetwork]?.label ?? DEFAULT_NETWORK_NAME })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "select-network", onClick: () => setDialogElement("network"), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "network-selector.title" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "connect-section", children:/*#__PURE__*/(0, jsx_runtime.jsx)(ConnectWallet_ConnectWallet, {}) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(LanguageSelectorDialog_LanguageSelectorDialog, { chooseLanguage: dialogElement === "language", setChooseLanguage: () => setDialogElement("none") }),/*#__PURE__*/(0, jsx_runtime.jsx)(NetworkSelectorDialog_NetworkSelectorDialog, { handleShow: () => setDialogElement("none"), showDialog: dialogElement === "network" })] }) };/* harmony default export */ const SettingsMenu_SettingsMenu = (SettingsMenu);
        ;// ./src/static/logos/autolayer/autolayerIconColors.png
        const autolayerIconColors_namespaceObject = __webpack_require__.p + "static/autolayerIconColors.3393d865faacd6ef036e.png";
        ;// ./src/static/logos/autolayer/autolayerIconBlue.png
        const autolayerIconBlue_namespaceObject = __webpack_require__.p + "static/autolayerIconBlue.2a9b0595aebdc99ec8de.png";
        ;// ./src/static/logos/autolayer/autolayerIconDark.svg
        const autolayerIconDark_namespaceObject = __webpack_require__.p + "static/autolayerIconDark.6f3b33f5f43c7e3d8cec.svg";
        ;// ./src/static/logos/autolayer/autolayerLogoDark.svg
        const autolayerLogoDark_namespaceObject = __webpack_require__.p + "static/autolayerLogoDark.b69d0ab2d0ddd6cc98b5.svg";
        ;// ./src/static/logos/autolayer/autolayerLogoWhite.svg
        const autolayerLogoWhite_namespaceObject = __webpack_require__.p + "static/autolayerLogoWhite.1aeab9459ae86043162a.svg";
        ;// ./src/static/logos/autolayer/autolayerIconColors.svg
        const logos_autolayer_autolayerIconColors_namespaceObject = __webpack_require__.p + "static/autolayerIconColors.7572cb1b08ff2aafb3bb.svg";
        // EXTERNAL MODULE: ./src/static/logos/autolayer/autolayerIconColor.svg
        var autolayerIconColor = __webpack_require__(77761);
        ;// ./src/static/logos/autolayer/autolayerLogoColor.svg
        const autolayerLogoColor_namespaceObject = __webpack_require__.p + "static/autolayerLogoColor.a1188fa047d753dc22af.svg";
        ;// ./src/static/logos/autolayer/token.png
        const token_namespaceObject = __webpack_require__.p + "static/token.50f34647e2d28f5c7c7d.png";
        ;// ./src/static/logos/autolayer/autolayerRoundedBlue.png
        const autolayerRoundedBlue_namespaceObject = __webpack_require__.p + "static/autolayerRoundedBlue.0f235fb51d7ca9f44ea5.png";
        ;// ./src/static/logos/autolayer/index.ts
        const AutolayerLogos = { logoColors: autolayerIconColors_namespaceObject, logoBlue: autolayerIconBlue_namespaceObject, autolayerPoints: logos_autolayer_autolayerIconColors_namespaceObject, autolayerLogoWhite: autolayerLogoWhite_namespaceObject, autolayerLogoDark: autolayerLogoDark_namespaceObject, autolayerIconWhite: autolayerIconWhite_namespaceObject, autolayerIconDark: autolayerIconDark_namespaceObject, autolayerIconColor: autolayerIconColor, autolayerLogoColor: autolayerLogoColor_namespaceObject, token: token_namespaceObject, autolayerRoundedBlue: autolayerRoundedBlue_namespaceObject };
        ;// ./src/routes/Dashboard/DashboardHeader/DashboardHeader.tsx
        function DashboardHeader() { const isResponsive = hooks_useIsResponsive(); return /*#__PURE__*/(0, jsx_runtime.jsx)("header", { id: "dashboard-masthead", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "logo-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "only-mobile", src: AutolayerLogos.autolayerIconDark, alt: "Autolayer logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "only-desktop", src: AutolayerLogos.autolayerLogoDark, alt: "Autolayer logo" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "connect-wrapper", children: isResponsive ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(SettingsMenu_SettingsMenu, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(NavigationMenu_NavigationMenu, {})] }) :/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(NavigateStake, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(GoToReferrals_GoToReferrals, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(GoToAirdrops_GoToAirdrops, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(SettingsMenu_SettingsMenu, {})] }) })] }) }) }
        ;// ./src/components/AuBnbBanner/AuBnbBanner.tsx
        function AuBnbBanner() { const location = (0, dist/* useLocation */.zy)(); const isInfoPage = location.pathname.includes("/info"); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "aubnb-banner", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children: "AuBNB" }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "aubnb.banner.text" }) }), !isInfoPage &&/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* Link */.N_, { className: "button", to: "/info/aubnb", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "more-info" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "sphere" })] }) }
        ;// ./src/routes/Dashboard/Dashboard.tsx
        const Dashboard = () => { const location = (0, dist/* useLocation */.zy)(); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const [selectedNetwork, setSelectedNetwork] = (0, react.useState)("all networks"); const isLrt = location.pathname.replace("/", "") === "lrt"; const handleNetworkChange = newValue => setSelectedNetwork(newValue); if (location.pathname === "/") { return /*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Navigate */.C5, { to: "/lrt" }) } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "dashboard", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(DashboardHeader, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "points-section", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(AuBnbBanner, {}), wallet ?/*#__PURE__*/(0, jsx_runtime.jsx)(DashboardPointsGrid_DashboardPointsGrid, {}) :/*#__PURE__*/(0, jsx_runtime.jsx)(Welcome_Welcome, {})] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "filters", style: { display: "flex", justifyContent: "space-between" }, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ButtonChooseRST, {}), isLrt ?/*#__PURE__*/(0, jsx_runtime.jsx)(SelectNetwork, { handleNetworkChange: handleNetworkChange, selectedNetwork: selectedNetwork }) : null] }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "strategy-section", children:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductGrid_ProductGrid, { selectedNetwork: selectedNetwork }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] }) };/* harmony default export */ const Dashboard_Dashboard = (Dashboard);
        ;// ./src/static/images/error/error_shadow.png
        const error_shadow_namespaceObject = __webpack_require__.p + "static/error_shadow.5e5639da4d06d8696a1d.png";
        ;// ./src/static/images/error/error_cube.png
        const error_cube_namespaceObject = __webpack_require__.p + "static/error_cube.3e1e78c8156bbaf84447.png";
        ;// ./src/routes/NotFound/NotFound.tsx
        const NotFound = () => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "not-found", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("header", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "logo", src: autolayerLogoWhite_namespaceObject, alt: "tortle logo" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "split", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "item left", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children: "404" }),/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { className: "mono-space", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error.404-text" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* Link */.N_, { to: "/", className: "button", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "back-to-dashboard" }) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "item right", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "cube-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "cube", src: error_cube_namespaceObject, alt: "cube layers" }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "shadow", src: error_shadow_namespaceObject, alt: "shadow cube layers" })] }) })] }) })] }) };/* harmony default export */ const NotFound_NotFound = (NotFound);
        // EXTERNAL MODULE: ./node_modules/react-helmet-async/lib/index.esm.js
        var lib_index_esm = __webpack_require__(85902);
        ;// ./src/components/Meta/Analytics.tsx
        const Analytics = () => {
          const scriptText = `
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-5QWCQ5YXGH');
  `; return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("script", { async: true, src: "https://www.googletagmanager.com/gtag/js?id=G-5QWCQ5YXGH" }),/*#__PURE__*/(0, jsx_runtime.jsx)("script", { children: scriptText })] })
        };/* harmony default export */ const Meta_Analytics = (Analytics);
        ;// ./src/components/Meta/Meta.tsx
        const Meta = () => { const intl = (0, useIntl/* default */.A)(); const title = intl.formatMessage({ id: "meta.title" }); const description = intl.formatMessage({ id: "meta.description" }); const keywords = intl.formatMessage({ id: "meta.keywords" }); const image = "https://i.imgur.com/iqgYKok.png"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "viewport", content: "width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "keywords", content: keywords }),/*#__PURE__*/(0, jsx_runtime.jsx)("title", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:type", content: "website" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: "https://app.autolayer.io/" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "shortcut icon", href: "/favicon.ico", type: "image/x-icon" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "preconnect", href: "https://fonts.gstatic.com", crossOrigin: "anonymous" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "icon", type: "image/png", sizes: "16x16", href: "/favicon-16x16.png" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "icon", type: "image/png", sizes: "32x32", href: "/favicon-32x32.png" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "icon", type: "image/png", sizes: "192x192", href: "/android-chrome-192x192.png" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "icon", type: "image/png", sizes: "512x512", href: "/android-chrome-512x512.png" }),/*#__PURE__*/(0, jsx_runtime.jsx)("link", { rel: "apple-touch-icon", sizes: "180x180", href: "/apple-touch-icon.png" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "msapplication-TileColor", content: "#4088FC" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "theme-color", content: "#FFFFFF" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Meta_Analytics, {})] }) };/* harmony default export */ const Meta_Meta = (Meta);
        ;// ./src/routes/ErrorPage/ErrorPage.tsx
        const ErrorPage = ({ error }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "error-page", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("header", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "logo", src: autolayerLogoWhite_namespaceObject, alt: "tortle logo" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "split", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "item left", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { className: "mono-space", children: false &&/*#__PURE__*/0 }),/*#__PURE__*/(0, jsx_runtime.jsx)(react_router_dom_dist/* Link */.N_, { to: "/", className: "button", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "back-to-dashboard" }) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "item right", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "cube-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "cube", src: error_cube_namespaceObject, alt: "cube layers" }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { className: "shadow", src: error_shadow_namespaceObject, alt: "shadow cube layers" })] }) })] }) })] }) };/* harmony default export */ const ErrorPage_ErrorPage = (ErrorPage);
        ;// ./src/routes/ProductInfo/ProductInfo.tsx
        const ProductInfo = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorPage_ErrorPage, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Outlet */.sv, {}) }) }) };/* harmony default export */ const ProductInfo_ProductInfo = (ProductInfo);
        ;// ./src/components/Meta/ProductMeta.tsx
        function ProductMeta({ description, image, title, url }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("title", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:type", content: "website" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: url }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image })] }) }
        ;// ./src/utils/text.ts
        const capitalize = str => { return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() }; function firstPhrase(text) { const firstPoint = text?.indexOf("."); if (!firstPoint) return text; return text?.substring(0, firstPoint + 1) } const textHelpers = { capitalize, firstPhrase };/* harmony default export */ const utils_text = (textHelpers);
        ;// ./src/components/ShareDialog/Options/ShareLstOptions/ShareLstOptions.tsx
        function ShareLstOptions({ productInfo }) { const { showCopied, copyClipBoard } = useCopy(); const { pathname } = (0, dist/* useLocation */.zy)(); const url = true ? window.location.href : 0; const text = `AutoLayer's 1-Click Liquid Staking: ${productInfo.name} (${productInfo.id})`; const urlTwitter = `https://twitter.com/intent/tweet?text=${text}&url=${url}`; const urlTelegram = `https://t.me/share/url?url=${url}&text=${text}`; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "product-share", tabIndex: -1, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("ul", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("li", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: urlTelegram, target: "_blank", rel: "noreferrer noopener", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-telegram" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "share-telegram" }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("li", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: urlTwitter, target: "_blank", rel: "noopener noreferrer", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-x" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "share-twitter" }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("li", { onClick: e => copyClipBoard(e, url), children: !showCopied ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-copypaste" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "share-link" }) })] }) :/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "share-link-success" }) }) })] }) }) }
        ;// ./src/routes/ProductInfo/Header/HeaderProductInfo.tsx
        const HeaderProductInfo = ({ productInfo }) => { const assetType = productInfo?.type.toLocaleLowerCase() === "lrt" || productInfo?.type.toLocaleLowerCase() === "lst"; const backUrl = assetType ? productInfo?.type : "defi-strategies"; const name = productInfo.name; return /*#__PURE__*/(0, jsx_runtime.jsx)("header", { id: "masthead-product-info", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)(react_router_dom_dist/* Link */.N_, { to: `/${backUrl?.toLowerCase()}`, className: "button", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_left" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "back-text", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "back-to-dashboard" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { title: name, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: name }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "right-buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(NonModalLayout, { image: { src: SmallIcons.share, alt: "share icon" }, children:/*#__PURE__*/(0, jsx_runtime.jsx)(ShareLstOptions, { productInfo: productInfo }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(SettingsMenu_SettingsMenu, {})] })] }) }) };/* harmony default export */ const Header_HeaderProductInfo = (HeaderProductInfo);
        ;// ./src/static/images/banner-info/cubes.png
        const cubes_namespaceObject = __webpack_require__.p + "static/cubes.87d9f06252e3d61de6b2.png";
        ;// ./src/static/images/banner-info/cubes-mobile.png
        const cubes_mobile_namespaceObject = __webpack_require__.p + "static/cubes-mobile.b38e81350e5f3c5972bd.png";
        ;// ./src/routes/ProductInfo/BannerInfo/BannerInfo.tsx
        const BannerInfo = () => { const { width } = hooks_useWindowDimensions(); const isMobile = width < 460; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "banner-info", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "split", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "left item", children:/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "banner-info.title" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "right item", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: isMobile ? cubes_mobile_namespaceObject : cubes_namespaceObject, alt: "" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "badge", children: "autolayer.io" })] }) };/* harmony default export */ const BannerInfo_BannerInfo = (BannerInfo);
        ;// ./src/utils/tokenNameToAddress.ts
        const tokenNameToAddress = (tokenSymbol, chainId) => { const networkInfo = data_networkData(chainId); const token = networkInfo.tokens.find(t => t.id?.toLowerCase() === tokenSymbol?.toLowerCase()); if (token) { return token?.address?.toLowerCase() } else return "" };/* harmony default export */ const utils_tokenNameToAddress = (tokenNameToAddress);
        // EXTERNAL MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js + 1 modules
        var bignumber = __webpack_require__(10686);
        ;// ./src/contracts/tokenDecimals/getTokenDecimals.ts
        const getTokenDecimals = (token, chainId) => { const tokenAddress = token.length === 42 ? token.toLowerCase() : utils_tokenNameToAddress(token, chainId).toLowerCase(); const networkInfo = data_networkData(chainId); const findToken = networkInfo.tokens?.find(t => t.address.toLowerCase() === tokenAddress.toLowerCase()); return findToken ? findToken.decimals : "18" };/* harmony default export */ const tokenDecimals_getTokenDecimals = (getTokenDecimals);
        ;// ./src/contracts/tokenDecimals/getEtherNumberAmount.ts
        const getEtherNumberAmount = async (tokenAddress, amount, chainId) => { if (!amount || !tokenAddress) return "0"; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); const decimals = tokenDecimals_getTokenDecimals(tokenAddress, chainId); const FINAL_DECIMALS = 10 ** 6; let convertedAmount; if (decimals !== "18") { const valueDifference = bignumber/* BigNumber */.gH.from(10).pow(decimals); convertedAmount = bignumber/* BigNumber */.gH.from(amount).mul(FINAL_DECIMALS).div(valueDifference); convertedAmount = Number(convertedAmount) / FINAL_DECIMALS; return parseFloat(convertedAmount).toFixed(8) } const bnAmount = bignumber/* BigNumber */.gH.from(amount); convertedAmount = web3.utils.fromWei(bnAmount.toString(), "ether"); return parseFloat(convertedAmount).toFixed(15) }; const numberScientificNotationToString = amount => { if (Math.abs(amount) < 1) { const e = parseInt(amount.toString().split("e-")[1]); if (e) { let correctAmount = String(amount * Math.pow(10, e - 1)); correctAmount = "0." + new Array(e).join("0") + correctAmount.toString().substring(2); return correctAmount } else { return String(amount) } } else { let e = parseInt(amount.toString().split("+")[1]); if (e > 20) { e -= 20; let correctAmount = String(amount / Math.pow(10, e)); correctAmount += new Array(e + 1).join("0"); return correctAmount } return String(amount) } }; const getWeiNumberAmountDependOnDecimals = async (tokenName, amount, chainId) => { const tokenAddress = tokenName.length === 42 ? tokenName.toLowerCase() : utils_tokenNameToAddress(tokenName, chainId); const decimals = tokenDecimals_getTokenDecimals(tokenAddress, chainId); let convertedAmount; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); if (decimals?.toString() !== "18") { const FINAL_DECIMALS = 10 ** Number(decimals); const valueDifference = bignumber/* BigNumber */.gH.from(10).pow(decimals); let bnAmount; if (!Number.isInteger(amount)) { const amountWithDecimals = (amount * FINAL_DECIMALS)?.toFixed(0); bnAmount = bignumber/* BigNumber */.gH.from(amountWithDecimals) } else { bnAmount = bignumber/* BigNumber */.gH.from(amount); bnAmount = bnAmount.mul(FINAL_DECIMALS) } convertedAmount = bignumber/* BigNumber */.gH.from(bnAmount.mul(valueDifference)); convertedAmount = bignumber/* BigNumber */.gH.from(convertedAmount.div(FINAL_DECIMALS)) } else { const stringAmount = numberScientificNotationToString(amount); convertedAmount = web3.utils.toWei(stringAmount, "ether") } return convertedAmount.toString() };
        ;// ./src/contracts/getBalance/getSingleTokenBalance.ts
        const getSingleTokenBalance = async (tokenSymbol, userAddress, chainId, isMaxButton = false) => { if (!userAddress) return null; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); const nativeCrypto = getNativeCurrencySymbol(chainId); if (tokenSymbol === nativeCrypto) { const balance = web3.utils.fromWei(await web3.eth.getBalance(userAddress), "ether"); return parseFloat(balance)?.toFixed(6) } const tokenAddress = tokenSymbol.length === 42 ? tokenSymbol : utils_tokenNameToAddress(tokenSymbol, chainId); const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, tokenAddress); const weiBalance = await tokenContract.methods.balanceOf(userAddress).call(); const ethBalance = await getEtherNumberAmount(tokenAddress, weiBalance, chainId); return isMaxButton ? parseFloat(ethBalance).toFixed(6) : ethBalance }; const getRealWeiTokenBalance = async (tokenSymbol, userAddress, chainId) => { if (!userAddress) return null; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); if (tokenSymbol === "ETH" || tokenSymbol === "BNB") { const balance = await web3.eth.getBalance(userAddress); return balance.toString() } const tokenAddress = tokenSymbol.length === 42 ? tokenSymbol : utils_tokenNameToAddress(tokenSymbol, chainId); const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, tokenAddress); const weiBalance = await tokenContract.methods.balanceOf(userAddress).call(); return weiBalance };
        ;// ./src/utils/camelot.ts
        function isCamelot(productAddress) { const isCamelotPool = Arbitrum_ArbitrumData.camelotPools.some(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase()); return isCamelotPool } function getNftPoolAddress(productAddress) { const nftPool = Arbitrum_ArbitrumData.camelotPools.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase()); return nftPool?.nftAddress } function getLpName(productAddress) { const nftPool = Arbitrum_ArbitrumData.camelotPools.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase()); return nftPool?.bptName } const camelotUtils = { isCamelot, getNftPoolAddress, getLpName };/* harmony default export */ const camelot = (camelotUtils);
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/LeftUsdValues/ProductLeftUsdValue.tsx
        function ProductLeftUsdValue({ ethBalance, name }) { const coingeckoData = hooks_useCoingecko(); const { current_price: usdPrice } = coingeckoData.find(c => c.symbol?.toLowerCase() === name?.toLowerCase()); const usdValue = usdPrice * Number(ethBalance); const finalValue = useCompactNumbers(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "actual-value-points-box points-box", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "left-point.actual-value" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "active-amount row", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "amount", children: parseFloat(ethBalance).toFixed(5) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "badge-name", children: name })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "usd-value", children: ["(", finalValue(usdValue, 2), " USD) "] })] }) }
        ;// ./src/contracts/Camelot/getNFTId.ts
        const jsonRpc = (id, address, data) => ({ jsonrpc: "2.0", method: "eth_call", params: [{ to: address, data }], id }); const getAmountOfPoolNftsForUser = async (nftPoolAddress, userAddress) => { if (!userAddress) return 0; if (!nftPoolAddress) return 0; const web3 = contracts_web3("arbitrum"); const nftPoolContract = new web3.eth.Contract(abis_GENERIC_ABIS.nftPoolCamelotAbi, nftPoolAddress); const amount = await nftPoolContract.methods.balanceOf(userAddress).call(); return parseInt(amount) }; const getNFTIds = async (nftPoolAddress, userAddress) => { const web3 = contracts_web3("arbitrum"); const totalUserNfts = await getAmountOfPoolNftsForUser(nftPoolAddress, userAddress); if (totalUserNfts === 0) return []; const nftPoolContract = new web3.eth.Contract(abis_GENERIC_ABIS.nftPoolCamelotAbi, nftPoolAddress); const batchRequest = new web3.BatchRequest; const promises = []; for (let i = 0; i < totalUserNfts; i++) { const data = nftPoolContract.methods.tokenOfOwnerByIndex(userAddress, i).encodeABI(); promises.push(batchRequest.add(jsonRpc(i.toString(), nftPoolAddress, data))) } await batchRequest.execute(); const ids = (await Promise.all(promises)).map(id => parseInt(id)); return ids }; const getLpEquivalentForNft = async (nftPoolAddress, nftId) => { const web3 = contracts_web3("arbitrum"); const nftPoolContract = new web3.eth.Contract(abis_GENERIC_ABIS.nftPoolCamelotAbi, nftPoolAddress); const info = await nftPoolContract.methods.getStakingPosition(nftId).call(); return info }; const getLpsForNfts = async (nftPoolAddress, ids) => { const web3 = contracts_web3("arbitrum"); const nftPoolContract = new web3.eth.Contract(abis_GENERIC_ABIS.nftPoolCamelotAbi, nftPoolAddress); const batchRequest = new web3.BatchRequest; const info = ids.map((id, index) => { const data = nftPoolContract.methods.getStakingPosition(id).encodeABI(); return batchRequest.add(jsonRpc(index.toString(), nftPoolAddress, data)) }); await batchRequest.execute(); const infoResolved = await Promise.all(info); const decodedAmountsInfo = infoResolved.map(info => { const decoded = web3.eth.abi.decodeParameters(["uint256"], info.toString()); return decoded[0].toString() }); const ethAmounts = decodedAmountsInfo.map(info => parseFloat(web3.utils.fromWei(info, "ether"))); return ethAmounts }; const getCamelotLpBalanceForSinglePool = async (nftPoolAddress, userAddress) => { const ids = await getNFTIds(nftPoolAddress, userAddress); if (ids?.length === 0) return 0; const lpsEthAmount = await getLpsForNfts(nftPoolAddress, ids); const lpTotal = lpsEthAmount.reduce((acc, l) => acc + l, 0); return lpTotal }; const getNFTId_getCamelotLpBalancesForAllPools = async userAddress => { const nftPools = ArbitrumData.camelotPools.map(p => p.nftAddress); const balances = []; for (const nftPoolAddress of nftPools) { const balance = await getCamelotLpBalanceForSinglePool(nftPoolAddress, userAddress); balances.push({ nftAddress: nftPoolAddress, balanceLp: balance }) } return balances };
        ;// ./src/contracts/Camelot/getCamelotLpValue.ts
        const getLiquidityForLpCamelotNFT = async (posAddress, coingeckoData) => { const web3 = contracts_web3("arbitrum"); const posContract = new web3.eth.Contract(abis_GENERIC_ABIS.camelotLpAbi, posAddress); const batchRequest = new web3.BatchRequest; const jsonRpc = (id, data) => ({ jsonrpc: "2.0", method: "eth_call", params: [{ to: posAddress, data }], id }); const totalAmount = posContract.methods.getTotalAmounts().encodeABI(); const token0 = posContract.methods.token0().encodeABI(); const token1 = posContract.methods.token1().encodeABI(); const promises = [batchRequest.add(jsonRpc("1", totalAmount)), batchRequest.add(jsonRpc("2", token0)), batchRequest.add(jsonRpc("3", token1))]; await batchRequest.execute(); const [weiAmounts, token0AddressRaw, token1AddressRaw] = await Promise.all(promises); const stringAmount = web3.eth.abi.decodeParameters(["uint256", "uint256"], weiAmounts); const weiAmountArray = [stringAmount[0].toString(), stringAmount[1].toString()]; const amounts = weiAmountArray.map(amount => parseFloat(web3.utils.fromWei(amount, "ether"))); const token0Address = web3.eth.abi.decodeParameter("address", token0AddressRaw); const token1Address = web3.eth.abi.decodeParameter("address", token1AddressRaw); const token0Symbol = tokenAddressToSymbol(token0Address, Networks.arbitrum); const token1Symbol = tokenAddressToSymbol(token1Address, Networks.arbitrum); const token0Price = coingeckoData.find(data => data.symbol.toLowerCase() === token0Symbol.toLowerCase())?.current_price; const token1Price = coingeckoData.find(data => data.symbol.toLowerCase() === token1Symbol.toLowerCase())?.current_price; const liquidityUSD = amounts[0] * token0Price + amounts[1] * token1Price; return liquidityUSD }; const getTotalSupplyForLpCamelotNFT = async posAddress => { const web3 = contracts_web3("arbitrum"); const posContract = new web3.eth.Contract(abis_GENERIC_ABIS.camelotLpAbi, posAddress); const totalSupplyWei = await posContract.methods.totalSupply().call(); const totalSupply = parseFloat(web3.utils.fromWei(totalSupplyWei.toString(), "ether")); return totalSupply }; const getLpUSDPriceForNftPosition = async (posAddress, coingeckoData) => { const liquidityUSD = await getLiquidityForLpCamelotNFT(posAddress, coingeckoData); const totalSupply = await getTotalSupplyForLpCamelotNFT(posAddress); const unitaryLpPriceUsd = liquidityUSD / totalSupply; return unitaryLpPriceUsd }; const addLpPriceToCamelotPoolArray = async coingeckoData => { const poolsWithLpPrice = await Promise.all(ArbitrumData.camelotPools.map(async p => { const lpPrice = await getLpUSDPriceForNftPosition(p.pos, coingeckoData); return { pos: p.pos, nftAddress: p.nftAddress, lpPrice } })); return poolsWithLpPrice }; const getCamelotPositionsUsdValue = async (coingeckoData, userAddress) => { const camelotPoolsWithLpPrice = await addLpPriceToCamelotPoolArray(coingeckoData); const camelotPoolsBalances = await getCamelotLpBalancesForAllPools(userAddress); const camelotUsdValue = camelotPoolsBalances?.reduce((acc, p) => { const lpPrice = camelotPoolsWithLpPrice.find(c => c.nftAddress.toLowerCase() === p.nftAddress.toLowerCase())?.lpPrice; return acc + lpPrice * p.balanceLp }, 0) ?? 0; return camelotUsdValue };
        ;// ./src/hooks/useCamelot.ts
        const useCamelotPoolNftsForUser = (refreshKey, nftAddress) => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const amountNfts = hooks_usePromise(getAmountOfPoolNftsForUser, nftAddress, wallet?.address, refreshKey); return amountNfts }; const useGetNftIdsCamelot = (refreshKey, nftPoolsAddress) => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const nftsIds = hooks_usePromise(getNFTIds, nftPoolsAddress, wallet?.address, refreshKey); return nftsIds }; const useGetLpAmountForNft = (refreshKey, nftPoolsAddress, nftsIds) => { const idsBalances = hooks_usePromise(getLpsForNfts, nftPoolsAddress, nftsIds, refreshKey); return idsBalances };
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/LeftUsdValues/CamelotLeftUsdValue.tsx
        function CamelotLeftUsdValue({ pos, refreshKey }) { const nftAddress = camelot.getNftPoolAddress(pos); const name = camelot.getLpName(pos); const ids = useGetNftIdsCamelot(refreshKey, nftAddress); const lps = useGetLpAmountForNft(refreshKey, nftAddress, ids); const totalLpAmount = lps.reduce((acc, lp) => acc + lp, 0); const coingeckoData = hooks_useCoingecko(); const unitaryPrice = hooks_usePromise(getLpUSDPriceForNftPosition, pos, coingeckoData); const finalUsdValue = totalLpAmount * unitaryPrice; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "actual-value-points-box points-box", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "left-point.actual-value" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "active-amount row", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "amount", children: totalLpAmount?.toFixed(5) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "badge-name", children: name })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "usd-value", children: ["(", finalUsdValue.toFixed(2), " USD)"] })] }) }
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/LeftUsdValues/DefiLeftUsdValue.tsx
        function DefiLeftUsdValue({ ethBalance, address }) { const pool = useSinglePool(address); const bptUsdPrice = parseFloat(pool.liquidity) / parseFloat(pool.totalShares); const usdValue = bptUsdPrice * Number(ethBalance); const finalValue = useCompactNumbers(); const tokens = pool?.filteredTokens; const [open, setOpen] = (0, react.useState)(false); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "actual-value-points-box points-box", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "left-point.actual-value" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "active-amount row", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "amount", children: parseFloat(ethBalance).toFixed(5) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "points-symbol", onClick: () => setOpen(!open), children: ["+", tokens.length,/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { className: `tooltip ${open ? "open" : ""}`, children: tokens?.map(t =>/*#__PURE__*/(0, jsx_runtime.jsx)("li", { children: t.symbol }, t.id)) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "usd-value", children: ["(", finalValue(usdValue, 2), " USD)"] })] }) }
        ;// ./src/hooks/useNetworkFromRoute.ts
        const useNetworkFromRoute = () => { const { networkName } = (0, dist/* useParams */.g)(); const chainId = getNetworkIdByName(networkName); return { chainId, networkName } };/* harmony default export */ const hooks_useNetworkFromRoute = (useNetworkFromRoute);
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/ActualValueLeftPoint.tsx
        const DefiAndProductsLeftUsdValueWrapper = ({ productName, productAddress, refreshKey }) => { const nameUsed = productName ?? productAddress; const wallet = useWallet_useWallet(); const { chainId } = hooks_useNetworkFromRoute(); const productEthBalance = hooks_usePromise(getSingleTokenBalance, nameUsed, wallet, chainId, false, refreshKey); if (productName) { return /*#__PURE__*/(0, jsx_runtime.jsx)(ProductLeftUsdValue, { ethBalance: productEthBalance, name: productName }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(DefiLeftUsdValue, { ethBalance: productEthBalance, address: productAddress }) }; const ActualValueLeftPoint = ({ refreshKey }) => { const { productName, productAddress } = (0, dist/* useParams */.g)(); const isCamelot = camelot.isCamelot(productAddress); if (productName || !isCamelot) { return /*#__PURE__*/(0, jsx_runtime.jsx)(DefiAndProductsLeftUsdValueWrapper, { productAddress: productAddress, productName: productName, refreshKey: refreshKey }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(CamelotLeftUsdValue, { pos: productAddress, refreshKey: refreshKey }) };/* harmony default export */ const LeftPointsTypes_ActualValueLeftPoint = (ActualValueLeftPoint);
        ;// ./src/components/FallbackNoConnected/FallbackNoConnected.tsx
        const FallbackNoConnected = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { id: "left-points-fallback", children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "fallback-no-connected", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "left-points-fallback" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ConnectButton, {})] }) }) }) };/* harmony default export */ const FallbackNoConnected_FallbackNoConnected = (FallbackNoConnected);
        ;// ./src/routes/ProductInfo/LeftInfo/LeftProductInfoClient.tsx
        const LeftProductInfoClient = ({ infoType }) => { const isLST = infoType === "LST"; const isDefi = infoType === "Defi"; return /*#__PURE__*/_jsxs("div", { className: "left-product-info", children: [/*#__PURE__*/_jsx(DefaultPointsBox, { type: "default" }),/*#__PURE__*/_jsx(DefaultPointsBox, { type: "default" }), !isLST || isDefi &&/*#__PURE__*/_jsx(DefaultPointsBox, { type: "default" }), !isLST || isDefi &&/*#__PURE__*/_jsx(DefaultPointsBox, { type: "default" }), isDefi &&/*#__PURE__*/_jsx(DefaultPointsBox, { type: "default" })] }) };/* harmony default export */ const LeftInfo_LeftProductInfoClient = ((/* unused pure expression or super */ null && (LeftProductInfoClient)));
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/Defi/useDefiPoints.ts
        function useEigenLayerWithRenzo() { const { productAddress } = (0, dist/* useParams */.g)(); const isDefiCamelot = Arbitrum_ArbitrumData.camelotPools.some(p => p.pos.toLowerCase() === productAddress.toLowerCase()); const { balancer, camelot } = useRenzoPoints(); const eigenLayerPoints = isDefiCamelot ? camelot.eigenLayerPoints : balancer.eigenLayerPoints; return { points: eigenLayerPoints } } function useEigenLayerWithKelp() { const { eigenLayerPoints } = useKelpPoints(); return { points: eigenLayerPoints } } function useEigenLayerWithKelpAndRenzo() { const { eigenLayerPoints: kelpEigenLayer } = useKelpPoints(); const { balancer } = useRenzoPoints(); const renzoEigenLayerPoints = +balancer.eigenLayerPoints; const total = parseFloat(kelpEigenLayer) + renzoEigenLayerPoints; return { points: total.toString() } }
        ;// ./src/components/Points/AssetInfo/AssetInfoPoints.tsx
        function AssetInfoPoints({ type, useFetchPoints, refreshKey }) { const { points } = useFetchPoints(refreshKey); return /*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_PointsBox, { type: type, points: +points }) }
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/Defi/EigenLayerDefiLeftPoints.tsx
        const EigenLayerDefiLeftPoints = ({ isKelp, isRenzo }) => { if (isRenzo && isKelp) return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "eigenLayer", useFetchPoints: useEigenLayerWithKelpAndRenzo }); if (isKelp) return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "eigenLayer", useFetchPoints: useEigenLayerWithKelp }); return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "eigenLayer", useFetchPoints: useEigenLayerWithRenzo }) };/* harmony default export */ const Defi_EigenLayerDefiLeftPoints = (EigenLayerDefiLeftPoints);
        ;// ./src/routes/ProductInfo/LeftInfo/LeftDefiInfo.tsx
        const LeftDefiInfo = ({ refreshKey, filteredTokens }) => { const renzoAddress = "0x2416092f143378750bb29b79eD961ab195CcEea5"; const kelpAddress = "0x4186BFC76E2E237523CBC30FD220FE055156b41F"; const isRenzoToken = filteredTokens?.some(t => t.address.toLowerCase() === renzoAddress.toLowerCase()); const isKelpToken = filteredTokens?.some(t => t.address.toLowerCase() === kelpAddress.toLowerCase()); const wallet = useWallet_useWallet(); console.log("wallet", wallet); if (false) { } if (wallet === null) return /*#__PURE__*/(0, jsx_runtime.jsx)(FallbackNoConnected_FallbackNoConnected, {}); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "left-defi-info", className: "left-product-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "default" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(LeftPointsTypes_ActualValueLeftPoint, { refreshKey: refreshKey }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "autoLayer" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "autoLayer", useFetchPoints: useAutolayerPoints, refreshKey: refreshKey }) }) }), (isRenzoToken || isKelpToken) &&/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "eigenLayer" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(Defi_EigenLayerDefiLeftPoints, { isKelp: isKelpToken, isRenzo: isRenzoToken }) }) }), isRenzoToken &&/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "renzo" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "renzo", useFetchPoints: useEigenLayerWithRenzo }) }) }), isKelpToken &&/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "kelp" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "kelp", useFetchPoints: useKelpPoints }) }) })] }) };/* harmony default export */ const LeftInfo_LeftDefiInfo = (LeftDefiInfo);
        ;// ./src/components/Charts/ChartTimeSelector/ChartTimeSelector.tsx
        const timeSpanArray = ["1d", "7d", "1m", "1y", "all"]; const checkTimeSpan = time => timeSpanArray.some(item => item === time); const ChartTimeSelector = ({ handleTime, time }) => { const handleChange = event => { const time = event.target.value; const isCorrect = checkTimeSpan(time); handleTime(isCorrect ? time : "1d") }; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "chart-time-selector", children: timeSpanArray.map(timeSpan =>/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "radio", value: timeSpan, checked: time === timeSpan, className: "time-pnl-radio", onChange: handleChange }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: timeSpan })] }, timeSpan)) }) };/* harmony default export */ const ChartTimeSelector_ChartTimeSelector = (ChartTimeSelector);
        ;// ./src/components/Charts/AprChart/AprChartWrapper.tsx
        const AprChart =/*#__PURE__*/(0, react.lazy)(() => Promise.all(/*! import() */[__webpack_require__.e(4027), __webpack_require__.e(1751)]).then(__webpack_require__.bind(__webpack_require__, /*! ./AprChart */ 61751))); function AprChartWrapper(props) { return /*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AprChart, { ...props }) }) }
        ;// ./src/components/Charts/AprChart/CompleteAprChart/CompleteAprChart.tsx
        function CompleteChart({ productName, fallbackData }) { const [time, setTime] = (0, react.useState)("1m"); const handleTime = (0, react.useCallback)(time => setTime(time), []); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "chart-apr-item", children: [true ?/*#__PURE__*/(0, jsx_runtime.jsx)(AprChartWrapper, { chartTime: time, productName: productName, handleTime: handleTime, fallbackData: fallbackData }) : 0,/*#__PURE__*/(0, jsx_runtime.jsx)(ChartTimeSelector_ChartTimeSelector, { time: time, handleTime: handleTime })] }) }
        ;// ./src/routes/ProductInfo/MiddleInfo/InfoBox/InfoBox.tsx
        const InfoBox = ({ amount, type }) => { const finalValue = useCompactNumbers(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `${type}-info-box info-box`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `info-box.${type}` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { title: amount?.toFixed(2), className: `${type}-amount row`, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("strong", { className: "amount", children: [type !== "apr" ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "currency", children: "$" }) : "",/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: finalValue(+amount, 2) }), type === "apr" ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "percentage", children: "%" }) : ""] }) })] }) };/* harmony default export */ const InfoBox_InfoBox = (InfoBox);
        ;// ./src/hooks/useTokensWeightForPools.ts
        const useTokensWeightForPools = pool => { const coingeckoData = hooks_useCoingecko(); const poolWithTokenWeights = helpers_addTokensWeightForPools([pool], coingeckoData); return poolWithTokenWeights };/* harmony default export */ const hooks_useTokensWeightForPools = (useTokensWeightForPools);
        ;// ./src/routes/ProductInfo/MiddleInfo/PoolTokenTable/PoolTokenTable.tsx
        const PoolTokenTable = ({ tokens }) => { const calc = useCompactNumbers(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("table", { id: "pool-token-table", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("colgroup", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-token" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-balance" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-usd-value" }),/*#__PURE__*/(0, jsx_runtime.jsx)("col", { className: "col-token-weight" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("thead", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("th", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "pool-token-table.token" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "pool-token-table.balance" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "pool-token-table.usd-value" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("th", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "pool-token-table.token-weight" }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("tbody", { children: tokens?.map(t => { const scanLink = "https://arbiscan.io/address/" + t?.address; const finalValue = calc(t.usdValue, 2); return /*#__PURE__*/(0, jsx_runtime.jsxs)("tr", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("td", { className: "cell-token", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage(t?.symbol.toLowerCase()), alt: t?.symbol, className: "token-image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "token-name", children: t.symbol }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", target: "_blank", href: scanLink, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-external_window" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "cell-balance", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "token-balance", children: parseFloat(t?.balance).toFixed(5) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "cell-usd-value", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "usd-value", children: ["$", finalValue] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("td", { className: "cell-token-weight", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "token-weight", children: [(t.weight * 100).toFixed(2), "%"] }) })] }, t?.address) }) })] }) }; const PoolTokenBalancerTable = ({ productInfo }) => { const info = hooks_useTokensWeightForPools(productInfo); return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "pool-token-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)(PoolTokenTable, { tokens: info[0].filteredTokens }) }) }; const PoolTokenWrapper = ({ productInfo }) => { return productInfo.provider === "Camelot" ?/*#__PURE__*/(0, jsx_runtime.jsx)(PoolTokenTable, { tokens: productInfo.filteredTokens }) :/*#__PURE__*/(0, jsx_runtime.jsx)(PoolTokenBalancerTable, { productInfo: productInfo }) };/* harmony default export */ const PoolTokenTable_PoolTokenTable = (PoolTokenWrapper);
        ;// ./src/routes/ProductInfo/MiddleInfo/TokensWeight.tsx
        const TokensWeight = ({ scanLink, info }) => { const isCamelot = info.provider === "Camelot"; const tokens = isCamelot ? info.filteredTokens : info[0].filteredTokens; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "tokens", children: [tokens.map(t =>/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "token-card", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage(t.symbol.toLowerCase()), alt: t.symbol, className: "token-image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "token-name", children: t.symbol }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "token-weight", children: [(t.weight * 100).toFixed(2), "%"] })] }, t.address)),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", target: "_blank", href: scanLink, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-external_window" }) })] }) }; const BalancerTokensWeight = ({ productInfo }) => { const scanLink = "https://arbiscan.io/address/" + productInfo?.address; const info = hooks_useTokensWeightForPools(productInfo); return /*#__PURE__*/(0, jsx_runtime.jsx)(TokensWeight, { info: info, scanLink: scanLink }) }; const TokensWeightWrapper = ({ productInfo }) => { return productInfo.provider === "Camelot" ?/*#__PURE__*/(0, jsx_runtime.jsx)(TokensWeight, { info: productInfo, scanLink: "https://arbiscan.io/address/" + productInfo.pos }) :/*#__PURE__*/(0, jsx_runtime.jsx)(BalancerTokensWeight, { productInfo: productInfo }) };/* harmony default export */ const MiddleInfo_TokensWeight = (TokensWeightWrapper);
        ;// ./src/routes/ProductInfo/MiddleInfo/MiddleDefiInfo.tsx
        const MiddleDefiInfo = ({ productInfo }) => { const { address, name, apy, provider, liquidity, volume, multipliers } = productInfo; const tvl = +liquidity; return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "defi-middle-section", className: "middle-section", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "top-info", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: `badge ${provider?.toLowerCase()} provider`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: protocolsIcons?.[provider.toLowerCase()], alt: provider, className: "provider-image" }), provider] }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { title: name, children: name }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { mini: true, colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(MiddleInfo_TokensWeight, { productInfo: productInfo }) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "info-cards", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(InfoBox_InfoBox, { type: "apr", amount: +apy }),/*#__PURE__*/(0, jsx_runtime.jsx)(InfoBox_InfoBox, { type: "volume", amount: +volume }),/*#__PURE__*/(0, jsx_runtime.jsx)(InfoBox_InfoBox, { type: "tvl", amount: tvl })] })] }), !!productInfo?.description &&/*#__PURE__*/(0, jsx_runtime.jsx)("section", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children: productInfo?.description }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "multipliers-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "middle-section.multipliers" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ListMultiplier_ListMultiplier, { multipliers: multipliers })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(CompleteChart, { productName: address }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "pool-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "middle-section.pool-composition" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(PoolTokenTable_PoolTokenTable, { productInfo: productInfo }) }) })] })] }) };/* harmony default export */ const MiddleInfo_MiddleDefiInfo = (MiddleDefiInfo);
        ;// ./src/hooks/useEnoughBalance.ts
        const useEnoughBalance = (realAmountWei, tokenSymbol) => { const [hasEnoughBalance, setHasEnoughBalance] = (0, react.useState)(false); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const userAddress = wallet?.address; const { chainId } = hooks_useNetworkFromRoute(); (0, react.useEffect)(() => { const getTokenBalance = async () => { const balance = await getRealWeiTokenBalance(tokenSymbol, userAddress, chainId); if (!balance) { setHasEnoughBalance(false); return } const bigIntBalance = BigInt(balance); setHasEnoughBalance(bigIntBalance >= realAmountWei) }; getTokenBalance().catch(error => { console.error("Error in hook useEnoughBalance", error.message); setHasEnoughBalance(false) }) }, [realAmountWei, tokenSymbol, userAddress, chainId]); return hasEnoughBalance };/* harmony default export */ const hooks_useEnoughBalance = (useEnoughBalance); const useEnoughBalanceCamelotPools = (realAmountWei, nftId, nftAddress) => { const [hasEnoughBalance, setHasEnoughBalance] = (0, react.useState)(false); (0, react.useEffect)(() => { if (nftId === "" || nftAddress === "") return; getLpEquivalentForNft(nftAddress, Number(nftId)).then(info => { const nftLpAmountWei = BigInt(info.amount); setHasEnoughBalance(nftLpAmountWei >= realAmountWei) }).catch(error => { console.error("Error in hook useEnoughBalanceCamelotPools", error.message); setHasEnoughBalance(false) }) }, [realAmountWei, nftId, nftAddress]); return hasEnoughBalance };
        ;// ./src/routes/ProductInfo/ProductInfoButtons/ChangeNetworkButton.tsx
        const ChangeNetworkButton = ({ darkMode }) => { const { chainId } = hooks_useNetworkFromRoute(); const { networkTag } = getItemByNetwork(chainId); const wallet = useWallet_useWallet(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `product-info-buttons network ${!darkMode ? "dark-theme" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "change-network-to" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: networkTag })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { disabled: wallet === null, className: "network", onClick: () => changeChain(chainId), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "change-network" }) })] }) };/* harmony default export */ const ProductInfoButtons_ChangeNetworkButton = (ChangeNetworkButton);
        ;// ./src/hooks/useWalletChainId.ts
        const useWalletChainId = () => { const chainId = (0, es/* useSelector */.d4)(state => state.network); return chainId };/* harmony default export */ const hooks_useWalletChainId = (useWalletChainId);
        ;// ./src/routes/ProductInfo/ProductInfoButtons/ProductInfoButtons.tsx
        const ProductInfoButtons = ({ darkMode = false, setIsDepositDialogOpen, setIsSwapDialogOpen, disableWithdraw }) => { const { productName } = (0, dist/* useParams */.g)(); const handleSwap = () => { setIsSwapDialogOpen(true) }; const handleDepositMore = () => { setIsDepositDialogOpen(true) }; const isForToken = !!productName; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: !darkMode ? "product-info-buttons" : "product-info-buttons dark-theme", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "deposit-more", onClick: handleDepositMore, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Restake" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: isForToken ? "swap" : "withdraw", onClick: handleSwap, disabled: disableWithdraw, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [" ", isForToken ?/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "swap" }) :/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "token-selector.withdraw" })] }) })] }) }; const CamelotProductInfoButtons = ({ darkMode = false, setIsDepositDialogOpen, setIsSwapDialogOpen, refresher }) => { const { productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const nftAddress = networkInfo?.camelotPools?.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase())?.nftAddress; const amountNfts = useCamelotPoolNftsForUser(refresher, nftAddress); const disableWithdraw = amountNfts === 0; return /*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfoButtons, { setIsDepositDialogOpen: setIsDepositDialogOpen, darkMode: darkMode, setIsSwapDialogOpen: setIsSwapDialogOpen, disableWithdraw: disableWithdraw }) }; const TokensProductInfoButtons = ({ darkMode = false, setIsDepositDialogOpen, setIsSwapDialogOpen }) => { const { productName } = (0, dist/* useParams */.g)(); const { productAddress } = (0, dist/* useParams */.g)(); const tokenUsed = productName ?? productAddress; const MIN_WEI_AMOUNT = BigInt(100); const enoughBalance = hooks_useEnoughBalance(MIN_WEI_AMOUNT, tokenUsed); const disableWithdraw = !enoughBalance; if (!productName) { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: !darkMode ? "product-info-buttons" : "product-info-buttons dark-theme", children:/*#__PURE__*/(0, jsx_runtime.jsx)("a", { href: "https://autolayer.notion.site/The-AuBNB-Odyssey-Discovering-Next-Gen-LRT-12f62c8ce4be80d5b5e4e246f02fe04f", className: "button", id: "aubnb-button", target: "_blank", rel: "noopener noreferrer", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "how-get-whitelisted" }) }) }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfoButtons, { setIsDepositDialogOpen: setIsDepositDialogOpen, darkMode: darkMode, setIsSwapDialogOpen: setIsSwapDialogOpen, disableWithdraw: disableWithdraw }) }; const ProductInfoButtonsWrapper = ({ darkMode = false, setIsDepositDialogOpen, setIsSwapDialogOpen, refresher }) => { const { productAddress } = (0, dist/* useParams */.g)(); const userWalletChainId = hooks_useWalletChainId(); const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const isCamelot = networkInfo?.camelotPools?.some(pool => pool?.pos?.toLowerCase() === productAddress?.toLowerCase()); if (chainId !== userWalletChainId) { return /*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfoButtons_ChangeNetworkButton, { darkMode: darkMode }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children: isCamelot ?/*#__PURE__*/(0, jsx_runtime.jsx)(CamelotProductInfoButtons, { refresher: refresher, setIsDepositDialogOpen: setIsDepositDialogOpen, darkMode: darkMode, setIsSwapDialogOpen: setIsSwapDialogOpen }) :/*#__PURE__*/(0, jsx_runtime.jsx)(TokensProductInfoButtons, { setIsDepositDialogOpen: setIsDepositDialogOpen, darkMode: darkMode, setIsSwapDialogOpen: setIsSwapDialogOpen }) }) };/* harmony default export */ const ProductInfoButtons_ProductInfoButtons = (ProductInfoButtonsWrapper);
        ;// ./src/types/DepositTypes.ts
        var ExecutionSteps; (function (ExecutionSteps) { ExecutionSteps[ExecutionSteps["notStarted"] = 0] = "notStarted"; ExecutionSteps[ExecutionSteps["gotRoute"] = 1] = "gotRoute"; ExecutionSteps[ExecutionSteps["approvedToken"] = 2] = "approvedToken"; ExecutionSteps[ExecutionSteps["sentToken"] = 3] = "sentToken" })(ExecutionSteps || (ExecutionSteps = {})); var FailExecutionSteps; (function (FailExecutionSteps) { FailExecutionSteps[FailExecutionSteps["failGotRoute"] = 1] = "failGotRoute"; FailExecutionSteps[FailExecutionSteps["failApprovedToken"] = 2] = "failApprovedToken"; FailExecutionSteps[FailExecutionSteps["failSentToken"] = 3] = "failSentToken" })(FailExecutionSteps || (FailExecutionSteps = {})); var RemoveLiquiditySteps; (function (RemoveLiquiditySteps) { RemoveLiquiditySteps[RemoveLiquiditySteps["notStarted"] = 0] = "notStarted"; RemoveLiquiditySteps[RemoveLiquiditySteps["approveBpt"] = 1] = "approveBpt"; RemoveLiquiditySteps[RemoveLiquiditySteps["sendBptLiquidity"] = 2] = "sendBptLiquidity"; RemoveLiquiditySteps[RemoveLiquiditySteps["approveToken"] = 3] = "approveToken"; RemoveLiquiditySteps[RemoveLiquiditySteps["sendToken"] = 4] = "sendToken" })(RemoveLiquiditySteps || (RemoveLiquiditySteps = {})); var FailRemoveLiquiditySteps; (function (FailRemoveLiquiditySteps) { FailRemoveLiquiditySteps[FailRemoveLiquiditySteps["failBptApprove"] = 1] = "failBptApprove"; FailRemoveLiquiditySteps[FailRemoveLiquiditySteps["failSendBptLiquidity"] = 2] = "failSendBptLiquidity"; FailRemoveLiquiditySteps[FailRemoveLiquiditySteps["failApproveToken"] = 3] = "failApproveToken"; FailRemoveLiquiditySteps[FailRemoveLiquiditySteps["failSendToken"] = 4] = "failSendToken" })(FailRemoveLiquiditySteps || (FailRemoveLiquiditySteps = {}));
        ;// ./src/contracts/getAllowance.ts
        const getAllowance = async (token, spender, owner, chainId) => { const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, token); const allowanceAmount = await tokenContract.methods.allowance(owner, spender).call(); return BigInt(allowanceAmount.toString()) };/* harmony default export */ const contracts_getAllowance = (getAllowance);
        ;// ./src/contracts/approveToken.ts
        const approveToken = async (tokenInput, amountIn, userAddress, chainId) => { const input = tokenInput.length === 42 ? tokenInput.toLowerCase() : utils_tokenNameToAddress(tokenInput, chainId); const swapsContractAddress = SWAPS_CONTRACT[chainId].toLowerCase(); const allowanceAmountWei = await contracts_getAllowance(input, swapsContractAddress, userAddress, chainId); if (allowanceAmountWei >= amountIn) return "0x"; const tokenContract = new web3/* default */.A.eth.Contract(abis_GENERIC_ABIS.token, input); const estimatedGas = await tokenContract.methods.approve(swapsContractAddress, amountIn.toString()).estimateGas({ from: userAddress }); const increasedGasPrice = chainId === Networks.arbitrum ? Number(estimatedGas) * 2 : Math.ceil(Number(estimatedGas) * 1.4); const tx = await tokenContract.methods.approve(swapsContractAddress, amountIn.toString()).send({ from: userAddress, gas: increasedGasPrice.toString(), maxPriorityFeePerGas: null, maxFeePerGas: null }); return tx };/* harmony default export */ const contracts_approveToken = (approveToken);
        ;// ./src/hooks/useIsConnected.ts
        const useIsConnected = () => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); if (wallet?.address) return true; else return false };/* harmony default export */ const hooks_useIsConnected = (useIsConnected);
        ;// ./src/hooks/useCommonDeposit.ts
        function useCommonDeposit(initialState) { const [data, setData] = (0, react.useState)(initialState); const [realWeiAmount, setRealWeiAmount] = (0, react.useState)(BigInt(0)); const isConnected = hooks_useIsConnected(); const [slippage, setSlippage] = (0, react.useState)(100); const [searchMode, setSearchMode] = (0, react.useState)(false); const [executionStep, setExecutionStep] = (0, react.useState)(undefined); const [failExecutionStep, setFailExecutionStep] = (0, react.useState)(undefined); const [txHash, setTxHash] = (0, react.useState)(undefined); const [txPoints, setTxPoints] = (0, react.useState)(undefined); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const { networkName } = (0, dist/* useParams */.g)(); const chainId = getNetworkIdByName(networkName); return { data, setData, realWeiAmount, setRealWeiAmount, searchMode, setSearchMode, executionStep, setExecutionStep, failExecutionStep, setFailExecutionStep, txHash, setTxHash, txPoints, setTxPoints, wallet, isConnected, chainId, slippage, setSlippage } }
        // EXTERNAL MODULE: ./node_modules/@paraswap/sdk/dist/sdk.esm.js
        var sdk_esm = __webpack_require__(95855);
        ;// ./src/utils/swap.ts
        function getTokenAddress(token, chainId) { return token.length === 42 ? token.toLowerCase() : utils_tokenNameToAddress(token, chainId) } function swap_getTokenDecimals(tokenAddress, chainId) { const networkInfo = data_networkData(chainId); const decimals = +networkInfo.tokens.find(token => token.address.toLowerCase() === tokenAddress)?.decimals; return decimals } const swapUtils = { getTokenDecimals: swap_getTokenDecimals, getTokenAddress };/* harmony default export */ const swap = (swapUtils);
        ;// ./src/contracts/Paraswap/sdk.ts
        const paraswapMap = new Map; const getParaswapSDK = networkName => { if (!paraswapMap.has(networkName)) { let chainId = 42161; if (networkName === "ethereum") chainId = 1; else if (networkName === "binance") chainId = 56; else if (networkName === "optimism") chainId = 10; else if (networkName === "base") chainId = 8453; paraswapMap.set(networkName, (0, sdk_esm/* constructSimpleSDK */.E1)({ chainId, fetch: window.fetch, version: "6.2" })) } return true && paraswapMap.get(networkName) };
        ;// ./src/contracts/Paraswap/getParaswapRoute.ts
        const getParaswapRoute = async (tokenIn, tokenOut, amount, chainId) => { const inputToken = swap.getTokenAddress(tokenIn, chainId); const outputToken = swap.getTokenAddress(tokenOut, chainId); const inputDecimals = swap.getTokenDecimals(inputToken, chainId); const outputDecimals = swap.getTokenDecimals(outputToken, chainId); const networkName = getNetworkName(chainId); const paraSwapMin = getParaswapSDK(networkName); const priceRoute = await paraSwapMin.swap.getRate({ srcToken: inputToken, destToken: outputToken, srcDecimals: inputDecimals, destDecimals: outputDecimals, amount, side: sdk_esm/* SwapSide */.tw.SELL, options: { includeContractMethods: [sdk_esm/* ContractMethod */.cM.swapExactAmountInOnUniswapV3, sdk_esm/* ContractMethod */.cM.swapExactAmountIn], excludeContractMethodsWithoutFeeModel: true } }); return priceRoute };/* harmony default export */ const Paraswap_getParaswapRoute = (getParaswapRoute);
        ;// ./src/contracts/Paraswap/buildParaswapTx.ts
        const buildParaswapTx = async (priceRoute, tokenIn, tokenOut, amount, chainId, slippage) => { const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const TX_FEE = 20; const FEE_TREASURY_ADDRESS = "0xfabada35c7868b320d78e5f30b9ce139d123ccf2"; const inputToken = swap.getTokenAddress(tokenIn, chainId); const outputToken = swap.getTokenAddress(tokenOut, chainId); const inputDecimals = swap.getTokenDecimals(inputToken, chainId); const outputDecimals = swap.getTokenDecimals(outputToken, chainId); const buildTxInputBase = { srcToken: inputToken, destToken: outputToken, userAddress: swapsContractAddress.toLowerCase(), srcDecimals: inputDecimals, destDecimals: outputDecimals }; const buildTxInput = { ...buildTxInputBase, priceRoute, slippage, srcAmount: amount, partnerAddress: FEE_TREASURY_ADDRESS, partnerFeeBps: TX_FEE, takeSurplus: false, isDirectFeeTransfer: true, isSurplusToUser: false }; const options = { ignoreChecks: true }; const networkName = getNetworkName(chainId); const paraSwapMin = getParaswapSDK(networkName); const txParams = await paraSwapMin.swap.buildTx(buildTxInput, options); return txParams };/* harmony default export */ const Paraswap_buildParaswapTx = (buildParaswapTx);
        ;// ./src/hooks/useDeposit.ts
        const useDeposit = ({ refreshAutoLayerPoints }) => { const { networkName: network } = hooks_useNetworkFromRoute(); const initialTokenSymbol = network === "binance" ? "BNB" : "ETH"; const { data: depositData, executionStep, failExecutionStep, realWeiAmount, searchMode, setData: setDepositData, setExecutionStep, setFailExecutionStep, setRealWeiAmount, setSearchMode, setTxHash, setTxPoints, txHash, txPoints, wallet, isConnected, chainId, setSlippage, slippage } = useCommonDeposit({ outputCoin: initialTokenSymbol, amount: 0 }); const hasEnoughBalance = hooks_useEnoughBalance(realWeiAmount, depositData?.outputCoin); const retrieveTokenInAdress = () => { const tokenIn = depositData.outputCoin; const tokenInAddress = tokenIn.length === 42 ? tokenIn.toLowerCase() : utils_tokenNameToAddress(tokenIn, chainId); return tokenInAddress }; const changeExecutionStep = executionStep => setExecutionStep(executionStep); const retrieveTxParams = async (tokenInAddress, output, amount, slippage) => { const priceRoute = await Paraswap_getParaswapRoute(tokenInAddress, output, amount, chainId); const txParams = await Paraswap_buildParaswapTx(priceRoute, tokenInAddress, output, amount, chainId, slippage); return { txParams, priceRoute } }; const handleRetrieveTxParamsError = error => { console.error("Error getting swap info", error.message); setFailExecutionStep(FailExecutionSteps.failGotRoute) }; const tokenApprove = async tokenInAddress => { const nativeCrypto = getNativeCurrencySymbol(chainId); if (tokenInAddress === utils_tokenNameToAddress(nativeCrypto, chainId)) return; await contracts_approveToken(tokenInAddress, realWeiAmount, wallet?.address, chainId) }; const handleApproveError = error => { console.error("Error approving token", error.message); setFailExecutionStep(FailExecutionSteps.failApprovedToken) }; const finishTransaction = sendSwapTx => { const { points, transactionHash } = getAutolayerPointsAfterTx(sendSwapTx, wallet?.address); setTxHash(transactionHash); setTxPoints(points); refreshAutoLayerPoints() }; const handleSendError = error => { console.error("Error sending swap transaction", error.message); setFailExecutionStep(FailExecutionSteps.failSentToken) }; const handleTokenChange = data => { if (executionStep || failExecutionStep) { setExecutionStep(undefined); setFailExecutionStep(undefined) } setDepositData(data) }; return { searchMode, executionStep, failExecutionStep, txHash, txPoints, isConnected, hasEnoughBalance, depositData, realWeiAmount, wallet, chainId, setDepositData, setRealWeiAmount, handleTokenChange, retrieveTokenInAdress, retrieveTxParams, handleRetrieveTxParamsError, handleSendError, finishTransaction, handleApproveError, tokenApprove, setSearchMode, changeExecutionStep, slippage, setSlippage } };/* harmony default export */ const hooks_useDeposit = (useDeposit);
        ;// ./src/contracts/sendSwapTransaction.ts
        const sendSwapTransaction = async (txParams, outputToken, weiAmount, userAddress, chainId) => { const ETH_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE"; const data = txParams.data; const outputAddress = outputToken.length === 42 ? outputToken.toLowerCase() : utils_tokenNameToAddress(outputToken, chainId).toLowerCase(); const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const gasPrice = Math.ceil(parseFloat(txParams.gasPrice) * 1.25); let sendSwapTx; if (txParams.value !== "0") { const estimatedGas = await swapsContract.methods.swapTokensWithETH(data).estimateGas({ from: userAddress, value: weiAmount }); const increasedGas = chainId === Networks.ethereum ? Math.ceil(Number(estimatedGas) * 1.6) : Number(estimatedGas) * 2; sendSwapTx = await swapsContract.methods.swapTokensWithETH(data).send({ from: userAddress, gasPrice: gasPrice.toString(), gas: increasedGas.toString(), value: weiAmount }) } else if (outputAddress === ETH_ADDRESS.toLowerCase()) { const estimatedGas = await swapsContract.methods.swapTokensWithETH(data).estimateGas({ from: userAddress }); const increasedGas = chainId === Networks.ethereum ? Math.ceil(Number(estimatedGas) * 1.6) : Number(estimatedGas) * 2; sendSwapTx = await swapsContract.methods.swapTokensWithETH(data).send({ from: userAddress, gasPrice: gasPrice.toString(), gas: increasedGas.toString() }) } else { const estimatedGas = await swapsContract.methods.swapTokens(data).estimateGas({ from: userAddress }); const increasedGas = chainId === Networks.ethereum ? Math.ceil(Number(estimatedGas) * 1.6) : Number(estimatedGas) * 2; sendSwapTx = await swapsContract.methods.swapTokens(data).send({ from: userAddress, gasPrice: gasPrice.toString(), gas: increasedGas.toString() }) } return sendSwapTx };/* harmony default export */ const contracts_sendSwapTransaction = (sendSwapTransaction);
        ;// ./src/components/TokenSelector/BalanceButtons/BalanceButtons.tsx
        const BalanceButtons = ({ previousData, onChange, disabled = true, isSwap = false, setRealWeiAmount }) => { const [open, setOpen] = (0, react.useState)(false); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const { productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const nftPoolsAddress = networkInfo?.camelotPools?.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase())?.nftAddress; const handleBalance = async value => { const token = isSwap ? previousData.inputCoin : previousData.outputCoin; const tokenAddress = swap.getTokenAddress(token, chainId); try { const res = await getRealWeiTokenBalance(token, wallet?.address, chainId); const ethAmount = await getEtherNumberAmount(tokenAddress, res, chainId); if (value === 1) { setRealWeiAmount(BigInt(res)); onChange({ ...previousData, amount: +parseFloat(ethAmount).toFixed(6) }) } else { const exactEthAmount = parseFloat(ethAmount) * value; onChange({ ...previousData, amount: +exactEthAmount?.toFixed(6) }); if (value === .25) setRealWeiAmount(BigInt(res) / BigInt(4)); else if (value === .5) setRealWeiAmount(BigInt(res) / BigInt(2)); else if (value === .75) { setRealWeiAmount(BigInt(res) / BigInt(4) * BigInt(3)) } } } catch (err) { console.error("Error in percentage buttons:", err.message) } }; const handleCamelotBalance = async value => { try { const info = await getLpEquivalentForNft(nftPoolsAddress, Number(previousData.outputCoin)); const lpAmountWei = info.amount; if (value === 1) { setRealWeiAmount(BigInt(lpAmountWei)); const ethAmount = +web3/* default */.A.utils.fromWei(lpAmountWei.toString(), "ether"); onChange({ ...previousData, amount: +ethAmount?.toFixed(6) }) } else { const ethAmount = +web3/* default */.A.utils.fromWei(lpAmountWei.toString(), "ether"); const exactEthAmount = ethAmount * value; onChange({ ...previousData, amount: +exactEthAmount?.toFixed(6) }); if (value === .25) setRealWeiAmount(BigInt(lpAmountWei) / BigInt(4)); else if (value === .5) { setRealWeiAmount(BigInt(lpAmountWei) / BigInt(2)) } else if (value === .75) { setRealWeiAmount(BigInt(lpAmountWei) / BigInt(4) * BigInt(3)) } } } catch (error) { console.error("Error in percentage buttons for Camelot:", error.message) } }; const handleFunction = nftPoolsAddress && isSwap ? handleCamelotBalance : handleBalance; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "balance-buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { disabled: disabled, className: "max-balance-button", onClick: () => handleFunction(1), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "max" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { disabled: disabled, className: "percentage-balance-button", onClick: () => setOpen(!open), children: "%" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `percentages ${open && !disabled ? "expanded" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", onClick: () => handleFunction(.75), children: "75%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", onClick: () => handleFunction(.5), children: "50%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", onClick: () => handleFunction(.25), children: "25%" })] })] }) };/* harmony default export */ const BalanceButtons_BalanceButtons = (BalanceButtons);
        ;// ./src/components/TokenSelector/TokenSearch/TokenSearch.tsx
        const TokenSearch = ({ search, setSearch }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("label", { className: "token-selector-search", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-search" }),/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "placeholder.token-selector", children: text =>/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "search", onChange: e => { e.preventDefault(); setSearch(e.target.value) }, placeholder: text, value: search || "" }) })] }) };/* harmony default export */ const TokenSearch_TokenSearch = (TokenSearch);
        ;// ./src/contracts/getBalance/getBalanceList.ts
        const getTokenBalanceList = async (tokens, address, chainId) => { const userAddress = address; if (!userAddress) return []; const networkCoin = getNativeCurrencySymbol(chainId); const weiBalance = []; const balancesEthPromise = []; const tokensList = tokens.length > 10 ? tokens.slice(0, 10) : tokens; const networkName = getNetworkName(chainId); const web3 = contracts_web3(networkName); for (const token of tokensList) { if (token.id === networkCoin) { weiBalance.push(web3.eth.getBalance(userAddress)); continue } const tokenContract = new web3.eth.Contract(abis_GENERIC_ABIS.token, token?.address); weiBalance.push(tokenContract.methods.balanceOf(userAddress).call()) } const balancesWei = await Promise.all(weiBalance); for (let i = 0; i < balancesWei?.length; i++) { balancesEthPromise.push(getEtherNumberAmount(tokensList[i].address, balancesWei[i], chainId)) } const balancesEth = await Promise.all(balancesEthPromise); const balancesResult = tokensList.map((token, i) => { const info = { balance: balancesEth[i], id: token.id, name: token.name, address: token.address }; return info }); return balancesResult }; const getPoolsBalanceList = async (pools, address) => { const userAddress = address; if (!userAddress) return []; const weiBalance = []; const web3 = getWeb3("arbitrum"); for (const token of pools) { const tokenContract = new web3.eth.Contract(GENERIC_ABIS.token, token?.address); weiBalance.push(tokenContract.methods.balanceOf(userAddress).call()) } const balancesWei = await Promise.all(weiBalance); const balancesEth = balancesWei.map(balance => web3.utils.fromWei(balance, "ether")); const balancesResult = pools.map((token, i) => { const info = { balance: balancesEth[i], id: token.id, name: token.name, address: token.address }; return info }); return balancesResult };
        ;// ./src/hooks/useTokenBalanceList.ts
        function useTokenBalanceList(tokens) { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const address = wallet?.address ? wallet.address : null; const { chainId } = hooks_useNetworkFromRoute(); const result = hooks_usePromise(getTokenBalanceList, tokens, address, chainId); return result }
        ;// ./src/components/TokenSelector/TokenSelectorList/tokensSelectorHelper.ts
        const filterTokenInListToAvoidSwapSameToken = (filterCoins, networkInfo, productAddress, inputCoin) => { let coinstWithInputCoin = []; if (!productAddress) { coinstWithInputCoin = filterCoins.filter(c => c.id.toLowerCase() !== inputCoin?.toLowerCase()) } else { const balancerPool = networkInfo.pools.find(p => p.address.toLowerCase() === productAddress.toLowerCase()); if (balancerPool) { coinstWithInputCoin = filterCoins.filter(c => !balancerPool.symbolTokens.includes(c.id.toLowerCase())) } else { const camelotPool = networkInfo.camelotPools.find(p => p.pos.toLowerCase() === productAddress.toLowerCase()); if (camelotPool) { coinstWithInputCoin = filterCoins.filter(c => !camelotPool.symbolTokens.includes(c.id.toLowerCase())) } } } return coinstWithInputCoin };
        ;// ./src/components/TokenSelector/TokenSelectorList/TokenSelectorList.tsx
        const TokenListItem = ({ outputCoin, setCoin, token }) => { const { showCopied, copyClipBoard } = useCopy(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("li", { className: `token-item ${outputCoin === token.id ? "selected" : ""}`, onClick: () => setCoin(token.id), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: token.id, src: getTokenImage(token.id) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: token.name || token.id }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: token.id }), token?.balance > 0 &&/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "compact-number", children: `(${compactNumbers(token?.balance, 5)})` })] })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "account-number", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: token.address.substr(0, 5) + "..." + token.address.slice(-3) }), showCopied &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "copied-bubble", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "copied-bubble.text" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { type: "button", className: "mobile-icon mobile-icon-copy", onClick: e => copyClipBoard(e, token.address) })] })] }) }; const TokenSelectorList = ({ outputCoin, setCoin, search, coins, inputCoin }) => { const { chainId } = hooks_useNetworkFromRoute(); const { productAddress } = (0, dist/* useParams */.g)(); const networkInfo = data_networkData(chainId); const balanceCoins = useTokenBalanceList(networkInfo.tokens); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const balanceOutputCoin = hooks_usePromise(getSingleTokenBalance, outputCoin, wallet?.address, chainId); if (balanceOutputCoin) { const index = balanceCoins.findIndex(token => token?.id === outputCoin); if (index === -1) { const newItem = { balance: parseFloat(balanceOutputCoin), id: outputCoin, address: utils_tokenNameToAddress(outputCoin, chainId) }; balanceCoins.push(newItem) } } const ids = new Set(balanceCoins.map(t => t.id)); const sortedBalanceCoins = [...balanceCoins].sort((a, b) => +b.balance - +a.balance); const merged = [...sortedBalanceCoins, ...coins.filter(c => !ids.has(c.id))]; const filterCoins = merged.filter(c => c.id.toLowerCase().includes(search.toLowerCase()) || c.name?.toLowerCase().includes(search.toLowerCase())); const coinstWithInputCoin = filterTokenInListToAvoidSwapSameToken(filterCoins, networkInfo, productAddress, inputCoin); return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children: coinstWithInputCoin.map(c =>/*#__PURE__*/(0, jsx_runtime.jsx)(TokenListItem, { token: c, outputCoin: outputCoin, setCoin: setCoin }, c.id)) }) };/* harmony default export */ const TokenSelectorList_TokenSelectorList = (TokenSelectorList);
        ;// ./src/components/TokenSelector/TokenSelector.tsx
        const MINIMUN_VALUE = 0; const TokenSelector = ({ previousData = { outputCoin: "WETH", amount: 0 }, onChange, searchMode = false, setSearchMode, setRealWeiAmount, blocked = true, darkMode = false }) => { const [search, setSearch] = (0, react.useState)(""); const { amount, outputCoin } = previousData; const { chainId } = hooks_useNetworkFromRoute(); const network = data_networkData(chainId); const setCoin = coin => { !!onChange && onChange({ ...previousData, outputCoin: coin }) }; const { productName } = (0, dist/* useParams */.g)(); const inputTokenDecimals = tokenDecimals_getTokenDecimals(previousData.outputCoin.toLowerCase(), chainId); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `token-selector ${blocked ? "blocked" : ""} ${darkMode ? "dark-theme" : "light-theme"}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "token-selector-info", onClick: () => setSearchMode?.(false), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { className: "input-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children: "Restake" }),/*#__PURE__*/(0, jsx_runtime.jsx)("input", { readOnly: blocked, className: `amount-input ${("" + amount).length < 9 ? "big" : ""}`, disabled: amount < MINIMUN_VALUE, type: "number", inputMode: "decimal", onFocus: () => { setSearchMode?.(false) }, onBlur: () => { const factor = Math.pow(10, Number(inputTokenDecimals)); setRealWeiAmount?.(BigInt(amount * factor)) }, onChange: e => { e.preventDefault(); const value = e.target.value; const decimals = value.split(",")[1]; if (decimals && decimals.length > 6) return; onChange({ ...previousData, amount: +e.target.value }) }, placeholder: "0", value: amount === 0 || !amount ? 0 : amount, min: MINIMUN_VALUE, step: "any" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("h1", { className: outputCoin?.length > 4 ? outputCoin?.length > 6 ? "micro" : "mini" : "", onClick: e => { e.stopPropagation(); if (!blocked) { setSearchMode?.(!searchMode) } }, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: outputCoin, src: getTokenImage(outputCoin) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: outputCoin || network.tokens[0].id }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `icon icon-angle_${searchMode ? "right" : "down"}` })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(BalanceButtons_BalanceButtons, { disabled: blocked, previousData: previousData, onChange: onChange, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: `token-selector-select ${searchMode ? "open" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSearch_TokenSearch, { search: search, setSearch: setSearch }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "token-selector-list-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { className: "token-selector-list", onClick: () => setSearchMode?.(false), children:/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error-loading-tokens-balance" }) }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children: !!onChange &&/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelectorList_TokenSelectorList, { coins: network.tokens, search: search, outputCoin: outputCoin, setCoin: setCoin, inputCoin: productName }) }) }) }) })] })] }) };/* harmony default export */ const TokenSelector_TokenSelector = (TokenSelector);
        ;// ./src/components/Deposit/NotConnectedDeposit.tsx
        const NotConnectedDeposit = ({ darkMode, searchMode, depositData, setDepositData, setSearchMode }) => { const handleConnect = () => { __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.connect()) }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "not-connected", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_TokenSelector, { darkMode: darkMode, searchMode: searchMode, previousData: depositData, blocked: true, onChange: setDepositData, setSearchMode: setSearchMode }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: handleConnect, className: !darkMode ? "continue-deposit light-theme" : "continue-deposit dark-theme", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "select-wallet-modal.connect-wallet" }) })] }) };/* harmony default export */ const Deposit_NotConnectedDeposit = (NotConnectedDeposit);
        ;// ./src/components/Swap/CamelotSelectedPositionData/CamelotSelectedPositionData.tsx
        const CamelotSelectedPositionData = ({ selectedPositionData, bptName }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "camelot-position-data", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: "USD Value: " }), "$", selectedPositionData?.usdValue?.toFixed(2)] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: "LP Amount: " }), " ", selectedPositionData?.balance?.toFixed(6), " ",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "bpt", children: bptName })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "after-withdrawal-you-receive" }), " ",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: bptName.split("-")[0] }), " &", " ",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: bptName.split("-")[1] })] })] }) };/* harmony default export */ const CamelotSelectedPositionData_CamelotSelectedPositionData = (CamelotSelectedPositionData);
        ;// ./src/components/Deposit/ContinueButton.tsx
        function ContinueButton({ disabled, handleDeposit, darkMode, selectedPositionData, bptName }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [bptName && selectedPositionData?.balance > 0 && selectedPositionData?.usdValue > 0 &&/*#__PURE__*/(0, jsx_runtime.jsx)(CamelotSelectedPositionData_CamelotSelectedPositionData, { bptName: bptName, selectedPositionData: selectedPositionData }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: !darkMode ? "continue-deposit light-theme" : "continue-deposit dark-theme", disabled: disabled, onClick: handleDeposit, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) })] }) }
        ;// ./src/components/Deposit/DepositStepMessage/messageList.ts
        const executionStepMessages = { 0: [["getting-route", "running"]], 1: [["getting-route", "done"], ["approving-token", "running"]], 2: [["getting-route", "done"], ["approving-token", "done"], ["sending-token", "running"]], 3: [["getting-route", "done"], ["approving-token", "done"], ["sending-token", "done"]] }; const failExecutionStepMessages = { 1: [["getting-route", "fail"]], 2: [["getting-route", "done"], ["approving-token", "fail"]], 3: [["getting-route", "done"], ["approving-token", "done"], ["sending-token", "fail"]] }; const createMessageList = (failExecutionStep, executionStep) => { if (!failExecutionStep) { const messages = executionStepMessages[executionStep]; return messages } const errorMessage = failExecutionStepMessages[failExecutionStep]; return errorMessage };/* harmony default export */ const messageList = (createMessageList); const executionStepMessagesForPoolsWithdrawal = { 0: [["approving-token", "running"]], 1: [["approving-token", "done"], ["signing", "running"]], 2: [["approving-token", "done"], ["signing", "done"], ["approving-token", "running"]], 3: [["approving-token", "done"], ["signing", "done"], ["approving-token", "done"], ["signing", "running"]], 4: [["approving-token", "done"], ["signing", "done"], ["approving-token", "done"], ["signing", "done"]] }; const failExecutionStepMessagesForPoolsWithdrawal = { 1: [["approving-token", "fail"]], 2: [["approving-token", "done"], ["signing", "fail"]], 3: [["approving-token", "done"], ["signing", "done"], ["approving-token", "fail"]], 4: [["approving-token", "done"], ["signing", "done"], ["approving-token", "done"], ["signing", "fail"]] }; const createMessageListForPoolsWithdrawal = (failExecutionStep, executionStep) => { if (!failExecutionStep) { const messages = executionStepMessagesForPoolsWithdrawal[executionStep]; return messages } const errorMessage = failExecutionStepMessagesForPoolsWithdrawal[failExecutionStep]; return errorMessage };
        ;// ./src/components/Deposit/DepositStepMessage/ScanLinkMessage.tsx
        const ScanLinkMessage = ({ txHash }) => { const { chainId } = hooks_useNetworkFromRoute(); const networkParams = getNetworkParams(chainId); const networkScan = networkParams.blockExplorerUrls[0]; const scanLink = networkScan + "tx/" + txHash; const { scanName } = getItemByNetwork(chainId); return /*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: scanLink, target: "_blank", className: "ftm-link", rel: "noreferrer", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: SmallIcons.linkGrey, alt: "link icon" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "deposit-step-scan.link", values: { scan: scanName } }) })] }) };/* harmony default export */ const DepositStepMessage_ScanLinkMessage = (ScanLinkMessage);
        ;// ./src/components/Deposit/DepositStepMessage/DepositStepMessage.tsx
        const DepositStepMessage = ({ failExecutionStep, executionStep, darkMode = false, txHash, txPoints }) => { const messages = messageList(failExecutionStep, executionStep); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `deposit-step-list ${darkMode ? "dark-theme" : "light-theme"}`, children: [messages?.map((message, index) => { const [step, status] = message; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [status === "done" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle done" }), failExecutionStep && status === "fail" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }), failExecutionStep && status === "running" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }), !failExecutionStep && status === "running" &&/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: `deposit-step-${step}.${status}` }) })] }, index) }), txHash ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_ScanLinkMessage, { txHash: txHash }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { className: "funds-wallet", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "funds-wallet" }) })] }) : null, txHash && txPoints && parseFloat(txPoints) > 0 &&/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("p", { className: "funds-wallet", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "deposit.tx-points-earned" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "tx-points", children: [parseFloat(txPoints).toFixed(4), " ",/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "dashboard.autoLayer" })] })] })] }) };/* harmony default export */ const DepositStepMessage_DepositStepMessage = (DepositStepMessage);
        ;// ./src/components/Slippage/Slippage.tsx
        const Slippage = ({ slippage, setSlippage, blocked }) => { const radioOptions = ["1", "2"]; const [open, setOpen] = (0, react.useState)(false); const handleChange = e => { const value = +e.target.value * 100; setSlippage(value <= 500 ? value : 500) }; return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "slippage", className: blocked ? "blocked" : "", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { onClick: () => setOpen(!open), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Slippage " }),/*#__PURE__*/(0, jsx_runtime.jsxs)("strong", { children: [slippage / 100, "%"] }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: gears_namespaceObject, alt: "gear icon" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `${open ? "open" : ""} slippage-bubble`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: "Slippage Tolerance" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "row", children: [radioOptions.map(option =>/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "radio", name: "slippageOption", value: option, checked: slippage === +option * 100, onChange: handleChange }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [option, " %"] })] }, option)),/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "number", name: "customValue", value: slippage && slippage > 0 && slippage <= 500 ? slippage / 100 : "", min: "1", max: "50", step: .1, onChange: handleChange }), "%"] })] })] })] }), open &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "veil", onClick: () => setOpen(false) })] }) };/* harmony default export */ const Slippage_Slippage = (Slippage);
        ;// ./src/components/Deposit/Deposit.tsx
        const Deposit = ({ darkMode = false, refreshAutoLayerPoints }) => { const { productName } = (0, dist/* useParams */.g)(); const { searchMode, setSearchMode, executionStep, failExecutionStep, txHash, txPoints, setDepositData, setRealWeiAmount, handleTokenChange, depositData, hasEnoughBalance, realWeiAmount, wallet, finishTransaction, tokenApprove, handleApproveError, handleRetrieveTxParamsError, handleSendError, retrieveTokenInAdress, retrieveTxParams, isConnected, chainId, changeExecutionStep, slippage, setSlippage } = hooks_useDeposit({ refreshAutoLayerPoints }); const blocked = executionStep !== undefined && failExecutionStep === undefined; const handleDeposit = async () => { setSearchMode(false); const tokenInAddress = retrieveTokenInAdress(); changeExecutionStep(ExecutionSteps.notStarted); let txParams; try { const paraswapRes = await retrieveTxParams(tokenInAddress, productName, realWeiAmount.toString(), slippage); txParams = paraswapRes.txParams; changeExecutionStep(tokenInAddress !== utils_tokenNameToAddress("ETH", chainId) ? ExecutionSteps.gotRoute : ExecutionSteps.approvedToken) } catch (err) { handleRetrieveTxParamsError(err); return } try { await tokenApprove(tokenInAddress); changeExecutionStep(ExecutionSteps.approvedToken) } catch (err) { handleApproveError(err); return } let sendSwapTx; try { sendSwapTx = await contracts_sendSwapTransaction(txParams, productName, realWeiAmount.toString(), wallet?.address, chainId) } catch (error) { handleSendError(error); return } try { finishTransaction(sendSwapTx); changeExecutionStep(ExecutionSteps.sentToken) } catch (error) { console.error("Error getting transaction Points", error.message) } }; if (!isConnected) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: depositData, setDepositData: setDepositData, setSearchMode: setSearchMode }) } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "deposit", className: darkMode ? "dark-theme" : "light-theme", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper-selector", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_TokenSelector, { darkMode: darkMode, searchMode: searchMode, previousData: depositData, blocked: blocked, onChange: handleTokenChange, setSearchMode: setSearchMode, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)(Slippage_Slippage, { blocked: blocked, slippage: slippage, setSlippage: setSlippage })] }), executionStep === undefined ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(ContinueButton, { disabled: depositData?.amount <= 0 || !hasEnoughBalance, handleDeposit: handleDeposit, darkMode: darkMode }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessage, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints })] }) };/* harmony default export */ const Deposit_Deposit = (Deposit);
        ;// ./src/contracts/addLiquidityBalancerPool.ts
        const addLiquidityBalancerPool = async (txParams, pool, weiAmount, userAddress, chainId) => { const data = txParams.data; const gasPrice = await web3/* default */.A.eth.getGasPrice(); const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const poolTokensAddresses = pool?.filteredTokens.map(token => token.address.toLowerCase()); poolTokensAddresses.sort((a, b) => Number(a) - Number(b)); const poolTokensAddressesWithBpt = pool.tokens.map(token => token.address.toLowerCase()); poolTokensAddressesWithBpt.sort((a, b) => Number(a) - Number(b)); const poolId = pool.id.toLowerCase(); const estimatedGas = await swapsContract.methods.addLiquidityToBalancer(data, poolTokensAddresses, poolTokensAddressesWithBpt, poolId).estimateGas({ from: userAddress, value: txParams.value !== "0" ? weiAmount : "0" }); const increasedGasPrice = Number(estimatedGas) * 2; const sendSwapTx = await swapsContract.methods.addLiquidityToBalancer(data, poolTokensAddresses, poolTokensAddressesWithBpt, poolId).send({ from: userAddress, gasPrice: gasPrice.toString(), gas: increasedGasPrice.toString(), value: txParams.value !== "0" ? weiAmount : "0" }); return sendSwapTx };/* harmony default export */ const contracts_addLiquidityBalancerPool = (addLiquidityBalancerPool);
        ;// ./src/components/Deposit/DepositPools.tsx
        const DepositPools = ({ darkMode = false, refreshAutoLayerPoints }) => { const { productAddress } = (0, dist/* useParams */.g)(); const thisPool = useSinglePool(productAddress); const tokenOutputAddress = thisPool?.filteredTokens[0].address.toLowerCase(); const { searchMode, executionStep, failExecutionStep, txHash, txPoints, depositData, hasEnoughBalance, realWeiAmount, wallet, isConnected, setDepositData, setRealWeiAmount, handleTokenChange, setSearchMode, finishTransaction, tokenApprove, handleApproveError, handleRetrieveTxParamsError, handleSendError, retrieveTokenInAdress, retrieveTxParams, changeExecutionStep, chainId, slippage, setSlippage } = hooks_useDeposit({ refreshAutoLayerPoints }); const blocked = executionStep !== undefined && failExecutionStep === undefined; const handleDeposit = async () => { setSearchMode(false); const tokenInAddress = retrieveTokenInAdress(); changeExecutionStep(ExecutionSteps.notStarted); let txParams; try { const paraswapRes = await retrieveTxParams(tokenInAddress, tokenOutputAddress, realWeiAmount.toString(), slippage); txParams = paraswapRes.txParams; changeExecutionStep(tokenInAddress !== utils_tokenNameToAddress("ETH", chainId) ? ExecutionSteps.gotRoute : ExecutionSteps.approvedToken) } catch (err) { handleRetrieveTxParamsError(err); return } try { await tokenApprove(tokenInAddress); changeExecutionStep(ExecutionSteps.approvedToken) } catch (err) { handleApproveError(err); return } let sendSwapTx; try { sendSwapTx = await contracts_addLiquidityBalancerPool(txParams, thisPool, realWeiAmount.toString(), wallet?.address, chainId) } catch (error) { handleSendError(error); return } try { finishTransaction(sendSwapTx); changeExecutionStep(ExecutionSteps.sentToken) } catch (error) { console.error("Error getting transaction Points", error.message) } }; if (!isConnected) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: depositData, setDepositData: setDepositData, setSearchMode: setSearchMode }) } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "deposit", className: darkMode ? "dark-theme" : "light-theme", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper-selector", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_TokenSelector, { darkMode: darkMode, searchMode: searchMode, previousData: depositData, blocked: blocked, onChange: handleTokenChange, setSearchMode: setSearchMode, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)(Slippage_Slippage, { blocked: blocked, slippage: slippage, setSlippage: setSlippage })] }), executionStep === undefined ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(ContinueButton, { disabled: depositData?.amount <= 0 || !hasEnoughBalance, handleDeposit: handleDeposit, darkMode: darkMode }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessage, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints })] }) };/* harmony default export */ const Deposit_DepositPools = (DepositPools);
        ;// ./src/contracts/Camelot/getDepositAmount.ts
        const getDepositAmount = async (pos, token0Address, amountToken0Address) => { const GAMMA_CONTRACT = "0x1f7792eD527A399159583730017cdB5003D57f4F"; const web3 = contracts_web3("arbitrum"); const gammaContract = new web3.eth.Contract(abis_GENERIC_ABIS.gammaContractAbi, GAMMA_CONTRACT); const depositAmount = await gammaContract.methods.getDepositAmount(pos, token0Address, amountToken0Address.toString()).call(); const { amountStart, amountEnd } = depositAmount; return { amountStart: BigInt(amountStart), amountEnd: BigInt(amountEnd) } };/* harmony default export */ const Camelot_getDepositAmount = (getDepositAmount);
        ;// ./src/contracts/Camelot/addLiquidityCamelot.ts
        const addLiquidityCamelot = async (ParamsTxToken0, ParamsTxToken1, pos, nftPoolAddress, ethRealWeiAmount, userAddress, chainId) => { const swapData0 = ParamsTxToken0.data; const swapData1 = ParamsTxToken1.data; const amountInMin = [0, 0, 0, 0]; const lockDuration = 0; const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const estimatedGas = await swapsContract.methods.addLiquidityToCamelot(swapData0, swapData1, pos, amountInMin, nftPoolAddress, lockDuration).estimateGas({ from: userAddress, value: ethRealWeiAmount.toString() }); const increasedGasPrice = Number(estimatedGas) * 2; const sendSwapTx = await swapsContract.methods.addLiquidityToCamelot(swapData0, swapData1, pos, amountInMin, nftPoolAddress, lockDuration).send({ from: userAddress, gasPrice: ParamsTxToken0.gasPrice, gas: increasedGasPrice.toString(), value: ethRealWeiAmount.toString() }); return sendSwapTx };/* harmony default export */ const Camelot_addLiquidityCamelot = (addLiquidityCamelot);
        ;// ./src/components/Deposit/DepositCamelotPools.tsx
        const DepositCamelotPools = ({ darkMode = false, refreshAutoLayerPoints }) => { const { productAddress } = (0, dist/* useParams */.g)(); const { searchMode, executionStep, failExecutionStep, txHash, txPoints, isConnected, wallet, realWeiAmount, depositData, hasEnoughBalance, chainId, setDepositData, finishTransaction, handleSendError, handleApproveError, retrieveTokenInAdress, retrieveTxParams, changeExecutionStep, handleRetrieveTxParamsError, setSearchMode, setRealWeiAmount, handleTokenChange, slippage, setSlippage } = hooks_useDeposit({ refreshAutoLayerPoints }); const blocked = executionStep !== undefined && failExecutionStep === undefined; const thisPool = useSingleCamelotPool(productAddress); const handleDeposit = async () => { setSearchMode(false); const tokenInAddress = retrieveTokenInAdress(); changeExecutionStep(ExecutionSteps.notStarted); const token0Address = thisPool?.filteredTokens[0].address.toLowerCase(); const token1Address = thisPool?.filteredTokens[1].address.toLowerCase(); let txParamsToken0; let txParamsToken1; let ethRealAmountInWei = BigInt(0); let inputTokenAmountForSecondPoolToken = BigInt(0); let halfRealWeiAmount = BigInt(0); try { const token0Weight = Math.floor(thisPool.filteredTokens[0].weight * 100); halfRealWeiAmount = realWeiAmount * BigInt(token0Weight) / BigInt(100); const rateWithInput = await Paraswap_getParaswapRoute(tokenInAddress, token0Address, halfRealWeiAmount.toString(), chainId); const expectedAmountToken0 = BigInt(rateWithInput.destAmount); const { amountStart: expectedAmountSecondPoolToken } = await Camelot_getDepositAmount(productAddress, token0Address, expectedAmountToken0); const rateWithOutput = await Paraswap_getParaswapRoute(token1Address, tokenInAddress, expectedAmountSecondPoolToken.toString(), chainId); inputTokenAmountForSecondPoolToken = BigInt(rateWithOutput.destAmount); if (tokenInAddress === utils_tokenNameToAddress("ETH", chainId)) ethRealAmountInWei = halfRealWeiAmount + BigInt(rateWithOutput.destAmount); const paraswapRes0 = await retrieveTxParams(tokenInAddress, token0Address, halfRealWeiAmount.toString(), slippage); const paraswapRes1 = await retrieveTxParams(tokenInAddress, token1Address, inputTokenAmountForSecondPoolToken.toString(), slippage); txParamsToken0 = paraswapRes0.txParams; txParamsToken1 = paraswapRes1.txParams; changeExecutionStep(tokenInAddress !== utils_tokenNameToAddress("ETH", chainId) ? ExecutionSteps.gotRoute : ExecutionSteps.approvedToken) } catch (error) { handleRetrieveTxParamsError(error); return } try { if (tokenInAddress !== utils_tokenNameToAddress("ETH", chainId)) { const totalRealAmount = halfRealWeiAmount + inputTokenAmountForSecondPoolToken; await contracts_approveToken(tokenInAddress, totalRealAmount, wallet?.address, chainId); changeExecutionStep(ExecutionSteps.approvedToken) } } catch (error) { handleApproveError(error); return } let sendSwapTx; try { sendSwapTx = await Camelot_addLiquidityCamelot(txParamsToken0, txParamsToken1, productAddress, thisPool.nftAddress, ethRealAmountInWei, wallet?.address, chainId) } catch (error) { handleSendError(error); return } try { finishTransaction(sendSwapTx); changeExecutionStep(ExecutionSteps.sentToken) } catch (error) { console.error("Error getting transaction Points", error.message) } }; return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "deposit", className: darkMode ? "dark-theme" : "light-theme", children: !isConnected ?/*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: depositData, setDepositData: setDepositData, setSearchMode: setSearchMode }) :/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper-selector", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_TokenSelector, { darkMode: darkMode, searchMode: searchMode, previousData: depositData, blocked: blocked, onChange: handleTokenChange, setSearchMode: setSearchMode, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)(Slippage_Slippage, { blocked: blocked, slippage: slippage, setSlippage: setSlippage })] }), executionStep === undefined &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: !darkMode ? "continue-deposit light-theme" : "continue-deposit dark-theme", disabled: depositData?.amount <= 0 || !hasEnoughBalance, onClick: handleDeposit, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) }) }), executionStep !== undefined &&/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessage, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints })] }) }) };/* harmony default export */ const Deposit_DepositCamelotPools = (DepositCamelotPools);
        ;// ./src/components/DepositDialog/DepositDialog.tsx
        const DepositContainer = ({ darkMode, refreshAutoLayerPoints }) => { const { productName, productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const camelotPool = data_networkData(chainId)?.camelotPools?.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase())?.bptName; if (productName) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_Deposit, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }) } if (camelotPool) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_DepositCamelotPools, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_DepositPools, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }) }; const DepositDialog = ({ setIsDepositDialogOpen, refreshAutoLayerPoints, darkMode = false }) => { const { productName, productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const bptName = data_networkData(chainId)?.pools?.find(pool => pool.address.toLowerCase() === productAddress?.toLowerCase())?.bptName; const title = productName ?? bptName; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "deposit-dialog", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h3", { children: [" Restake ", title] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: () => setIsDepositDialogOpen(false), children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children: "Error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(DepositContainer, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }) }) })] }) };/* harmony default export */ const DepositDialog_DepositDialog = (DepositDialog);
        ;// ./src/static/vectors/swap-black.svg
        const swap_black_namespaceObject = __webpack_require__.p + "static/swap-black.ed2ce4c8fb716278ea7d.svg";
        ;// ./src/components/TokenSelector/SwapSelector.tsx
        const SwapSelector_MINIMUN_VALUE = 0; const SwapSelector = ({ previousData, onChange, searchMode = false, setSearchMode, blocked = true, darkMode = false, swapPreviewAmount, setRealWeiAmount }) => { const [search, setSearch] = (0, react.useState)(""); const { amount, outputCoin, inputCoin } = previousData; const setCoin = coin => { !!onChange && onChange({ ...previousData, outputCoin: coin }) }; const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const bptName = networkInfo?.pools?.find(pool => pool.address.toLowerCase() === inputCoin?.toLowerCase())?.bptName; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `swap-selector ${blocked ? "blocked" : ""} ${darkMode ? "dark-theme" : "light-theme"}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "selector-wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "token-selector-info", onClick: () => setSearchMode?.(false), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { className: "input-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children: !bptName ?/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "swap" }) :/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "token-selector.withdraw" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(BalanceButtons_BalanceButtons, { disabled: blocked, previousData: previousData, onChange: onChange, isSwap: true, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)("input", { readOnly: blocked, className: `amount-input ${("" + amount).length < 10 ? "big" : ""}`, disabled: amount < SwapSelector_MINIMUN_VALUE, type: "number", inputMode: "decimal", onFocus: () => setSearchMode?.(false), onBlur: () => { const weiAmount = web3/* default */.A.utils.toWei(amount.toString(), "ether"); setRealWeiAmount?.(BigInt(weiAmount)) }, onChange: e => { e.preventDefault(); const value = e.target.value; const decimals = value.split(",")[1]; if (decimals && decimals.length > 6) return; onChange({ ...previousData, amount: +e.target.value }) }, placeholder: "0", value: amount, min: SwapSelector_MINIMUN_VALUE, step: "any" })] }), !bptName ?/*#__PURE__*/(0, jsx_runtime.jsxs)("h1", { className: inputCoin?.length > 4 ? inputCoin?.length > 6 ? "micro" : "mini" : "", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: inputCoin, src: getTokenImage(inputCoin) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "input-coin", children: bptName || inputCoin })] }) :/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { className: inputCoin?.length > 6 ? "super-micro" : "micro", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "input-coin", children: bptName || inputCoin }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: swap_black_namespaceObject, alt: "swap icon", className: "swap-icon" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "token-selector-info", onClick: () => setSearchMode?.(false), children: [swapPreviewAmount ?/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { className: "input-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "token-selector.preview" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "preview-amount", children: swapPreviewAmount })] }) :/*#__PURE__*/(0, jsx_runtime.jsx)("label", { className: "input-container" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("h1", { className: outputCoin?.length > 4 ? outputCoin?.length > 6 ? "micro" : "mini" : "", onClick: e => { e.stopPropagation(); if (!blocked) { setSearchMode?.(!searchMode) } }, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { title: outputCoin, src: getTokenImage(outputCoin) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: outputCoin || networkInfo.tokens[0].id }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `icon icon-angle_${searchMode ? "right" : "down"}` })] })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: `token-selector-select ${searchMode ? "open" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSearch_TokenSearch, { search: search, setSearch: setSearch }),/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "token-selector-list-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { className: "token-selector-list", onClick: () => setSearchMode?.(false), children:/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error-loading-tokens-balance" }) }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children: !!onChange &&/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelectorList_TokenSelectorList, { coins: networkInfo.tokens, search: search, outputCoin: outputCoin, setCoin: setCoin, inputCoin: inputCoin }) }) }) }) })] })] }) };/* harmony default export */ const TokenSelector_SwapSelector = (SwapSelector);
        ;// ./src/components/Swap/Swap.tsx
        const Swap = ({ darkMode = false, refreshAutoLayerPoints }) => { const { productName } = (0, dist/* useParams */.g)(); const [priceRoute, setPriceRoute] = (0, react.useState)(undefined); const [swapOutputPreviewAmount, setSwapOutputPreviewAmount] = (0, react.useState)(undefined); const { networkName: network } = hooks_useNetworkFromRoute(); const initialTokenSymbol = network === "binance" ? "BNB" : "ETH"; const { searchMode, setSearchMode, executionStep, setExecutionStep, failExecutionStep, setFailExecutionStep, txHash, setTxHash, txPoints, setTxPoints, data: swapData, setData: setSwapData, realWeiAmount, setRealWeiAmount, wallet, isConnected, chainId, slippage, setSlippage } = useCommonDeposit({ outputCoin: initialTokenSymbol, amount: 0, inputCoin: productName }); const hasEnoughBalance = hooks_useEnoughBalance(realWeiAmount, swapData?.inputCoin); const blocked = executionStep !== undefined && failExecutionStep === undefined; (0, react.useEffect)(() => { setSwapOutputPreviewAmount(undefined); setPriceRoute(undefined); const estimateSwap = setTimeout(async () => { const priceRoute = await Paraswap_getParaswapRoute(swapData.inputCoin, swapData.outputCoin, realWeiAmount.toString(), chainId); setPriceRoute(priceRoute); const outputEtherAmount = (parseFloat(priceRoute.destAmount) / 10 ** priceRoute.destDecimals).toFixed(6); setSwapOutputPreviewAmount(outputEtherAmount) }, 1200); return () => clearTimeout(estimateSwap) }, [chainId, realWeiAmount, swapData]); const handleChange = data => { if (executionStep || failExecutionStep) { setExecutionStep(undefined); setFailExecutionStep(undefined) } setSwapData(data) }; const handleSwap = async () => { setSearchMode(false); setExecutionStep(ExecutionSteps.notStarted); let txParams; try { txParams = await Paraswap_buildParaswapTx(priceRoute, swapData.inputCoin, swapData.outputCoin, realWeiAmount.toString(), chainId, slippage); setExecutionStep(ExecutionSteps.gotRoute) } catch (error) { console.error("Error getting swap info", error.message); setFailExecutionStep(FailExecutionSteps.failGotRoute); return } try { await contracts_approveToken(swapData.inputCoin, realWeiAmount, wallet?.address, chainId); setExecutionStep(ExecutionSteps.approvedToken) } catch (error) { console.error("Error approving token", error.message); setFailExecutionStep(FailExecutionSteps.failApprovedToken); return } let sendSwapTx; try { sendSwapTx = await contracts_sendSwapTransaction(txParams, swapData.outputCoin, realWeiAmount.toString(), wallet?.address, chainId) } catch (error) { console.error("Error sending swap transaction", error.message); setFailExecutionStep(FailExecutionSteps.failSentToken); return } try { const { points, transactionHash } = getAutolayerPointsAfterTx(sendSwapTx, wallet?.address, false, utils_tokenNameToAddress(swapData.outputCoin, chainId)); setExecutionStep(ExecutionSteps.sentToken); setTxHash(transactionHash); setTxPoints(points); refreshAutoLayerPoints() } catch (error) { console.error("Error getting transaction Points", error.message) } }; if (!isConnected) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: swapData, setDepositData: setSwapData, setSearchMode: setSearchMode }) } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "swap", className: darkMode ? "dark-theme" : "light-theme", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper-selector", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_SwapSelector, { darkMode: darkMode, searchMode: searchMode, previousData: swapData, blocked: blocked, onChange: handleChange, setSearchMode: setSearchMode, swapPreviewAmount: swapOutputPreviewAmount, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)(Slippage_Slippage, { blocked: blocked, slippage: slippage, setSlippage: setSlippage })] }), executionStep === undefined ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(ContinueButton, { disabled: swapData?.amount <= 0 || !hasEnoughBalance || !priceRoute, handleDeposit: handleSwap, darkMode: darkMode }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessage, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints })] }) };/* harmony default export */ const Swap_Swap = (Swap);
        ;// ./src/contracts/removeLiquidityBalancerPool.ts
        const removeLiquidityBalancerPool = async (pool, bptWeiAmount, userAddress, bptAddress, chainId) => { const gasPrice = await web3/* default */.A.eth.getGasPrice(); const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const poolId = pool.id.toLowerCase(); const poolTokensAddresses = pool?.filteredTokens.map(token => token.address.toLowerCase()); const poolTokensWithBptAddresses = pool.tokens.map(token => token.address.toLowerCase()); poolTokensAddresses.sort((a, b) => Number(a) - Number(b)); poolTokensWithBptAddresses.sort((a, b) => Number(a) - Number(b)); const amountMin = poolTokensWithBptAddresses.map(() => 0); const poolTokenOutputAddress = poolTokensAddresses[0]; const estimatedGas = await swapsContract.methods.removeLiquidityFromBalancer(poolId, bptAddress, poolTokenOutputAddress, poolTokensWithBptAddresses, amountMin, bptWeiAmount).estimateGas({ from: userAddress }); const increasedGasPrice = Number(estimatedGas) * 2; const removeLiquidityTx = await swapsContract.methods.removeLiquidityFromBalancer(poolId, bptAddress, poolTokenOutputAddress, poolTokensWithBptAddresses, amountMin, bptWeiAmount).send({ from: userAddress, gasPrice: gasPrice.toString(), gas: increasedGasPrice.toString() }); const txLogs = removeLiquidityTx.logs; const txLogsArray = Object.values(txLogs); const lastTransferEvent = txLogs[txLogsArray?.length - 1]; const hexAmountWei = lastTransferEvent?.data; const amountWei = web3/* default */.A.utils.hexToNumberString(hexAmountWei); const amountEth = await getEtherNumberAmount(poolTokenOutputAddress, amountWei, chainId); const transactionHash = removeLiquidityTx.transactionHash; return { transactionHash, amountWei, amountEth } };/* harmony default export */ const contracts_removeLiquidityBalancerPool = (removeLiquidityBalancerPool);
        ;// ./src/components/Deposit/DepositStepMessage/DepositStepMessageForPoolsWithdrawal.tsx
        const DepositStepMessageForPoolsWithdrawal = ({ failExecutionStep, executionStep, darkMode = false, txHash, txPoints, avoidSwap, withdrawalAmount, camelotLpName }) => { const messages = createMessageListForPoolsWithdrawal(failExecutionStep, executionStep); let filteredMessages = []; if (avoidSwap && executionStep === RemoveLiquiditySteps.sendBptLiquidity) { filteredMessages = [messages[0], messages[1]] } else { filteredMessages = messages } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `deposit-step-list ${darkMode ? "dark-theme" : "light-theme"}`, children: [filteredMessages?.map((message, index) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [message[1] === "done" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle done" }), failExecutionStep && message[1] === "fail" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }), failExecutionStep && message[1] === "running" &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }), !failExecutionStep && message[1] === "running" &&/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: `deposit-step-${message[0]}.${message[1]}` }), index === 0 || index === 1 ? " (1 / 2)" : " (2 / 2) "] })] }, index) }), txHash &&/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_ScanLinkMessage, { txHash: txHash }), txHash &&/*#__PURE__*/(0, jsx_runtime.jsx)("p", { className: "funds-wallet", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "funds-wallet" }) }), withdrawalAmount && withdrawalAmount?.token0 && withdrawalAmount?.token1 &&/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "amount-withdraw", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [parseFloat(withdrawalAmount?.token0).toFixed(6), " ",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: camelotLpName.split("-")[0] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [parseFloat(withdrawalAmount?.token1).toFixed(6), " ",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: camelotLpName.split("-")[1] })] })] }), txHash && txPoints && parseFloat(txPoints) > 0 &&/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("p", { className: "funds-wallet", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "deposit.tx-points-earned" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "tx-points", children: [parseFloat(txPoints).toFixed(4), " ",/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "dashboard.autolayer-points" })] })] })] }) };/* harmony default export */ const DepositStepMessage_DepositStepMessageForPoolsWithdrawal = (DepositStepMessageForPoolsWithdrawal);
        ;// ./src/components/Swap/swapHelper.ts
        const calculatePoolTokenOutputAmount = (thisPool, coingeckoData, amount, poolTokenAddress, chainId) => { const bptPrice = parseFloat(thisPool.liquidity) / parseFloat(thisPool.totalShares); const bptUsdValue = bptPrice * amount; const networkInfo = data_networkData(chainId); const poolTokenSymbol = networkInfo.tokens.find(token => token.address.toLowerCase() === poolTokenAddress.toLowerCase())?.id; const outputTokenPrice = coingeckoData.find(token => token.symbol.toLowerCase() === poolTokenSymbol.toLowerCase())?.current_price; const outputPoolTokenAmount = bptUsdValue / outputTokenPrice; return outputPoolTokenAmount };
        ;// ./src/components/Swap/SwapPools.tsx
        const SwapPools = ({ darkMode = false, refreshAutoLayerPoints }) => { const { productAddress } = (0, dist/* useParams */.g)(); const [avoidSwap, setAvoidSwap] = (0, react.useState)(false); const [swapPreviewAmount, setSwapPreviewAmount] = (0, react.useState)("0"); const isConnected = hooks_useIsConnected(); const { searchMode, setSearchMode, txHash, setTxHash, txPoints, setTxPoints, executionStep, failExecutionStep, setExecutionStep, setFailExecutionStep, realWeiAmount, setRealWeiAmount, data: swapData, setData: setSwapData, wallet, chainId, slippage, setSlippage } = useCommonDeposit({ outputCoin: "USDT", amount: 0, inputCoin: productAddress }); const blocked = executionStep !== undefined && failExecutionStep === undefined; const thisPool = useSinglePool(productAddress); const poolTokensAddress = thisPool.filteredTokens.map(token => token.address); poolTokensAddress.sort((a, b) => Number(a) - Number(b)); const hasEnoughBalance = hooks_useEnoughBalance(realWeiAmount, swapData?.inputCoin); const coingeckoData = hooks_useCoingecko(); (0, react.useEffect)(() => { const calculateSwapPreview = setTimeout(async () => { try { if (swapData.amount <= 0) return; const outputPoolTokenAmount = calculatePoolTokenOutputAmount(thisPool, coingeckoData, swapData.amount, poolTokensAddress[0], chainId); const weiAmount = await getWeiNumberAmountDependOnDecimals(poolTokensAddress[0], +outputPoolTokenAmount.toFixed(5), chainId); const priceRoute = await Paraswap_getParaswapRoute(poolTokensAddress[0], swapData.outputCoin, weiAmount, chainId); const outputTokenAmountEth = parseFloat(priceRoute.destAmount) / 10 ** priceRoute.destDecimals; setSwapPreviewAmount(outputTokenAmountEth?.toFixed(5)) } catch (error) { console.error("Error calculating swap preview", error.message); setSwapPreviewAmount("0") } }, 900); return () => clearTimeout(calculateSwapPreview) }, [thisPool, swapData, coingeckoData, poolTokensAddress, chainId]); const handleChange = data => { if (executionStep || failExecutionStep) { setExecutionStep(undefined); setFailExecutionStep(undefined) } setSwapData(data) }; const handleSwap = async () => { if (poolTokensAddress[0]?.toLowerCase() === utils_tokenNameToAddress(swapData?.outputCoin, chainId)?.toLowerCase(), chainId) { setAvoidSwap(true) } setSearchMode(false); setExecutionStep(RemoveLiquiditySteps.notStarted); try { await contracts_approveToken(swapData.inputCoin, realWeiAmount, wallet?.address, chainId); setExecutionStep(RemoveLiquiditySteps.approveBpt) } catch (error) { console.error("Error approving token", error.message); setFailExecutionStep(FailRemoveLiquiditySteps.failBptApprove); return } let weiReceivedAmount; try { const { transactionHash, amountWei } = await contracts_removeLiquidityBalancerPool(thisPool, realWeiAmount.toString(), wallet?.address, productAddress, chainId); weiReceivedAmount = amountWei; setExecutionStep(RemoveLiquiditySteps.sendBptLiquidity); if (poolTokensAddress[0]?.toLowerCase() === utils_tokenNameToAddress(swapData?.outputCoin, chainId)?.toLowerCase()) { setTxHash(transactionHash) } } catch (error) { console.error("Error sending swap transaction", error.message); setFailExecutionStep(FailRemoveLiquiditySteps.failSendBptLiquidity); return } if (poolTokensAddress[0]?.toLowerCase() === utils_tokenNameToAddress(swapData?.outputCoin, chainId)?.toLowerCase()) { return } let priceRoute; try { priceRoute = await Paraswap_getParaswapRoute(poolTokensAddress[0], swapData.outputCoin, weiReceivedAmount, chainId) } catch (error) { console.error("Error getting swap info", error.message) } let txParams; try { txParams = await Paraswap_buildParaswapTx(priceRoute, poolTokensAddress[0], swapData.outputCoin, weiReceivedAmount, chainId, slippage) } catch (error) { console.error("Error getting swap info", error.message); setFailExecutionStep(FailRemoveLiquiditySteps.failApproveToken); return } try { await contracts_approveToken(poolTokensAddress[0], BigInt(weiReceivedAmount), wallet?.address, chainId); setExecutionStep(RemoveLiquiditySteps.approveToken) } catch (error) { console.error("Error approving token", error.message); setFailExecutionStep(FailRemoveLiquiditySteps.failApproveToken); return } let sendSwapTx; try { sendSwapTx = await contracts_sendSwapTransaction(txParams, swapData.outputCoin, weiReceivedAmount, wallet?.address, chainId) } catch (error) { console.error("Error sending swap transaction", error.message); setFailExecutionStep(FailRemoveLiquiditySteps.failSendToken); return } try { const { points, transactionHash } = getAutolayerPointsAfterTx(sendSwapTx, wallet?.address, false, utils_tokenNameToAddress(swapData.outputCoin, chainId)); setExecutionStep(RemoveLiquiditySteps.sendToken); setTxHash(transactionHash); setTxPoints(points); refreshAutoLayerPoints() } catch (error) { console.error("Error getting transaction Points", error.message) } }; if (!isConnected) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: swapData, setDepositData: setSwapData, setSearchMode: setSearchMode }) } return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "swap", className: darkMode ? "dark-theme" : "light-theme", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper-selector", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_SwapSelector, { darkMode: darkMode, searchMode: searchMode, previousData: swapData, blocked: blocked, onChange: handleChange, setSearchMode: setSearchMode, swapPreviewAmount: swapPreviewAmount, setRealWeiAmount: setRealWeiAmount }),/*#__PURE__*/(0, jsx_runtime.jsx)(Slippage_Slippage, { blocked: blocked, slippage: slippage, setSlippage: setSlippage })] }), executionStep === undefined ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(ContinueButton, { disabled: swapData?.amount <= 0 || !hasEnoughBalance, handleDeposit: handleSwap, darkMode: darkMode }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessageForPoolsWithdrawal, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints, avoidSwap: avoidSwap })] }) };/* harmony default export */ const Swap_SwapPools = (SwapPools);
        ;// ./src/components/TokenSelector/NftCamelotSelector.tsx
        const NftCamelotSelector_MINIMUN_VALUE = 0; const NftCamelotSelector = ({ previousData, onChange, searchMode = false, setSearchMode, setRealWeiAmount, blocked = true, darkMode = false }) => { const { amount, outputCoin } = previousData; const inputTokenDecimals = "18"; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `token-selector ${blocked ? "blocked" : ""} ${darkMode ? "dark-theme" : "light-theme"}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "token-selector-info", onClick: () => setSearchMode?.(false), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { className: "input-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "token-selector.withdraw" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("input", { readOnly: blocked, className: `amount-input ${("" + amount).length < 9 ? "big" : ""}`, disabled: amount < NftCamelotSelector_MINIMUN_VALUE, type: "number", inputMode: "decimal", onFocus: () => { setSearchMode?.(false) }, onBlur: () => { const factor = Math.pow(10, Number(inputTokenDecimals)); setRealWeiAmount?.(BigInt(amount * factor)) }, onChange: e => { e.preventDefault(); const value = e.target.value; const decimals = value.split(",")[1]; if (decimals && decimals.length > 6) return; onChange({ ...previousData, amount: +e.target.value }) }, placeholder: "0", value: amount === 0 || !amount ? 0 : amount, min: NftCamelotSelector_MINIMUN_VALUE, step: "any" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { className: outputCoin?.length > 4 ? outputCoin?.length > 6 ? "micro" : "mini" : "", onClick: e => { e.stopPropagation(); if (!blocked) { setSearchMode?.(!searchMode) } }, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [" Position #", outputCoin] }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(BalanceButtons_BalanceButtons, { disabled: blocked, previousData: previousData, onChange: onChange, setRealWeiAmount: setRealWeiAmount, isSwap: true })] }) };/* harmony default export */ const TokenSelector_NftCamelotSelector = (NftCamelotSelector);
        ;// ./src/contracts/Camelot/withdrawFromCamelotPosition.ts
        const withdrawFromCamelotPosition = async (nftPoolAddress, tokenId, amountToWithdraw, userAddress, chainId) => { const gasPrice = (await web3/* default */.A.eth.getGasPrice()).toString(); const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const tx = await swapsContract.methods.withdrawFromCamelotPosition(nftPoolAddress, tokenId, amountToWithdraw).send({ from: userAddress, gasPrice }); return tx };/* harmony default export */ const Camelot_withdrawFromCamelotPosition = (withdrawFromCamelotPosition); const unbindCamelotPosition = async (pos, amountToWithdraw, userAddress, chainId) => { const minAmounts = [0, 0, 0, 0]; const gasPrice = (await web3/* default */.A.eth.getGasPrice()).toString(); const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const swapsContract = new web3/* default */.A.eth.Contract(AUTOLAYER_ABIS[chainId.toLowerCase()].swapContract, swapsContractAddress.toLowerCase()); const tx = await swapsContract.methods.unbindCamelotPosition(pos, amountToWithdraw, minAmounts).send({ from: userAddress, gasPrice }); return tx };
        ;// ./src/contracts/Camelot/nftApprove.ts
        const nftCamelotApprove = async (nftAddress, tokenId, userAddress, chainId) => { const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const nftContract = new web3/* default */.A.eth.Contract(abis_GENERIC_ABIS.nftPoolCamelotAbi, nftAddress); const gasPrice = await web3/* default */.A.eth.getGasPrice(); const tx = await nftContract.methods.approve(swapsContractAddress, tokenId).send({ from: userAddress, gasPrice: gasPrice.toString() }); return tx };/* harmony default export */ const nftApprove = (nftCamelotApprove); const lpCamelotApprove = async (pos, amount, userAddress, chainId) => { const swapsContractAddress = SWAPS_CONTRACT[chainId.toLowerCase()]; const lpAddress = new web3/* default */.A.eth.Contract(abis_GENERIC_ABIS.camelotLpAbi, pos); const gasPrice = await web3/* default */.A.eth.getGasPrice(); const tx = await lpAddress.methods.approve(swapsContractAddress, amount).send({ from: userAddress, gasPrice: gasPrice.toString() }); return tx };
        ;// ./src/components/TokenSelector/CamelotPositionsList/CamelotPositionItem.tsx
        const CamelotPositionItem = ({ camelotPosition, onClick, thisPool }) => { const { id, balance, usdValue } = camelotPosition; return /*#__PURE__*/(0, jsx_runtime.jsxs)("li", { onClick: () => onClick(id.toString(), balance, usdValue), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "position-id", children: ["Position #", id] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "usd-value", children: [" $", usdValue.toFixed(2), " "] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [balance > 0 &&/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "usd-value", children: `${compactNumbers(balance, 10)}` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "lp-name", children: thisPool.bptName })] })] })] }) };/* harmony default export */ const CamelotPositionsList_CamelotPositionItem = (CamelotPositionItem);
        ;// ./src/components/TokenSelector/CamelotPositionsList/CamelotPositionsList.tsx
        const CamelotPositionsList = ({ thisPool, onChange, previousData, setSeletedPositionData, refreshKey }) => { const { productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const nftPoolsAddress = networkInfo.camelotPools.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase())?.nftAddress; const nftsIds = useGetNftIdsCamelot(refreshKey, nftPoolsAddress); const idsBalances = useGetLpAmountForNft(refreshKey, nftPoolsAddress, nftsIds); const completeInfo = nftsIds.map((id, index) => ({ id, balance: idsBalances[index] })); const coingeckoData = hooks_useCoingecko(); const lpPrice = hooks_usePromise(getLpUSDPriceForNftPosition, thisPool.pos, coingeckoData); const completeInfoWithUsdValue = completeInfo.map(c => ({ ...c, usdValue: c.balance * lpPrice })); const setCoin = (coin, balance, usdValue) => { !!onChange && onChange({ ...previousData, outputCoin: coin }); setSeletedPositionData({ balance, usdValue }) }; return /*#__PURE__*/(0, jsx_runtime.jsx)("ul", { id: "camelot-position-list", children: completeInfoWithUsdValue.map(c =>/*#__PURE__*/(0, jsx_runtime.jsx)(CamelotPositionsList_CamelotPositionItem, { camelotPosition: c, onClick: setCoin, thisPool: thisPool }, c.id)) }) };/* harmony default export */ const CamelotPositionsList_CamelotPositionsList = (CamelotPositionsList);
        ;// ./src/static/images/iconsSmall/arrow.svg
        const arrow_namespaceObject = __webpack_require__.p + "static/arrow.e6ec89cbecc2d4b38c81.svg";
        ;// ./src/contracts/Camelot/decodedWithdrawalAmount.ts
        const decodedWithdrawalAmount = tx => { try { const withdrawTopic = "0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f"; const logs = tx.logs; const withdrawLog = logs.find(log => log.topics[0] === withdrawTopic); const data = withdrawLog.data; const web3 = contracts_web3("arbitrum"); const decodedData = web3.eth.abi.decodeParameters([{ type: "uint256", name: "shares" }, { type: "uint256", name: "amount0" }, { type: "uint256", name: "amount1" }], data); const token0Amount = web3.utils.fromWei(decodedData.amount0, "ether"); const token1Amount = web3.utils.fromWei(decodedData.amount1, "ether"); return { token0Amount, token1Amount } } catch (error) { console.error("Error decoding withdrawal amount", error); return { token0Amount: undefined, token1Amount: undefined } } };/* harmony default export */ const Camelot_decodedWithdrawalAmount = (decodedWithdrawalAmount);
        ;// ./src/components/Swap/WithdrawCamelotPools.tsx
        const WithdrawCamelotPools = ({ darkMode = false, refreshAutoLayerPoints, refreshKey }) => { const { productAddress } = (0, dist/* useParams */.g)(); const isConnected = hooks_useIsConnected(); const { searchMode, setSearchMode, txHash, txPoints, executionStep, failExecutionStep, setExecutionStep, setFailExecutionStep, setTxHash, realWeiAmount, setRealWeiAmount, data: swapData, setData: setSwapData, wallet, chainId } = useCommonDeposit({ outputCoin: "", amount: 0, inputCoin: productAddress }); const [showPositions, setShowPositions] = (0, react.useState)(false); const [selectedPositionData, setSelectedPositionData] = (0, react.useState)({ balance: 0, usdValue: 0 }); const [withdralAmount, setWithdrawalAmount] = (0, react.useState)({ token0: undefined, token1: undefined }); const thisPool = useSingleCamelotPool(productAddress); const hasEnoughBalance = useEnoughBalanceCamelotPools(realWeiAmount, swapData.outputCoin, thisPool?.nftAddress); const handleChange = data => { if (executionStep || failExecutionStep) { setExecutionStep(undefined); setFailExecutionStep(undefined) } setSwapData(data) }; const handleSwap = async () => { setExecutionStep(RemoveLiquiditySteps.notStarted); try { await nftApprove(thisPool.nftAddress, swapData?.outputCoin, wallet?.address, chainId); setExecutionStep(RemoveLiquiditySteps.approveBpt) } catch (error) { setFailExecutionStep(FailRemoveLiquiditySteps.failBptApprove); console.error("Error approving NFT", error); return } try { await Camelot_withdrawFromCamelotPosition(thisPool.nftAddress, swapData?.outputCoin, realWeiAmount.toString(), wallet?.address, chainId); setExecutionStep(RemoveLiquiditySteps.sendBptLiquidity) } catch (error) { setFailExecutionStep(FailRemoveLiquiditySteps.failSendBptLiquidity); console.error("Error withdrawing from Camelot Position", error); return } try { await lpCamelotApprove(thisPool.pos, realWeiAmount.toString(), wallet?.address, chainId); setExecutionStep(RemoveLiquiditySteps.approveToken) } catch (error) { setFailExecutionStep(FailRemoveLiquiditySteps.failApproveToken); console.error("Error approving Camelot LP", error); return } try { const tx = await unbindCamelotPosition(thisPool.pos, realWeiAmount.toString(), wallet?.address, chainId); refreshAutoLayerPoints(); const { token0Amount, token1Amount } = Camelot_decodedWithdrawalAmount(tx); setWithdrawalAmount({ token0: token0Amount, token1: token1Amount }); setTxHash(tx.transactionHash); setExecutionStep(RemoveLiquiditySteps.sendToken) } catch (error) { setFailExecutionStep(FailRemoveLiquiditySteps.failSendToken); console.error("Error unbinding Camelot LP", error) } }; if (!isConnected) { return /*#__PURE__*/(0, jsx_runtime.jsx)(Deposit_NotConnectedDeposit, { darkMode: darkMode, searchMode: searchMode, depositData: swapData, setDepositData: setSwapData, setSearchMode: setSearchMode }) } return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "swap", className: darkMode ? "dark-theme" : "light-theme", children: swapData.outputCoin === "" ?/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "camelot-positions", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: () => setShowPositions(true), className: "select-position-btn", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "select-position" }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: arrow_namespaceObject, alt: "arrow down", className: showPositions ? "" : "rotate" })] }), showPositions &&/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(CamelotPositionsList_CamelotPositionsList, { thisPool: thisPool, onChange: handleChange, setSeletedPositionData: setSelectedPositionData, refreshKey: refreshKey }) }) })] }) :/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenSelector_NftCamelotSelector, { darkMode: darkMode, searchMode: searchMode, previousData: swapData, blocked: false, onChange: handleChange, setSearchMode: setSearchMode, setRealWeiAmount: setRealWeiAmount }), executionStep === undefined ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(ContinueButton, { disabled: swapData?.amount <= 0 || !hasEnoughBalance || realWeiAmount === BigInt(0), handleDeposit: handleSwap, darkMode: darkMode, selectedPositionData: selectedPositionData, bptName: thisPool.bptName }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(DepositStepMessage_DepositStepMessageForPoolsWithdrawal, { executionStep: executionStep, failExecutionStep: failExecutionStep, txHash: txHash, txPoints: txPoints, avoidSwap: false, withdrawalAmount: withdralAmount, camelotLpName: thisPool.bptName })] }) }) };/* harmony default export */ const Swap_WithdrawCamelotPools = (WithdrawCamelotPools);
        ;// ./src/components/SwapDialog/SwapDialog.tsx
        const SwapDialog = ({ setIsSwapDialogOpen, darkMode = false, refreshAutoLayerPoints, refreshKey }) => { const { productName } = (0, dist/* useParams */.g)(); const { productAddress } = (0, dist/* useParams */.g)(); const { chainId } = hooks_useNetworkFromRoute(); const networkInfo = data_networkData(chainId); const bptName = networkInfo?.pools?.find(pool => pool.address.toLowerCase() === productAddress?.toLowerCase())?.bptName; const camelotPool = networkInfo?.camelotPools?.find(pool => pool.pos.toLowerCase() === productAddress?.toLowerCase())?.bptName; const title = productName ?? bptName; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "swap-dialog", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [productName ?/*#__PURE__*/(0, jsx_runtime.jsxs)("h3", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "swap" }), " ", title] }) :/*#__PURE__*/(0, jsx_runtime.jsxs)("h3", { children: [" ",/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "token-selector.withdraw" }), " "] }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: () => setIsSwapDialogOpen(false), children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close" }) })] }), productName &&/*#__PURE__*/(0, jsx_runtime.jsx)(Swap_Swap, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }), bptName && productAddress &&/*#__PURE__*/(0, jsx_runtime.jsx)(Swap_SwapPools, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints }), camelotPool && productAddress &&/*#__PURE__*/(0, jsx_runtime.jsx)(Swap_WithdrawCamelotPools, { darkMode: darkMode, refreshAutoLayerPoints: refreshAutoLayerPoints, refreshKey: refreshKey })] }) };/* harmony default export */ const SwapDialog_SwapDialog = (SwapDialog);
        ;// ./src/routes/ProductInfo/DefiInfo.tsx
        const DefiInfo = () => { const { productAddress } = (0, dist/* useParams */.g)(); const [isSwapDialogOpen, setIsSwapDialogOpen] = (0, react.useState)(false); const [isDepositDialogOpen, setIsDepositDialogOpen] = (0, react.useState)(false); const [refreshKey, setRefreshKey] = (0, react.useState)(0); const defiBalancerInfo = useSinglePool(productAddress); const defiCamelotInfo = useSingleCamelotPool(productAddress); const defiInfo = defiBalancerInfo || defiCamelotInfo; const handleRefreshKey = () => setRefreshKey(s => s + 1); const location = (0, dist/* useLocation */.zy)(); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ProductMeta, { url: true ? window.location.href : 0, description: utils_text.firstPhrase(defiInfo?.opengraph), image: defiInfo?.image, title: `${defiInfo?.name} | Autolayer` }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "defi-info", className: "product-info page", children: [isDepositDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(DepositDialog_DepositDialog, { setIsDepositDialogOpen: setIsDepositDialogOpen, refreshAutoLayerPoints: handleRefreshKey }), isSwapDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(SwapDialog_SwapDialog, { setIsSwapDialogOpen: setIsSwapDialogOpen, refreshAutoLayerPoints: handleRefreshKey, refreshKey: refreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(Header_HeaderProductInfo, { productInfo: defiInfo }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "grid-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(LeftInfo_LeftDefiInfo, { refreshKey: refreshKey, filteredTokens: defiInfo?.filteredTokens }),/*#__PURE__*/(0, jsx_runtime.jsx)(MiddleInfo_MiddleDefiInfo, { productInfo: defiInfo }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfoButtons_ProductInfoButtons, { refresher: refreshKey, darkMode: false, setIsSwapDialogOpen: setIsSwapDialogOpen, setIsDepositDialogOpen: setIsDepositDialogOpen }, refreshKey) }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsx)(BannerInfo_BannerInfo, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) }; const DefiInfoWrapper = () => { const { productAddress } = (0, dist/* useParams */.g)(); const isDefiBalancer = Arbitrum_ArbitrumData.pools.some(p => p.address.toLowerCase() === productAddress.toLowerCase()); const isDefiCamelot = Arbitrum_ArbitrumData.camelotPools.some(p => p.pos.toLowerCase() === productAddress.toLowerCase()); if (!isDefiBalancer && !isDefiCamelot) { return /*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Navigate */.C5, { to: "/defi-strategies" }) } return /*#__PURE__*/(0, jsx_runtime.jsx)(DefiInfo, {}) };/* harmony default export */ const ProductInfo_DefiInfo = (DefiInfoWrapper);
        ;// ./src/routes/ProductInfo/LeftInfo/LeftPointsTypes/EigenLayer/EigenLayerLeftPoint.tsx
        const productItems = { ezeth: "eigenLayer", rseth: "kelp", pufeth: "puffer", primeeth: "primestaked", unieth: "bedrock", ineth: "inception", eeth: "ether", weeth: "ether" }; const EigenLayerLeftPointsWrapper = () => { const { productName } = (0, dist/* useParams */.g)(); const type = productItems[productName]; if (!type) return null; return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "eigenLayer", useFetchPoints: productsPointsEigenLayer[type] }) };/* harmony default export */ const EigenLayerLeftPoint = (EigenLayerLeftPointsWrapper);
        ;// ./src/routes/ProductInfo/LeftInfo/BinaceNetworkNotice/BinaceNetworkNotice.tsx
        const BinaceNetworkNotice = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "binace-network-notice", children:/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "binace-network-notice" }) }) }) };/* harmony default export */ const BinaceNetworkNotice_BinaceNetworkNotice = (BinaceNetworkNotice);
        ;// ./src/components/Points/AssetInfo/LRTPoints/LrtPoints.tsx
        const LrtPoints_productItems = { ezeth: ["renzo"], pzeth: ["renzo", "mellow", "symbiotic"], swbtc: ["swbtc"], rseth: ["kelp"], pufeth: ["puffer"], rsweth: ["swell"], primeeth: ["primestaked"], unieth: ["bedrock"], ineth: ["inception"], eeth: ["ether"], weeth: ["ether"] }; function LRTPoints() { const { productName } = (0, dist/* useParams */.g)(); return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children: LrtPoints_productItems[productName].map(product =>/*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: product, useFetchPoints: productPointsLrt[product] }, product)) }) }
        ;// ./src/routes/ProductInfo/LeftInfo/LeftAssetInfo.tsx
        const LeftAssetInfo = ({ refreshKey, tokenInfo }) => { const { networkName } = (0, dist/* useParams */.g)(); const isBinaceNetwork = networkName === "binance"; const isLST = tokenInfo?.type === "LST"; const wallet = useWallet_useWallet(); if (false) { } if (wallet === null) return /*#__PURE__*/(0, jsx_runtime.jsx)(FallbackNoConnected_FallbackNoConnected, {}); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "left-asset-info", className: "left-product-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "default" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(LeftPointsTypes_ActualValueLeftPoint, { refreshKey: refreshKey }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "autoLayer" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfoPoints, { type: "autoLayer", useFetchPoints: useAutolayerPoints, refreshKey: refreshKey }) }) }), isBinaceNetwork &&/*#__PURE__*/(0, jsx_runtime.jsx)(BinaceNetworkNotice_BinaceNetworkNotice, {}), !isLST &&/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "eigenLayer" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(EigenLayerLeftPoint, {}) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: "error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(PointsBox_DefaultPointsBox, { type: tokenInfo?.id.toLocaleLowerCase() === "ezeth" ? "renzo" : "kelp" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(LRTPoints, {}) }) })] })] }) };/* harmony default export */ const LeftInfo_LeftAssetInfo = (LeftAssetInfo);
        ;// ./src/components/GenericPoints/RestakingRewards.tsx
        const RestakingRewards = ({ productName }) => { const tokensLst = hooks_useTokensLst(); const tokensLrst = hooks_useTokensLrst(); const tokens = [...tokensLst, ...tokensLrst]; const stakingRewards = tokens?.find(t => t?.id?.toLowerCase() === productName?.toLowerCase())?.apr; return /*#__PURE__*/(0, jsx_runtime.jsx)(GenericPoints_GenericPoints, { type: "left-point.restaking-rewards", points: +stakingRewards }) }; const RestakingRewardsWrapper = ({ productName }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(GenericPointsFallback, { type: "error-loading-data", pointsType: "left-point.restaking-rewards" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(GenericPointsFallback, { pointsType: "left-point.restaking-rewards" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(RestakingRewards, { productName: productName }) }) }) };/* harmony default export */ const GenericPoints_RestakingRewards = (RestakingRewardsWrapper);
        ;// ./src/components/Tooltip/Tooltip.tsx
        const Tooltip = ({ children, buttonComponent }) => { const [isOpen, setIsOpen] = (0, react.useState)(false); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `tooltip-container ${isOpen ? "tooltip-open" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { onClick: () => setIsOpen(!isOpen), children: buttonComponent ||/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "tooltip-button", children: "+" }) }), isOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "tooltip", children: children })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "veil", onClick: () => setIsOpen(false) })] }) };/* harmony default export */ const Tooltip_Tooltip = (Tooltip);
        // EXTERNAL MODULE: ./src/types/RiskTypes.ts
        var RiskTypes = __webpack_require__(32815);
        ;// ./src/routes/ProductInfo/MiddleInfo/RiskSection/RiskBox/TooltipItem/TooltipItem.tsx
        function TooltipItem({ protocol, data, riskType }) { const [expand, setExpand] = (0, react.useState)(false); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "toltip-item", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "top", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: riskType === RiskTypes/* RiskType */.G.Collateral ? getProtocolImage(protocol) : protocolsIcons[protocol], alt: `icon ${protocol}` }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: protocol }), data.splitedTvl.length > 0 ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "icon-wrapper", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `icon icon-angle_${expand ? "right" : "down"}`, role: "button", onClick: () => setExpand(!expand) }) }) : null] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "percentage", children: [Math.round(+data.percentageTvl * 100) / 100, "%"] })] }), expand ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "bottom", children:/*#__PURE__*/(0, jsx_runtime.jsx)("ul", { children: data.splitedTvl.map(({ network, percentageTvl }) =>/*#__PURE__*/(0, jsx_runtime.jsxs)("li", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { loading: "lazy", src: networkVectorsWhite[network], alt: network }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: utils_text.capitalize(network) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "percentage", children: [percentageTvl, "%"] })] }, network)) }) }) : null] }) }
        ;// ./src/routes/ProductInfo/MiddleInfo/RiskSection/RiskBox/TvlTooltip/TvlTooltip.tsx
        function TvlTooltip({ info, riskType }) { return /*#__PURE__*/(0, jsx_runtime.jsx)("ul", { id: "risk-box-tooltip", children: Object.entries(info).map(([protocol, data]) => !!data?.percentageTvl &&/*#__PURE__*/(0, jsx_runtime.jsx)("li", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(TooltipItem, { data: data, protocol: protocol, riskType: riskType }) }, protocol)) }) }
        ;// ./src/routes/ProductInfo/MiddleInfo/RiskSection/RiskBox/RiskBox.tsx
        function RiskBox({ info, riskType }) { const totalPercentage = Object.values(info).reduce((acc, obj) => acc + obj.percentageTvl, 0); return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { id: `risk-box-${riskType}`, className: `risk-box ${!totalPercentage ? "disabled" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "risk-box-left", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `risk-box.${riskType}` }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "risk-box-right", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "percetage", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("strong", { children: [totalPercentage > 0 ? Math.round(+totalPercentage * 100) / 100 : "0", "%"] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Tooltip_Tooltip, { children:/*#__PURE__*/(0, jsx_runtime.jsx)(TvlTooltip, { info: info, riskType: riskType }) })] })] }) }
        ;// ./src/hooks/useRiskForTokens.ts
        const useRiskForTokens = () => { const riskUrl = `${constants/* dataMicroserviceUrl */.dF}/risk-for-tokens`; const riskInfo = (0, index_esm/* useFetch */.st)(riskUrl); return riskInfo || [] };/* harmony default export */ const hooks_useRiskForTokens = (useRiskForTokens);
        ;// ./src/utils/risk.ts
        function groupItems(items) { return items.reduce((acc, item) => { if (!acc[item.protocol]) { acc[item.protocol] = { percentageTvl: 0, splitedTvl: [] } } acc[item.protocol].percentageTvl += item.percentageTvl; if (item.network) { acc[item.protocol].splitedTvl.push({ network: item.network, percentageTvl: item.percentageTvl }) } return acc }, {}) } function parseToInfoRisk(dexes) { return dexes.flatMap(liquidity => liquidity.info.map(info => ({ protocol: liquidity.protocol, percentageTvl: info.percentageTvl, network: info.network }))) } const riskUtils = { parseToInfoRisk, groupItems };/* harmony default export */ const utils_risk = (riskUtils);
        ;// ./src/routes/ProductInfo/MiddleInfo/RiskSection/RiskSection.tsx
        const RiskSection = () => { const { productName } = (0, dist/* useParams */.g)(); const risk = hooks_useRiskForTokens(); const data = risk.find(r => r.id === productName); const liquidityWithProtocolField = utils_risk.parseToInfoRisk(data?.liquidityInDexes || []); const liquidityGrouped = utils_risk.groupItems(liquidityWithProtocolField); const colateralGrouped = utils_risk.groupItems(data?.tvlAsCollateral || []); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "risk-section", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Risk Factor" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "risk-section-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(RiskBox, { riskType: RiskTypes/* RiskType */.G.Collateral, info: colateralGrouped }),/*#__PURE__*/(0, jsx_runtime.jsx)(RiskBox, { riskType: RiskTypes/* RiskType */.G.Dexes, info: liquidityGrouped })] })] }) };/* harmony default export */ const RiskSection_RiskSection = (RiskSection);
        ;// ./src/hooks/useAvsInfoForLRT.ts
        const useAvsInfoForLRT = () => { const route = "/avs-for-tokens"; const useAvsInfoForLRT = (0, index_esm/* useFetch */.st)(constants/* dataMicroserviceUrl */.dF + route); return useAvsInfoForLRT };/* harmony default export */ const hooks_useAvsInfoForLRT = (useAvsInfoForLRT);
        ;// ./src/routes/ProductInfo/MiddleInfo/AvsSection/AvsInfoBox/AvsInfoBox.tsx
        const AvsInfoBox = ({ avsInfo }) => { const lowerName = avsInfo.name.toLocaleLowerCase(); const extendedName = avsInfo.extendedName || avsInfo.name; const points = compactNumbers(+avsInfo.points, 2) + (compactNumbers(+avsInfo.points) !== "-" ? " Points" : ""); return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { id: `avs-info-box-${lowerName}`, className: "avs-info-box", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("header", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: avsInfo?.url, target: "_blank", rel: "noopener noreferrer", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "avs-image", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getAVSImage(lowerName), title: avsInfo.name, alt: `logo ${avsInfo.name}` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: extendedName })] }) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "cell", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "info-box.tvl" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [avsInfo.percentageDelegated, "%"] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "cell", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "avs-info-box.staked" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [compactNumbers(+avsInfo.staked, 2), " ETH"] })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "row", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "cell", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "avs-info-box.incentives" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: points })] }) })] }) };/* harmony default export */ const AvsInfoBox_AvsInfoBox = (AvsInfoBox);
        ;// ./src/data/avs/avsData.json
        const avsData_namespaceObject = /*#__PURE__*/JSON.parse('{"ezeth":[{"id":"eoracle","name":"eoracle","url":"https://www.eoracle.io/"},{"id":"eigenda","name":"EigenDA","url":"https://docs.eigenlayer.xyz/eigenda/overview/"},{"id":"altlayer","name":"AltLayer","url":"https://altlayer.io/"},{"id":"brevis","name":"Brevis coChain AVS","url":"https://brevis.network/"},{"id":"lagrange","name":"Lagrange","url":"https://www.lagrange.dev/"},{"id":"witness-chain","name":"Witness Chain","url":"https://www.witnesschain.com/"},{"id":"omni-network","name":"Omni Network","url":"https://omni.network/"},{"id":"automata","name":"Automata Multi-Prover","url":"https://www.ata.network/"},{"id":"openlayer","name":"OpenLayer","url":"https://www.openlayer.tech/"},{"id":"xterio","name":"Xterio Mach","url":"https://xter.io/"},{"id":"lagrange-zk","name":"Lagrange ZK Coprocessor","url":"https://www.lagrange.dev/"},{"id":"cyber","name":"Cyber via AltLayer","url":"https://cyber.co/"}],"rseth":[{"id":"cyber","name":"Cyber MACH (Powered by AltLayer)","url":"https://cyber.co/"},{"id":"lagrange-zk","name":"Lagrange ZK Prover Network","url":"https://www.lagrange.dev/"},{"id":"eoracle","name":"eoracle","url":"https://www.eoracle.io/"},{"id":"lagrange","name":"Lagrange State Committees","url":"https://www.lagrange.dev/"},{"id":"eigenda","name":"EigenDA","url":"https://docs.eigenlayer.xyz/eigenda/overview/"},{"id":"witness-chain","name":"Witness Chain","url":"https://www.witnesschain.com/"},{"id":"automata","name":"Automata Multi-Prover AVS","url":"https://www.ata.network/"},{"id":"hyperlane","name":"Hyperlane AVS","url":"https://docs.hyperlane.xyz/docs/protocol/economic-security/hyperlane-avs"},{"id":"openlayer","name":"OpenLayer","url":"https://www.openlayer.tech/"},{"id":"arpa","name":"ARPA Network","url":"https://www.arpanetwork.io/"},{"id":"brevis","name":"Brevis coChain AVS","url":"https://brevis.network/"}]}');
        ;// ./src/routes/ProductInfo/MiddleInfo/AvsSection/AvsSection.tsx
        const AvsSection = () => { const { productName } = (0, dist/* useParams */.g)(); const data = hooks_useAvsInfoForLRT(); const [extended, setextended] = (0, react.useState)(false); const avsInfo = data.find(item => item.id === productName)?.avsInfo; const extendedAvsInfo = (0, react.useMemo)(() => { return avsInfo?.map(info => { const avsDetails = avsData_namespaceObject[productName]?.find(item => item.id.toLocaleLowerCase() === info.name.toLocaleLowerCase()); return avsDetails ? { ...info, extendedName: avsDetails.name, url: avsDetails.url } : info }) }, [avsInfo, productName]); const finalAvsInfo = (0, react.useMemo)(() => extendedAvsInfo?.slice(0, 4), [extendedAvsInfo]); const isExpandable = (0, react.useMemo)(() => extendedAvsInfo?.length > 4 && !extended, [extendedAvsInfo, extended]); const [info, setinfo] = (0, react.useState)(isExpandable ? finalAvsInfo : extendedAvsInfo); (0, react.useEffect)(() => { if (isExpandable) { setinfo(finalAvsInfo) } else { setinfo(extendedAvsInfo) } }, [extendedAvsInfo, extended, finalAvsInfo, isExpandable]); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "avs-section", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "avs-section.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [" (", extendedAvsInfo?.length, ")"] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "avs-grid", className: `${extended ? "extended" : ""}`, children: info.map(info =>/*#__PURE__*/(0, jsx_runtime.jsx)(AvsInfoBox_AvsInfoBox, { avsInfo: info }, info.name)) }), extendedAvsInfo?.length > 4 &&/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: () => setextended(!extended), children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: extended ?/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "avs-section.hide" }) :/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "avs-section.extended", values: { n: extendedAvsInfo.length - 4 } }) }) })] }) };/* harmony default export */ const AvsSection_AvsSection = (AvsSection);
        ;// ./src/routes/ProductInfo/MiddleInfo/AvsSection/AvsSectionLoading.tsx
        const AvsSectionLoading = () => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "avs-section", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "avs-section.title" }), " "] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {})] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, {})] }) };/* harmony default export */ const AvsSection_AvsSectionLoading = (AvsSectionLoading);
        ;// ./src/routes/ProductInfo/MiddleInfo/RiskSection/RiskSectionLoading.tsx
        const RiskSectionLoading = () => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "risk-section", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Risk Factor" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, {})] }) };/* harmony default export */ const RiskSection_RiskSectionLoading = (RiskSectionLoading);
        ;// ./src/components/Charts/RiskChart/RiskChartWrapper.tsx
        const RiskChart =/*#__PURE__*/(0, react.lazy)(() => Promise.all(/*! import() */[__webpack_require__.e(4027), __webpack_require__.e(9576)]).then(__webpack_require__.bind(__webpack_require__, /*! ./RiskChart */ 29576))); function RiskChartWrapper(props) { return /*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(RiskChart, { ...props }) }) }
        ;// ./src/components/Charts/RiskChart/CompleteRiskChart/CompleteRiskChart.tsx
        function CompleteRiskChart({ productName }) { const [time, setTime] = (0, react.useState)("1m"); const handleTime = (0, react.useCallback)(time => setTime(time), []); const [selectedRisks, setSelectedRisks] = (0, react.useState)([RiskTypes/* RiskType */.G.Collateral, RiskTypes/* RiskType */.G.Dexes]); const toggleRisk = risk => { if (selectedRisks.includes(risk)) { if (selectedRisks.length > 1) { setSelectedRisks(selectedRisks.filter(r => r !== risk)) } } else { setSelectedRisks([...selectedRisks, risk]) } }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "complete-risk-chart", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { id: "dexes-check", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "checkbox", checked: selectedRisks.includes(RiskTypes/* RiskType */.G.Dexes), onChange: () => toggleRisk(RiskTypes/* RiskType */.G.Dexes), disabled: selectedRisks.length === 1 && selectedRisks.includes(RiskTypes/* RiskType */.G.Dexes) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Liquidity" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { id: "collateral-check", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { type: "checkbox", checked: selectedRisks.includes(RiskTypes/* RiskType */.G.Collateral), onChange: () => toggleRisk(RiskTypes/* RiskType */.G.Collateral), disabled: selectedRisks.length === 1 && selectedRisks.includes(RiskTypes/* RiskType */.G.Collateral) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Collateral" })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "chart-risk-item", children: [true ?/*#__PURE__*/(0, jsx_runtime.jsx)(RiskChartWrapper, { chartTime: time, productName: productName, handleTime: handleTime, selectedRisks: selectedRisks }) : 0,/*#__PURE__*/(0, jsx_runtime.jsx)(ChartTimeSelector_ChartTimeSelector, { time: time, handleTime: handleTime })] })] }) }
        ;// ./src/routes/ProductInfo/MiddleInfo/MiddleAssetInfo.tsx
        const InfoLst = ({ productName }) => { const tokens = hooks_useTokensLst(); const { networkName } = (0, dist/* useParams */.g)(); const networkId = getNetworkIdByName(networkName); const info = tokens?.find(t => t?.id?.toLowerCase() === productName?.toLowerCase() && t?.network === networkId); return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "middle-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ListMultiplier_ListMultiplier, { multipliers: { autoLayer: info.multipliers.autoLayer } }),/*#__PURE__*/(0, jsx_runtime.jsx)(ApyInfo_ApyInfo, { apr: +info.apr })] }) }) }; const InfoLrst = ({ productName }) => { const tokens = hooks_useTokensLrst(); const { networkName } = (0, dist/* useParams */.g)(); const networkId = getNetworkIdByName(networkName); const info = tokens?.find(t => t?.id?.toLowerCase() === productName?.toLowerCase() && t?.network === networkId); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "multipliers-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "middle-section.multipliers" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ListMultiplier_ListMultiplier, { multipliers: info.multipliers })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "middle-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ApyInfo_ApyInfo, { apr: !isNaN(+info.apr) ? +info.apr : null }),/*#__PURE__*/(0, jsx_runtime.jsx)(GenericPoints_RestakingRewards, { productName: info?.id?.toLowerCase() })] })] }) }; const MiddleAssetInfo = ({ tokenInfo }) => { const { networkName } = (0, dist/* useParams */.g)(); const { id, type, name, description, network } = tokenInfo; const { networkTag } = getItemByNetwork(network); const isLST = type === "LST"; const idLower = id.toLowerCase(); const hasAVS = idLower === "ezeth" || idLower === "rseth"; const noRiskIds = ["pzeth", "eeth", "primeeth", "ineth"]; const hasRisk = !isLST && !noRiskIds.includes(idLower); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "asset-middle-section", className: "middle-section", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "top-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage(idLower), alt: id, className: "lrs-img" }), !isLST &&/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "network", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: networkLogos[networkName], alt: `${networkName} logo` }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: networkTag })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: `badge ${type}`, children: type })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children: name }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children: description })] }), !isLST ?/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback: "error", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(InfoLrst, { productName: idLower }) }) }) :/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback: "error", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(InfoLst, { productName: idLower }) }) }), hasAVS &&/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(AvsSection_AvsSectionLoading, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(AvsSection_AvsSection, {}) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "chart-lrt", id: "chart-apy", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children: "APY Overtime" }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(CompleteChart, { productName: idLower }) })] }), hasRisk &&/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(RiskSection_RiskSectionLoading, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(RiskSection_RiskSection, {}) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "chart-lrt", id: "chart-risk", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children: "Risk Factor Overtime" }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(CompleteRiskChart, { productName: idLower }) })] })] })] }) };/* harmony default export */ const MiddleInfo_MiddleAssetInfo = (MiddleAssetInfo);
        ;// ./src/routes/ProductInfo/DiscontinuedNotice/DiscontinuedNotice.tsx
        const DiscontinuedNotice = () => { const link =/*#__PURE__*/(0, jsx_runtime.jsx)("a", { href: "https://x.com/ClayStack_HQ/status/1793570888853418239", target: "_blank", rel: "noreferrer noopener", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "announcement" }) }); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "discontinued-notice", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "icon icon-exclamation" }),/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "discontinued-notice.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "discontinued-notice.text", values: { link } }) })] }) };/* harmony default export */ const DiscontinuedNotice_DiscontinuedNotice = (DiscontinuedNotice);
        ;// ./src/routes/ProductInfo/AssetInfo.tsx
        const AssetInfo = () => { const [isSwapDialogOpen, setIsSwapDialogOpen] = (0, react.useState)(false); const [isDepositDialogOpen, setIsDepositDialogOpen] = (0, react.useState)(false); const [refreshKey, setRefreshKey] = (0, react.useState)(0); const { productName, networkName } = (0, dist/* useParams */.g)(); const networkId = getNetworkIdByName(networkName); const networkInfo = data_networkData(networkId); const tokenInfo = (0, react.useMemo)(() => networkInfo.tokensLRS.find(t => t.id.toLowerCase() === productName?.toLowerCase()), [networkInfo.tokensLRS, productName]); const handleRefreshKey = () => setRefreshKey(s => s + 1); const location = (0, dist/* useLocation */.zy)(); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ProductMeta, { url: true ? window.location.href : 0, description: utils_text.firstPhrase(tokenInfo.opengraph), image: tokenInfo.image, title: `${tokenInfo.name} | Autolayer` }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "asset-info", className: "product-info page", children: [isDepositDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(DepositDialog_DepositDialog, { setIsDepositDialogOpen: setIsDepositDialogOpen, refreshAutoLayerPoints: handleRefreshKey }), isSwapDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(SwapDialog_SwapDialog, { setIsSwapDialogOpen: setIsSwapDialogOpen, refreshAutoLayerPoints: handleRefreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(Header_HeaderProductInfo, { productInfo: tokenInfo }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "grid-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(LeftInfo_LeftAssetInfo, { tokenInfo: tokenInfo, refreshKey: refreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(MiddleInfo_MiddleAssetInfo, { tokenInfo: tokenInfo }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [productName === "cseth" &&/*#__PURE__*/(0, jsx_runtime.jsx)(DiscontinuedNotice_DiscontinuedNotice, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfoButtons_ProductInfoButtons, { darkMode: false, setIsSwapDialogOpen: setIsSwapDialogOpen, setIsDepositDialogOpen: setIsDepositDialogOpen })] })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) }; const AssetInfoWrapper = () => { const { productName, networkName } = (0, dist/* useParams */.g)(); const networkId = getNetworkIdByName(networkName); const networkInfo = data_networkData(networkId); const isTokenLst = networkInfo.tokensLRS.some(t => t.id.toLowerCase() === productName?.toLowerCase()); if (!isTokenLst) return /*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Navigate */.C5, { to: "/" }); return /*#__PURE__*/(0, jsx_runtime.jsx)(AssetInfo, {}) };/* harmony default export */ const ProductInfo_AssetInfo = (AssetInfoWrapper);
        ;// ./src/components/GoToAirdropChecker/GoToAirdropChecker.tsx
        const GoToAidropChecker = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "go-to-leaderboard", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.token, alt: "Lay3r Logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "go-to-airdrop-checker.text", defaultMessage: "Check your LAY3R allocation now by clicking {here}.", values: { here:/*#__PURE__*/(0, jsx_runtime.jsx)("a", { href: "https://claim.autolayer.io", target: "_blank", rel: "noreferrer", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "go-to-airdrop-checker.link", defaultMessage: "here" }) }) } }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.token, alt: "Lay3r Logo" })] }) }) }) };/* harmony default export */ const GoToAirdropChecker = (GoToAidropChecker);
        ;// ./src/components/ExternalHeader/ExternalHeader.tsx
        const ExternalHeader = ({ name, showSettingsMenu = true, learnMoreUrl = "" }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)("header", { className: "masthead-external", id: `${name}-masthead-external`, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)(react_router_dom_dist/* Link */.N_, { to: "/", className: "button", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_left" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "back-text", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "back-to-dashboard" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${name}-header.title` }) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "right-buttons", children: [!!learnMoreUrl &&/*#__PURE__*/(0, jsx_runtime.jsx)("a", { rel: "noopener noreferrer", className: "button learn-more", target: "_blank", href: learnMoreUrl, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "learn-more" }) }), showSettingsMenu &&/*#__PURE__*/(0, jsx_runtime.jsx)(SettingsMenu_SettingsMenu, {})] })] }) }) };/* harmony default export */ const ExternalHeader_ExternalHeader = (ExternalHeader);
        ;// ./src/hooks/useAirdrops.ts
        const useAirdrops = () => { const airdrops = (0, index_esm/* useFetch */.st)(constants/* airdropUrl */.Lu); return airdrops || [] };/* harmony default export */ const hooks_useAirdrops = (useAirdrops);
        ;// ./src/components/Points/Airdrop/GenericPoints.tsx
        function Airdrop_GenericPoints_GenericPoints({ points }) { const DECIMALS = +points < 1e3 ? 2 : 3; const finalAmount = useCompactNumbers(); return /*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: finalAmount(points, DECIMALS) }) }
        ;// ./src/components/Points/Airdrop/RewardPoints.tsx
        function RewardPoints({ useFetchPoints }) { const points = useFetchPoints(); return /*#__PURE__*/(0, jsx_runtime.jsx)(Airdrop_GenericPoints_GenericPoints, { points: +points?.points }) } function RewardPointsWrapper({ useFetchPoints }) { return /*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "Error" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(RewardPoints, { useFetchPoints: useFetchPoints }) }) }) }
        ;// ./src/routes/Airdrop/RewardsGrid/RewardCard/RewardCard.tsx
        const DefaultRewardCard = () => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "reward-card default-reward-card", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { className: "skeleton" }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "row", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "badge skeleton" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("h2", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.points-gathered", values: { n: "" } }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "skeleton" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.stage", values: { s: "" } }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "skeleton" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { target: "_blank", rel: "noopener noreferrer", className: "button disabled", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.claim" }) })] }) }; const RewardCard = ({ info }) => { const { id, lrt, url, tag, project, announced } = info; const lowerId = id.toLocaleLowerCase(); const associations = { eigenlayer: "eigenLayer", ezeth: "renzo", rseth: "kelp", pufeth: "puffer", eeth: "ether", rsweth: "swell", unieth: "bedrock", primeeth: "primestaked", inETH: "inception", symbiotic: "symbiotic", mellow: "mellow" }; const Element =/*#__PURE__*/(0, jsx_runtime.jsx)(RewardPointsWrapper, { useFetchPoints: productsPointsWithoutAutoLayer[associations[id]] }); return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { style: { backgroundImage: `url("/images/airdrop/${lowerId}.jpg")` }, id: `reward-card-${lowerId}`, className: "reward-card", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children: project }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "row", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { id: `badge-${id}`, className: "badge", children: lrt || tag }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.points-gathered", values: { n: Element } }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "row", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "stage", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.stage", values: { s: announced } }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("a", { href: info.url, target: "_blank", rel: "noopener noreferrer", className: `button ${!url ? "disabled" : ""}`, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "reward-card.claim" }) })] }) };/* harmony default export */ const RewardCard_RewardCard = (RewardCard);
        ;// ./src/routes/Airdrop/RewardsGrid/DefaultRewardsGrid.tsx
        const DefaultRewardsGrid = () => { return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { id: "rewards-grid", className: "grid-container", children: [...Array(5)].map((_, i) =>/*#__PURE__*/(0, jsx_runtime.jsx)(DefaultRewardCard, {}, i)) }) };/* harmony default export */ const RewardsGrid_DefaultRewardsGrid = (DefaultRewardsGrid);
        ;// ./src/routes/Airdrop/RewardsGrid/RewardsGrid.tsx
        const RewardsGrid = () => { const rewards = hooks_useAirdrops() || []; const wallet = (0, es/* useSelector */.d4)(s => s.wallet); if (!wallet) return /*#__PURE__*/(0, jsx_runtime.jsx)(RewardsGrid_DefaultRewardsGrid, {}); return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { id: "rewards-grid", className: "grid-container", children: rewards?.map(r =>/*#__PURE__*/(0, jsx_runtime.jsx)(RewardCard_RewardCard, { info: r }, r.id)) }) };/* harmony default export */ const RewardsGrid_RewardsGrid = (RewardsGrid);
        ;// ./src/components/Meta/AirdropMeta.tsx
        function AirdropMeta() { const intl = (0, useIntl/* default */.A)(); const title = intl.formatMessage({ id: "meta.airdrop.title" }); const description = intl.formatMessage({ id: "meta.airdrop.description" }); const image = "https://i.imgur.com/x5NS5K7.png"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("title", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:type", content: "website" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: "https://app.autolayer.io/airdrop/" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image })] }) }
        ;// ./src/routes/Airdrop/Airdrop.tsx
        const Airdrop = () => { return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(AirdropMeta, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "airdrop", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ExternalHeader_ExternalHeader, { name: "airdrop" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "airdrop.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { className: "mono-space", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "airdrop.text" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback: "error", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(RewardsGrid_DefaultRewardsGrid, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(RewardsGrid_RewardsGrid, {}) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) };/* harmony default export */ const Airdrop_Airdrop = (Airdrop);
        ;// ./src/components/Meta/ReferralsMeta.tsx
        function ReferralsMeta() { const intl = (0, useIntl/* default */.A)(); const title = intl.formatMessage({ id: "meta.referrals.title" }); const description = intl.formatMessage({ id: "meta.referrals.description" }); const image = "https://i.imgur.com/Z9QKE0O.png"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("title", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:type", content: "website" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: "https://app.autolayer.io/referrals/" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image })] }) }
        ;// ./src/routes/Referrals/Referrals.tsx
        const Referrals = () => { const learnMoreUrl = "https://docs.autolayer.io/autolayer/latest-app-infos/rewards-and-programs/autolayer-referral-program"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsMeta, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "referrals", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ExternalHeader_ExternalHeader, { name: "referrals", learnMoreUrl: learnMoreUrl }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "wrapper", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "referrals-top", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h1", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.text" }) })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "container", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "referrals-bottom", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsButtons_ReferralsButtons, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(Loading_Loading, { colored: true }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Outlet */.sv, {}) }) })] }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) };/* harmony default export */ const Referrals_Referrals = (Referrals);
        // EXTERNAL MODULE: ./node_modules/react-intl/lib/index.js + 1 modules
        var lib = __webpack_require__(72267);
        ;// ./src/utils/stake.ts
        function getLay3rData(data) { const autolayer = data.find(item => item.symbol === "lay3r"); return autolayer } function getAbbreviatedNumber(num) { if (num >= 1 && num < 1e4) { return num.toFixed(3) } else if (num < 1) { return num.toFixed(5) } else if (num >= 1e4 && num < 1e6) { return (num / 1e3).toFixed(1) + "K" } else if (num >= 1e6 && num < 1e9) { return (num / 1e6).toFixed(1) + "M" } else { return (num / 1e9).toFixed(1) + "B" } } function getPendingDate(startTime, lockTime) { const dateDifference = Math.floor(Date.now() / 1e3 - startTime); const day = Math.floor(dateDifference / 86400); return lockTime - day } function chooseDialogLabel(type) { switch (type) { case "claim": return "Claim Rewards"; case "rewards": return "Stake Rewards"; case "stake": return "Stake"; case "unstake": return "Unstake" } } const stakeUtils = { getLay3rData, getAbbreviatedNumber, chooseDialogLabel, getPendingDate };/* harmony default export */ const stake = (stakeUtils);
        ;// ./src/contracts/abis/AutoLayerAbis/StakingAbi.ts
        const StakingAbi_stakingAbi = [{ inputs: [{ internalType: "address", name: "target", type: "address" }], name: "AddressEmptyCode", type: "error" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "AddressInsufficientBalance", type: "error" }, { inputs: [], name: "FailedInnerCall", type: "error" }, { inputs: [], name: "InvalidInitialization", type: "error" }, { inputs: [], name: "NotInitializing", type: "error" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }], name: "OwnableInvalidOwner", type: "error" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "OwnableUnauthorizedAccount", type: "error" }, { inputs: [{ internalType: "address", name: "token", type: "address" }], name: "SafeERC20FailedOperation", type: "error" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "stakingPosition", type: "uint256" }, { indexed: false, internalType: "uint256", name: "rewardAmount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "claimTime", type: "uint256" }], name: "ClaimReward", type: "event" }, { anonymous: false, inputs: [{ indexed: false, internalType: "uint64", name: "version", type: "uint64" }], name: "Initialized", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "previousOwner", type: "address" }, { indexed: true, internalType: "address", name: "newOwner", type: "address" }], name: "OwnershipTransferred", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "stakingPosition", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "startTime", type: "uint256" }], name: "Stake", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "stakingPosition", type: "uint256" }, { indexed: false, internalType: "uint256", name: "rewardAmount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "startTime", type: "uint256" }], name: "StakeReward", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "user", type: "address" }, { indexed: true, internalType: "uint256", name: "stakingPosition", type: "uint256" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "rewardAmount", type: "uint256" }, { indexed: false, internalType: "uint256", name: "endTime", type: "uint256" }], name: "Unstake", type: "event" }, { inputs: [], name: "APY", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "autolayerToken", outputs: [{ internalType: "contract IERC20", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "stakingPosition", type: "uint256" }], name: "claimReward", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "getAvailableStakeAmount", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }], name: "getUserNumStakingPositions", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }, { internalType: "uint256", name: "stakingPosition", type: "uint256" }], name: "getUserPositionPendingRewardAmount", outputs: [{ internalType: "uint256", name: "userPositionPendingRewardAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }, { internalType: "uint256", name: "stakingPosition", type: "uint256" }], name: "getUserStakingPosition", outputs: [{ components: [{ internalType: "uint256", name: "initialAmount", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "uint256", name: "startTime", type: "uint256" }, { internalType: "uint256", name: "rewardAmountClaimed", type: "uint256" }, { internalType: "uint256", name: "lastTimeClaimed", type: "uint256" }, { internalType: "bool", name: "active", type: "bool" }], internalType: "struct StakingUtils.StakingPosition", name: "", type: "tuple" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }], name: "getUserTotalPendingRewardAmount", outputs: [{ internalType: "uint256", name: "userTotalPendingRewardAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }], name: "getUserTotalRewardAmountClaimed", outputs: [{ internalType: "uint256", name: "userTotalRewardAmountClaimed", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "user", type: "address" }], name: "getUserTotalStakedAmount", outputs: [{ internalType: "uint256", name: "userTotalStakedAmount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "historicTotalAmountStaked", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "historicTotalRewardClaimed", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "apy_", type: "uint256" }, { internalType: "uint256", name: "lockingPeriod_", type: "uint256" }, { internalType: "uint256", name: "maxTotalAmountStaked_", type: "uint256" }, { internalType: "address", name: "autolayerToken_", type: "address" }, { internalType: "address", name: "treasuryWallet_", type: "address" }], name: "initialize", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "isAllowed", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [], name: "lockingPeriod", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "maxTotalAmountStaked", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "owner", outputs: [{ internalType: "address", name: "", type: "address" }], stateMutability: "view", type: "function" }, { inputs: [], name: "pause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "pauseRewards", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "paused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "notAllowedAddress_", type: "address" }], name: "removeAllowed", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "renounceOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "rewardsEndTime", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "rewardsPaused", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "allowedAddress_", type: "address" }], name: "setAllowed", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "stake", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "stakingPosition", type: "uint256" }], name: "stakeReward", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "totalAmountStaked", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "newOwner", type: "address" }], name: "transferOwnership", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpause", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "unpauseRewards", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "uint256", name: "stakingPosition", type: "uint256" }], name: "unstake", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "", type: "address" }], name: "usersInfo", outputs: [{ internalType: "uint256", name: "numPositions", type: "uint256" }], stateMutability: "view", type: "function" }];
        ;// ./src/contracts/staking/getTotalData.ts
        const getTotalAmountStaked = async (contractAddress, networkName = "binance") => { const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const totalAmountStaked = await contract.methods.totalAmountStaked().call(); const ethTotalAmountStaked = web3.utils.fromWei(totalAmountStaked.toString(), "ether"); return parseFloat(ethTotalAmountStaked) }; const getHistoricTotalAmountStaked = async (contractAddress, networkName = "binance") => { const web3 = getWeb3(networkName); const contract = new web3.eth.Contract(stakingAbi, contractAddress); const historicTotalAmount = await contract.methods.historicTotalAmountStaked().call(); const ethhistoricTotalAmount = web3.utils.fromWei(historicTotalAmount.toString(), "ether"); return parseFloat(ethhistoricTotalAmount) }; const getHistoricTotalRewardsClaimed = async (contractAddress, networkName = "binance") => { const web3 = getWeb3(networkName); const contract = new web3.eth.Contract(stakingAbi, contractAddress); const historicTotalRewardClaimed = await contract.methods.historicTotalRewardClaimed().call(); const etHistoricTotalRewardClaimed = web3.utils.fromWei(historicTotalRewardClaimed.toString(), "ether"); return parseFloat(etHistoricTotalRewardClaimed) }; const getTotalData_getStakingTotals = async (contractAddress, networkName = "binance") => { const totalAmountStaked = await getTotalAmountStaked(contractAddress, networkName); const historicTotalAmountStaked = await getHistoricTotalAmountStaked(contractAddress, networkName); const historicTotalRewardClaimed = await getHistoricTotalRewardsClaimed(contractAddress, networkName); return { totalAmountStaked, historicTotalAmountStaked, historicTotalRewardClaimed } }; const getAvailableCapacity = async (contractAddress, networkName = "binance") => { const web3 = contracts_web3(networkName); if (!contractAddress) return 0; const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const resAvailableCapacity = await contract.methods.getAvailableStakeAmount().call(); console.log("resAvailableCapacity", resAvailableCapacity); const availableCapacity = web3.utils.fromWei(resAvailableCapacity.toString(), "ether"); return parseFloat(availableCapacity) };
        ;// ./src/contracts/staking/getUserStakingPosition.ts
        const getUserStakingPosition = async (userAddress, positionId, contractAddress, networkName = "binance") => { if (!userAddress) return null; const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const userStakingPosition = await contract.methods.getUserStakingPosition(userAddress, positionId).call(); const infoFormatted = { initialAmount: parseFloat(web3.utils.fromWei(userStakingPosition.initialAmount.toString(), "ether")), currentAmount: parseFloat(web3.utils.fromWei(userStakingPosition.amount.toString(), "ether")), startTime: +userStakingPosition.startTime.toString(), rewardAmountClaimed: parseFloat(web3.utils.fromWei(userStakingPosition.rewardAmountClaimed.toString(), "ether")), lastTimeClaimed: +userStakingPosition.lastTimeClaimed.toString(), active: userStakingPosition.active }; return infoFormatted };/* harmony default export */ const staking_getUserStakingPosition = (getUserStakingPosition); const getUserPositionPendingRewards = async (address, positionId, contractAddress, networkName = "binance") => { if (!address) return 0; const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const pendingRewards = await contract.methods.getUserPositionPendingRewardAmount(address, positionId).call(); const rewardsToClaim = web3.utils.fromWei(pendingRewards.toString(), "ether"); return parseFloat(rewardsToClaim) };
        ;// ./src/contracts/staking/getUserNumStakingPositions.ts
        const getUserNumStakingPositions = async (userAddress, contractAddress, networkName = "binance") => { if (!userAddress) return 0; const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const numPositions = await contract.methods.getUserNumStakingPositions(userAddress).call(); return +numPositions?.toString() };/* harmony default export */ const staking_getUserNumStakingPositions = (getUserNumStakingPositions);
        ;// ./src/contracts/staking/getUserStakingTotalData.ts
        const getUserTotalStakedAmount = async (address, contractAddress, networkName = "binance") => { if (!address) return 0; const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const userStakingPosition = await contract.methods.getUserTotalStakedAmount(address).call(); const totalStakedAmount = web3.utils.fromWei(userStakingPosition.toString(), "ether"); return parseFloat(totalStakedAmount) }; const getUserTotalPendingRewardAmount = async (address, contractAddress, networkName = "binance") => { if (!address) return 0; const web3 = contracts_web3(networkName); const contract = new web3.eth.Contract(StakingAbi_stakingAbi, contractAddress); const pendingRewards = await contract.methods.getUserTotalPendingRewardAmount(address).call(); const rewardsToClaim = web3.utils.fromWei(pendingRewards.toString(), "ether"); return parseFloat(rewardsToClaim) };
        ;// ./src/hooks/useStaking.ts
        const useStakingTotalStaked = (contractAddress, networkName = "binance") => { const totalStaked = hooks_usePromise(getTotalAmountStaked, contractAddress, networkName); return totalStaked }; const useStakingTotals = (contractAddress, networkName = "binance") => { const totals = usePromise(getStakingTotals, contractAddress, networkName); return totals }; const useStakingPosition = (address, positionId, contractAddress, networkName = "binance") => { const position = hooks_usePromise(staking_getUserStakingPosition, address, positionId, contractAddress, networkName); return position }; const useStakingPositionNumber = (address, contractAddress, refreshKey, networkName = "binance") => { const positionsNumber = hooks_usePromise(staking_getUserNumStakingPositions, address, contractAddress, networkName, refreshKey); return positionsNumber }; const useGetTotalUserStakedAmount = (userAddress, contractAddress, networkName = "binance") => { const totalStaked = hooks_usePromise(getUserTotalStakedAmount, userAddress, contractAddress, networkName); return totalStaked }; const useGetTotalUserRewards = (userAddress, contractAddress, networkName = "binance") => { const totalRewards = hooks_usePromise(getUserTotalPendingRewardAmount, userAddress, contractAddress, networkName); return totalRewards }; const useGetPendingRewardsInPosition = (userAddress, positionId, contractAddress, networkName = "binance") => { const rewards = hooks_usePromise(getUserPositionPendingRewards, userAddress, positionId, contractAddress, networkName); return rewards }; const useGetAvailableCapacity = (contractAddress, networkName = "binance") => { const rewards = hooks_usePromise(getAvailableCapacity, contractAddress, networkName); return rewards };
        ;// ./src/data/Staking/Binance/contracts.ts
        const pool1 = { lockTerm: 45, logo: AutolayerLogos.autolayerIconWhite, maxCapacity: 3e5, name: "$LAY3R", apy: 35, address: "0x99Af1822516a85eF1a9d27ef1F1C0d30676C4f8d" }; const pool2 = { lockTerm: 45, logo: AutolayerLogos.autolayerIconWhite, maxCapacity: 75e4, name: "$LAY3R", apy: 10, address: "0xC4EF9eBB5992EAe9756DeA2447D15211cE345121" }; const pool3 = { lockTerm: 45, logo: AutolayerLogos.autolayerIconWhite, maxCapacity: 6e5, name: "$LAY3R", apy: 30, address: "0xb16C4dB422594D18e051D06CD75792a433D01610" }; const pool4 = { lockTerm: 45, logo: AutolayerLogos.autolayerIconWhite, maxCapacity: 75e4, name: "$LAY3R", apy: 25, address: "0x6f0466636A612Cf3D816fDd3D837A2c6eb2A9DaE" }; const binancePools = { pool1, pool2, pool3, pool4 };
        ;// ./src/components/Stake/BannerItem/BannerItem.tsx
        const { pool1: BannerItem_pool1, pool2: BannerItem_pool2, pool3: BannerItem_pool3, pool4: BannerItem_pool4 } = binancePools; const BannerItemUSD = () => { const pool1Data = useStakingTotalStaked(BannerItem_pool1.address); const pool2Data = useStakingTotalStaked(BannerItem_pool2.address); const pool3Data = useStakingTotalStaked(BannerItem_pool3.address); const pool4Data = useStakingTotalStaked(BannerItem_pool4.address); const totalStaked = pool1Data + pool2Data + pool3Data + pool4Data; const data = hooks_useCoingecko(); const lay3rData = stake.getLay3rData(data); const { current_price: currentPrice } = lay3rData; return /*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: totalStaked * currentPrice, style: "currency", maximumFractionDigits: 0, currency: "USD" }) }; const BannerItemTotal = () => { const pool1Data = useStakingTotalStaked(BannerItem_pool1.address); const pool2Data = useStakingTotalStaked(BannerItem_pool2.address); const pool3Data = useStakingTotalStaked(BannerItem_pool3.address); const pool4Data = useStakingTotalStaked(BannerItem_pool4.address); const totalStaked = pool1Data + pool2Data + pool3Data + pool4Data; return /*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: totalStaked, style: "decimal", maximumFractionDigits: 0 }) }; const BannerItemUserStake = () => { const address = useWallet_useWallet(); const pool1Data = useGetTotalUserStakedAmount(address, BannerItem_pool1.address); const pool2Data = useGetTotalUserStakedAmount(address, BannerItem_pool2.address); const pool3Data = useGetTotalUserStakedAmount(address, BannerItem_pool4.address); const pool4Data = useGetTotalUserStakedAmount(address, BannerItem_pool4.address); const totalUserStaked = pool1Data + pool2Data + pool3Data + pool4Data; return /*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: totalUserStaked, style: "decimal", maximumFractionDigits: 2 }) }; const BannerItemRewards = () => { const address = useWallet_useWallet(); const pool1Data = useGetTotalUserRewards(address, BannerItem_pool1.address); const pool2Data = useGetTotalUserRewards(address, BannerItem_pool2.address); const pool3Data = useGetTotalUserRewards(address, BannerItem_pool3.address); const pool4Data = useGetTotalUserRewards(address, BannerItem_pool4.address); const totalUserRewards = pool1Data + pool2Data + pool3Data + pool4Data; return /*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: totalUserRewards, style: "decimal", maximumFractionDigits: 2 }) }; const dataComponents = { rewards: BannerItemRewards, totalStakedAmount: BannerItemTotal, userStakedAmount: BannerItemUserStake, usd: BannerItemUSD }; function BannerItem({ title, stakeKey }) { const DataComponent = dataComponents[stakeKey]; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "banner-item", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: title }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "fallback" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(DataComponent, {}) }) })] }) }
        ;// ./src/components/Stake/StakigInfo/StakingButtons/StakingButtons.tsx
        function StakingButtons({ open, rewards, poolAddress, positionId, pendingDate }) { const userWalletChainId = hooks_useWalletChainId(); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "stake", disabled: userWalletChainId !== "0x38", onClick: () => open({ type: "rewards", poolAddress, positionId, initialValue: rewards }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.buttons.stake" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "claim", disabled: userWalletChainId !== "0x38" || pendingDate > 0, onClick: () => open({ type: "claim", poolAddress, positionId, initialValue: rewards }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.buttons.claim" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "unstake", disabled: userWalletChainId !== "0x38" || pendingDate > 0, onClick: () => open({ type: "unstake", poolAddress, positionId }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.buttons.unstake" }) })] }) }
        ;// ./src/components/ProgressBar/ProgressBar.tsx
        function ProgressWrapper({ maxCapacity, poolAddress }) { const progrees = useStakingTotalStaked(poolAddress); return /*#__PURE__*/(0, jsx_runtime.jsx)(ProgressBar, { value: progrees / maxCapacity * 100, label: stake.getAbbreviatedNumber(maxCapacity) }) } const ProgressBar = ({ label, value, maxValue = 100 }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "progress-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "progress-label", children: label }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "progress-bar", role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": value, children:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "progress-fill", style: { clipPath: `polygon(0% 0%, ${value}% 0%, ${value}% 100%, 0% 100%)` } }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "progress-text", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: value / 100, style: "percent" }), " /",/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: maxValue / 100, style: "percent" })] })] }) };/* harmony default export */ const ProgressBar_ProgressBar = (ProgressBar);
        ;// ./src/components/Stake/StakigInfo/StakingInfo.tsx
        function StakingInfo({ lockTime, maxCapacity, poolAddress }) { const address = useWallet_useWallet(); const stakedAmount = useGetTotalUserStakedAmount(address, poolAddress); const rewards = useGetTotalUserRewards(address, poolAddress); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-info", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.lock-term" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "value time", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "days", children: lockTime }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.days" }) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.capacity" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(ProgressBar_ProgressBar, { value: 0, label: stake.getAbbreviatedNumber(maxCapacity) }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(ProgressWrapper, { maxCapacity: maxCapacity, poolAddress: poolAddress }) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.my-stake" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value bold", children: stake.getAbbreviatedNumber(stakedAmount) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.my-rewards" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value bold", children: stake.getAbbreviatedNumber(rewards) })] })] }) }
        ;// ./src/components/Stake/StakigInfo/StakingInfoWrapper.tsx
        function StakingInfoWrapper({ lockTime, maxCapacity }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-info", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.lock-term" }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { className: "value time", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "days", children: lockTime }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.days" }) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.capacity" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children:/*#__PURE__*/(0, jsx_runtime.jsx)(ProgressBar_ProgressBar, { value: 0, label: stake.getAbbreviatedNumber(maxCapacity) }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.my-stake" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value bold" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "title", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.header.my-rewards" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value bold" })] })] }) }
        ;// ./src/components/Stake/StakingContent/StakingContentMobile.tsx
        function StakingContentRowFallback({ open }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-entry fallback", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "time", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "days" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.days" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", {}) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingButtons, { open: open, rewards: 0, poolAddress: "", positionId: 0, pendingDate: 10 })] }) } function StakingContentRow({ open, poolAddress, positionId, lockTime }) { const address = useWallet_useWallet(); const positionData = useStakingPosition(address, positionId, poolAddress); const rewards = useGetPendingRewardsInPosition(address, positionId, poolAddress); if (!positionData) return null; const { startTime, currentAmount } = positionData; const pendingDate = stake.getPendingDate(startTime, lockTime); if (!positionData.active) return null; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-entry", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "time", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "days", children: pendingDate }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.days" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children: stake.getAbbreviatedNumber(currentAmount) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children: stake.getAbbreviatedNumber(rewards) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingButtons, { open: open, rewards: rewards, poolAddress: poolAddress, positionId: positionId, pendingDate: pendingDate })] }) } function StakingContentRowsWrapper({ lockTime, poolAddress, refreshKey, open }) { const address = useWallet_useWallet(); const positionsNumber = useStakingPositionNumber(address, poolAddress, refreshKey); const entries = Array.from({ length: positionsNumber }); return entries.map((_, index) =>/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentRow, { open: open, poolAddress: poolAddress, positionId: index, lockTime: lockTime }, index)) } function StakingContentMobile({ lockTime, maxCapacity, poolAddress, refreshKey, open }) { const fallbackEntries = [0, 1]; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-extended", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingInfoWrapper, { lockTime: lockTime, maxCapacity: maxCapacity, poolAddress: poolAddress }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingInfo, { lockTime: lockTime, maxCapacity: maxCapacity, poolAddress: poolAddress }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback: fallbackEntries.map(i =>/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentRowFallback, { open: open }, i)), children:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentRowsWrapper, { lockTime: lockTime, maxCapacity: maxCapacity, open: open, poolAddress: poolAddress, refreshKey: refreshKey }) })] }) }
        ;// ./src/components/Stake/Data/Mobile.tsx
        function StakingDataMobile({ apy, image, name, lockTime, maxCapacity, poolAddress, refreshKey, open: openDialog }) { const [open, setOpen] = (0, react.useState)(false); const userWalletChainId = hooks_useWalletChainId(); const totalStaked = useStakingTotalStaked(poolAddress); const disableStake = totalStaked >= maxCapacity; return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: `staking-data mobile ${open ? "open" : ""}`, tabIndex: 0, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { onClick: () => setOpen(prev => !prev), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "token-data", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: image, alt: "" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: name })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [apy, "%APY"] }),/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: fire_namespaceObject, alt: "fire icon", className: "fire" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { disabled: userWalletChainId !== "0x38" || disableStake, onClick: e => { openDialog({ type: "stake", poolAddress }); e.stopPropagation() }, children: "Stake" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_down" })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentMobile, { maxCapacity: maxCapacity, open: openDialog, lockTime: lockTime, poolAddress: poolAddress, refreshKey: refreshKey })] }) }
        ;// ./src/components/Stake/StakingContent/StakingContentDesktop.tsx
        function StakingContentTotalRewards({ poolAddress }) { const address = useWallet_useWallet(); const rewards = useGetTotalUserRewards(address, poolAddress); return /*#__PURE__*/(0, jsx_runtime.jsx)("span", { title: rewards.toString(), children: stake.getAbbreviatedNumber(rewards) }) } function StakingContentTotalStaked({ poolAddress }) { const address = useWallet_useWallet(); const stakedAmount = useGetTotalUserStakedAmount(address, poolAddress); return /*#__PURE__*/(0, jsx_runtime.jsx)("span", { title: stakedAmount.toString(), children: stake.getAbbreviatedNumber(stakedAmount) }) } function StakingContentDesktop_StakingContentRow({ poolAddress, positionId, lockTime, open }) { const address = useWallet_useWallet(); const positionData = useStakingPosition(address, positionId, poolAddress); const rewards = useGetPendingRewardsInPosition(address, positionId, poolAddress); if (!positionData) return null; const { startTime, currentAmount, active } = positionData; const pendingDate = stake.getPendingDate(startTime, lockTime); if (!active) return null; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "staking-entry", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "lock-term", children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: pendingDate }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "my-stake", title: `${currentAmount}`, children: stake.getAbbreviatedNumber(currentAmount) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "my-rewards", title: `${rewards}`, children: stake.getAbbreviatedNumber(rewards) }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingButtons, { open: open, rewards: rewards, poolAddress: poolAddress, positionId: positionId, pendingDate: pendingDate })] }) } function StakingContentDesktop({ apy, image, name, lockTime, maxCapacity, poolAddress, refreshKey, open: openDialog }) { const address = useWallet_useWallet(); const positionsNumber = useStakingPositionNumber(address, poolAddress, refreshKey); const entries = Array.from({ length: positionsNumber }); const [open, setOpen] = (0, react.useState)(false); const userWalletChainId = hooks_useWalletChainId(); const totalStaked = useStakingTotalStaked(poolAddress); const disableStake = totalStaked >= maxCapacity; return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: open ? "open" : "", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { onClick: () => setOpen(prev => !prev), children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "pools", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: name })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "apy", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [apy, "%"] }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.compounding" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "lock-term", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: lockTime }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.days" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "capacity", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(ProgressBar_ProgressBar, { label: stake.getAbbreviatedNumber(maxCapacity), value: 0 }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(ProgressWrapper, { maxCapacity: maxCapacity, poolAddress: poolAddress }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "my-stake", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("span", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentTotalStaked, { poolAddress: poolAddress }) }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "my-rewards", children:/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("span", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentTotalRewards, { poolAddress: poolAddress }) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: e => { openDialog({ type: "stake", poolAddress }); e.stopPropagation() }, disabled: userWalletChainId !== "0x38" || disableStake, children: "Stake" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-angle_right", role: "button", title: "Expand" })] })] }), entries.map((_, index) =>/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentDesktop_StakingContentRow, { lockTime: lockTime, open: openDialog, poolAddress: poolAddress, positionId: index }) }, index))] }) }
        ;// ./src/components/Stake/Data/Desktop.tsx
        const { pool1: Desktop_pool1, pool2: Desktop_pool2, pool3: Desktop_pool3, pool4: Desktop_pool4 } = binancePools; function StakingDataDesktop({ open, refreshKey }) { const header = "stake.staking-data.header"; return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "staking-data-container desktop", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.pools` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.apy` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.lock-term` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.capacity` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.my-stake` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.my-rewards` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${header}.actions` }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentDesktop, { refreshKey: refreshKey, apy: Desktop_pool1.apy, image: Desktop_pool1.logo, name: Desktop_pool1.name, open: open, lockTime: Desktop_pool1.lockTerm, maxCapacity: Desktop_pool1.maxCapacity, poolAddress: Desktop_pool1.address }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentDesktop, { refreshKey: refreshKey, apy: Desktop_pool3.apy, image: Desktop_pool3.logo, name: Desktop_pool3.name, open: open, lockTime: Desktop_pool3.lockTerm, maxCapacity: Desktop_pool3.maxCapacity, poolAddress: Desktop_pool3.address }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentDesktop, { refreshKey: refreshKey, apy: Desktop_pool4.apy, image: Desktop_pool4.logo, name: Desktop_pool4.name, open: open, lockTime: Desktop_pool4.lockTerm, maxCapacity: Desktop_pool4.maxCapacity, poolAddress: Desktop_pool4.address }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingContentDesktop, { refreshKey: refreshKey, apy: Desktop_pool2.apy, image: Desktop_pool2.logo, name: Desktop_pool2.name, open: open, lockTime: Desktop_pool2.lockTerm, maxCapacity: Desktop_pool2.maxCapacity, poolAddress: Desktop_pool2.address })] }) }
        ;// ./src/components/TokenInput/TokenInput.tsx
        function BalanceButtonsSkeleton() { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "balance-buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "max-balance-button", type: "button", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "max" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { type: "button", className: "percentage-balance-button", children: "%" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `percentages`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", children: "75%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", children: "50%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", children: "25%" })] })] }) } function TokenInput_BalanceButtons({ handleValue }) { const address = useWallet_useWallet(); const balance = hooks_usePromise(getRealWeiTokenBalance, "lay3r", address, "0x38"); const [openPorcentages, setOpenPorcentages] = (0, react.useState)(false); console.log(balance); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "balance-buttons", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "max-balance-button", type: "button", onClick: () => handleValue(balance), children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "max" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { type: "button", className: "percentage-balance-button", onClick: () => setOpenPorcentages(prev => !prev), children: "%" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `percentages ${openPorcentages ? "expanded" : ""}`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", onClick: () => handleValue(balance / BigInt(4) * BigInt(3)), children: "75%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", onClick: () => handleValue(balance / BigInt(2)), children: "50%" }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "balance-button", type: "button", onClick: () => handleValue(balance / BigInt(4)), children: "25%" })] })] }) } function TokenInput({ children, className, handleExternalChange, disabled = false, initialValue = 0 }) { const [value, setValue] = (0, react.useState)(initialValue); const weiInitialValue = initialValue * Math.pow(10, Number(18)); const [realAmount, setRealAmount] = (0, react.useState)(BigInt(weiInitialValue)); return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: `token-input ${className}`, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("label", { htmlFor: "quantity", children: "Amount" }), !disabled ?/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)(BalanceButtonsSkeleton, {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(TokenInput_BalanceButtons, { handleValue: value => { handleExternalChange(+value.toString()); setRealAmount(value); setValue(+value.toString() / Math.pow(10, Number(18))) } }) }) : null] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("input", { name: "quantity", type: "number", required: true, disabled: disabled, value: value, "data-wei": realAmount, onChange: ({ target: { value } }) => { const decimals = value.split(",")[1]; const factor = Math.pow(10, Number(18)); console.log("factor", factor); const valueAndFactor = +value * factor; console.log("valueAndFactor", valueAndFactor); setRealAmount(BigInt(valueAndFactor)); if (decimals && decimals.length > 6) return; setValue(+value); handleExternalChange(+value) } }), children] })] }) }
        ;// ./src/contracts/staking/stake.ts
        const autolayerTokenAddress = "0xF06ce11836851d71E74e4ffeFa7b73FCc8A27786"; const approveForStake = async (userAddress, contractAddress, amount) => { const tokenContract = new web3/* default */.A.eth.Contract(abis_GENERIC_ABIS.token, autolayerTokenAddress); const allowance = await tokenContract.methods.allowance(userAddress, contractAddress).call(); let txHash = ""; if (allowance < amount) { txHash = (await tokenContract.methods.approve(contractAddress, amount).send({ from: userAddress })).transactionHash } return txHash }; const stake_stake = async (userAddress, contractAddress, amount) => { const contract = new web3/* default */.A.eth.Contract(StakingAbi_stakingAbi, contractAddress); const estimatedGas = await contract.methods.stake(amount).estimateGas({ from: userAddress }); const stakeTx = await contract.methods.stake(amount).send({ from: userAddress, gas: estimatedGas.toString() }); return stakeTx.transactionHash }; const unstake = async (userAddress, contractAddress, positionId) => { const contract = new web3/* default */.A.eth.Contract(StakingAbi_stakingAbi, contractAddress); const estimatedGas = await contract.methods.unstake(positionId).estimateGas({ from: userAddress }); const unstakeTx = await contract.methods.unstake(positionId).send({ from: userAddress, gas: estimatedGas.toString() }); return unstakeTx.transactionHash }; const claimReward = async (userAddress, contractAddress, positionId) => { const contract = new web3/* default */.A.eth.Contract(StakingAbi_stakingAbi, contractAddress); const estimatedGas = await contract.methods.claimReward(positionId).estimateGas({ from: userAddress }); const claimRewardsTx = await contract.methods.claimReward(positionId).send({ from: userAddress, gas: estimatedGas.toString() }); return claimRewardsTx.transactionHash }; const stakeReward = async (userAddress, contractAddress, positionId) => { const contract = new web3/* default */.A.eth.Contract(StakingAbi_stakingAbi, contractAddress); const estimatedGas = await contract.methods.stakeReward(positionId).estimateGas({ from: userAddress }); const stakeRewardTx = await contract.methods.stakeReward(positionId).send({ from: userAddress, gas: estimatedGas.toString() }); return stakeRewardTx.transactionHash };
        ;// ./src/components/Stake/StakeDialog/Steps/StakeDialogSteps.tsx
        const DoneStatus = ({ text, txHash }) => { const networkParams = getNetworkParams("0x38"); const networkScan = networkParams.blockExplorerUrls[0]; const scanLink = networkScan + "tx/" + txHash; const { scanName } = getItemByNetwork("0x38"); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "done", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: scanLink, target: "_blank", className: "ftm-link", rel: "noreferrer", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: SmallIcons.linkGrey, alt: "link icon" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "deposit-step-scan.link", values: { scan: scanName } }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-dialog.steps.done-staking" }) })] }) }; const SuccessStatus = ({ text }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "success", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle success" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${text}.success` }) })] }) }; const ErrorStatus = ({ text }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "error", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${text}.error` }) })] }) }; const LoadingStatus = ({ text }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "loading", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${text}.loading` }) })] }) }; function StakeDialogSteps({ children, steps }) { const statusRecord = { success: SuccessStatus, error: ErrorStatus, loading: LoadingStatus, done: DoneStatus }; if (!steps.length) { return children } return /*#__PURE__*/(0, jsx_runtime.jsx)("section", { className: "stake-dialog-steps", children: steps.map((step, index) => { const Component = statusRecord[step.type]; return /*#__PURE__*/(0, jsx_runtime.jsx)(Component, { text: step.text, txHash: step.extra?.["txHash"] }, index) }) }) }/* harmony default export */ const Steps_StakeDialogSteps = (StakeDialogSteps);
        ;// ./src/components/Stake/StakeDialog/Types/StakeDialogStake/StakeDialogStake.tsx
        const BalanceLAY3R = ({ userAddress }) => { const balance = hooks_usePromise(getRealWeiTokenBalance, "lay3r", userAddress, "0x38"); const visualBalance = balance ? +balance.toString() / 10 ** 18 : 0; return /*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [visualBalance.toFixed(4), " LAY3R"] }) }; function StakeDialogStake({ poolAddress, updateRefreshKey, stepsData }) { const { addStep, successStep, errorStep, steps, setDone, resetSteps } = stepsData; const address = useWallet_useWallet(); const [enabled, setEnabled] = (0, react.useState)(false); const availableCapacity = useGetAvailableCapacity(poolAddress); const handleOnSubmit = async e => { e.preventDefault(); const weiAmount = e.target[5].dataset.wei; const weiAvailableCapacity = BigInt(availableCapacity * 10 ** 18); const amountWei = weiAmount > weiAvailableCapacity ? weiAvailableCapacity : weiAmount; addStep("stake.staking-dialog.stake.approved"); try { await approveForStake(address, poolAddress, amountWei); successStep() } catch (error) { console.error("Error approving for stake", error); errorStep(); return } try { addStep("stake.staking-dialog.stake.confirmation"); const stakeTxHash = await stake_stake(address, poolAddress, amountWei); successStep({ txHash: stakeTxHash }); setDone("stake.staking-dialog.steps.done-staking", stakeTxHash); updateRefreshKey() } catch (err) { errorStep() } }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("form", { onSubmit: handleOnSubmit, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { className: "balance", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "pool-token-table.balance" }), ":", " ",/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "0 LAY3R" }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(BalanceLAY3R, { userAddress: address }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { className: "available", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.max-available-amount" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [availableCapacity?.toFixed(2), " LAY3R"] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(TokenInput, { className: "stake", handleExternalChange: value => { resetSteps(); if (value === 0) { setEnabled(false) } else if (enabled === false) { setEnabled(true) } }, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.autolayerIconWhite, alt: "$LAY3R logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "$LAY3R" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Steps_StakeDialogSteps, { steps: steps, children:/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "continue", type: "submit", disabled: !enabled, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) }) })] }) }
        ;// ./src/components/Stake/StakeDialog/Types/StakeDialogUntstake/StakeDialogUnstake.tsx
        function StakeDialogUnstake({ poolAddress, positionId, updateRefreshKey, stepsData }) { const address = useWallet_useWallet(); const positionData = useStakingPosition(address, positionId, poolAddress); const { currentAmount } = positionData; const [enabled, setEnabled] = (0, react.useState)(true); const { addStep, errorStep, resetSteps, setDone, steps, successStep } = stepsData; const handleUnstake = async e => { e.preventDefault(); try { addStep("stake.staking-dialog.stake.confirmation"); const tx = await unstake(address, poolAddress, positionId); successStep(); setDone("stake.staking-dialog.steps.done-unstaking", tx); updateRefreshKey() } catch (err) { console.error("Error unstaking", err); errorStep() } }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("form", { onSubmit: handleUnstake, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenInput, { className: "stake", disabled: true, initialValue: currentAmount, handleExternalChange: value => { resetSteps(); if (value === 0) setEnabled(false) }, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.autolayerIconWhite, alt: "$LAY3R logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "$LAY3R" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Steps_StakeDialogSteps, { steps: steps, children:/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "continue", disabled: !enabled, type: "submit", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) }) })] }) }
        ;// ./src/components/Stake/StakeDialog/Types/StakeDialogClaimReward/StakeDialogClaimReward.tsx
        function StakeDialogClaimReward({ initialValue, poolAddress, positionId, updateRefreshKey, stepsData }) { const address = useWallet_useWallet(); const { addStep, successStep, errorStep, steps, setDone } = stepsData; const handleClaimRewards = async e => { e.preventDefault(); try { addStep("stake.staking-dialog.stake.confirmation"); const tx = await claimReward(address, poolAddress, positionId); successStep(); setDone("stake.staking-dialog.steps.done-claim", tx); updateRefreshKey() } catch (err) { console.error("Error claiming rewards", err); errorStep() } }; return /*#__PURE__*/(0, jsx_runtime.jsxs)("form", { onSubmit: handleClaimRewards, children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenInput, { className: "stake", disabled: true, initialValue: initialValue, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.autolayerIconWhite, alt: "$LAY3R logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "$LAY3R" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Steps_StakeDialogSteps, { steps: steps, children:/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "continue", disabled: initialValue === 0, type: "submit", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) }) })] }) }
        ;// ./src/components/Stake/StakeDialog/Types/StakeDialogStakeReward/StakeDialogStakeReward.tsx
        function StakeDialogStakeReward({ initialValue, poolAddress, positionId, updateRefreshKey, stepsData }) { const address = useWallet_useWallet(); const { addStep, successStep, errorStep, steps, setDone } = stepsData; const handleStakeRewards = async () => { try { addStep("stake.staking-dialog.stake.confirmation"); const tx = await stakeReward(address, poolAddress, positionId); successStep(); setDone("stake.staking-dialog.steps.done-restake", tx); updateRefreshKey() } catch (err) { console.error("Error staking rewards", err); errorStep() } }; return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TokenInput, { className: "stake", disabled: true, initialValue: initialValue, children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: AutolayerLogos.autolayerIconWhite, alt: "$LAY3R logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "$LAY3R" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(Steps_StakeDialogSteps, { steps: steps, children:/*#__PURE__*/(0, jsx_runtime.jsx)("button", { className: "continue", onClick: handleStakeRewards, disabled: initialValue === 0, children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "continue" }) }) })] }) }
        ;// ./src/hooks/useDialogSteps.ts
        function useDialogSteps() { const [steps, setSteps] = (0, react.useState)([]); const addStep = text => setSteps(prev => [...prev, { type: "loading", text }]); const resetSteps = () => setSteps([]); const modifyStep = (type, extras) => { setSteps(prev => { const copyPrev = [...prev]; const lastStep = copyPrev.at(-1); lastStep.type = type; lastStep.extra = extras; return [...copyPrev.slice(0, -1), lastStep] }) }; const successStep = extras => modifyStep("success", extras); const errorStep = extras => modifyStep("error", extras); const setDone = (message, txHash) => setSteps(prev => [...prev, { type: "done", text: message, extra: { txHash } }]); return { successStep, errorStep, addStep, setDone, resetSteps, steps } }
        ;// ./src/components/Stake/StakeDialog/StakeDialog.tsx
        const typesRecord = { stake: StakeDialogStake, unstake: StakeDialogUnstake, claim: StakeDialogClaimReward, rewards: StakeDialogStakeReward }; const StakeDialog =/*#__PURE__*/(0, react.forwardRef)(({ updateRefreshKey }, ref) => { const dialogRef = (0, react.useRef)(); const [data, setData] = (0, react.useState)({ poolAddress: "", type: "stake", initialValue: 0, positionId: 0 }); const steps = useDialogSteps(); const Component = typesRecord[data.type]; const close = () => { dialogRef.current?.close(); steps.resetSteps() }; (0, react.useImperativeHandle)(ref, () => ({ open: data => { setData(data); dialogRef.current?.showModal() }, close })); return /*#__PURE__*/(0, jsx_runtime.jsxs)("dialog", { id: "stake-dialog", ref: dialogRef, children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children: stake.chooseDialogLabel(data.type) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { title: "Close dialog", onClick: close, autoFocus: true, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "spinner-fallback", children:/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}) }), children:/*#__PURE__*/(0, jsx_runtime.jsx)(Component, { initialValue: data.initialValue, poolAddress: data.poolAddress, positionId: data.positionId, updateRefreshKey: updateRefreshKey, stepsData: steps }) })] }) }); StakeDialog.displayName = "Stake Dialog";/* harmony default export */ const StakeDialog_StakeDialog = (StakeDialog);
        ;// ./src/static/vectors/binance.svg
        const vectors_binance_namespaceObject = __webpack_require__.p + "static/binance.484384cd058714629388.svg";
        ;// ./src/components/Meta/StakeMeta.tsx
        function StakeMeta() { const image = "https://i.imgur.com/zfu24im.png"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: "https://app.autolayer.io/stake/" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image })] }) }
        ;// ./src/routes/Stake/Stake.tsx
        const { pool1: Stake_pool1, pool2: Stake_pool2, pool3: Stake_pool3, pool4: Stake_pool4 } = binancePools; function Stake() { const address = useWallet_useWallet(); const { width } = hooks_useWindowDimensions(); const userWalletChainId = hooks_useWalletChainId(); const [mobile, setMobile] = (0, react.useState)(true); const stakeDialogRef = (0, react.useRef)(null); const [refreshKey, setRefreshKey] = (0, react.useState)(0); const openDialog = data => stakeDialogRef.current.open(data); const updateRefreshKey = () => setRefreshKey(prev => ++prev); const isMobile = width < 820; (0, react.useEffect)(() => { setMobile(isMobile) }, [isMobile]); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(StakeMeta, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "stake", className: "page", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(DashboardHeader, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "banner", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("header", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.banner.title" }) }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(BannerItem, { address: address, stakeKey: "totalStakedAmount", title: "stake.banner.items.total" }),/*#__PURE__*/(0, jsx_runtime.jsx)(BannerItem, { address: address, stakeKey: "usd", title: "stake.banner.items.usd" }), userWalletChainId === Networks.binance ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(BannerItem, { address: address, stakeKey: "userStakedAmount", title: "stake.banner.items.userStake" }),/*#__PURE__*/(0, jsx_runtime.jsx)(BannerItem, { address: address, stakeKey: "rewards", title: "stake.banner.items.rewards" })] }) :/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "banner-item binance", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("span", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "change-network-to" }), " Stake"] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { className: "change-network", onClick: () => changeChain(Networks.binance), children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: vectors_binance_namespaceObject, alt: "Binance Network logo" }),/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "change-to-bsc" })] })] })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "stake.staking-data.title" }) }), mobile ?/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "staking-data-container mobile", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(StakingDataMobile, { open: openDialog, apy: Stake_pool1.apy, image: Stake_pool1.logo, name: Stake_pool1.name, lockTime: Stake_pool1.lockTerm, maxCapacity: Stake_pool1.maxCapacity, poolAddress: Stake_pool1.address, refreshKey: refreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingDataMobile, { open: openDialog, apy: Stake_pool3.apy, image: Stake_pool3.logo, name: Stake_pool3.name, lockTime: Stake_pool3.lockTerm, maxCapacity: Stake_pool3.maxCapacity, poolAddress: Stake_pool3.address, refreshKey: refreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingDataMobile, { open: openDialog, apy: Stake_pool4.apy, image: Stake_pool4.logo, name: Stake_pool4.name, lockTime: Stake_pool4.lockTerm, maxCapacity: Stake_pool4.maxCapacity, poolAddress: Stake_pool4.address, refreshKey: refreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakingDataMobile, { open: openDialog, apy: Stake_pool2.apy, image: Stake_pool2.logo, name: Stake_pool2.name, lockTime: Stake_pool2.lockTerm, maxCapacity: Stake_pool2.maxCapacity, poolAddress: Stake_pool2.address, refreshKey: refreshKey })] }, refreshKey) :/*#__PURE__*/(0, jsx_runtime.jsx)(StakingDataDesktop, { open: openDialog, refreshKey: refreshKey }, refreshKey)] }),/*#__PURE__*/(0, jsx_runtime.jsx)(StakeDialog_StakeDialog, { ref: stakeDialogRef, updateRefreshKey: updateRefreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) }
        ;// ./src/routes/Referrals/Grids/ReferralsCard/ReferralsCard.tsx
        const ReferralsCard = ({ type, text, amount = 0, icon, status }) => { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "referrals-info-card", id: `${type + "-" + text}-card`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `referrals-info-card.title.${text}` }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { className: "amount", children: status === "loading" ?/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}) : status === "error" ?/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "referrals-info-card-error", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "error-loading-your-values" }) }) : amount }), icon] })] }) };/* harmony default export */ const ReferralsCard_ReferralsCard = (ReferralsCard);
        ;// ./src/routes/Referrals/ReferralsDialog/IntroduceCode/IntroduceCode.tsx
        function IntroduceCode({ type, description, error, txHash, handleClose, handleSubmit, revertError, loading }) { const [code, setCode] = (0, react.useState)(""); const networkId = (0, es/* useSelector */.d4)(s => s.network); const intl = (0, useIntl/* default */.A)(); const networkParams = getNetworkParams(networkId); const explorerBaseUrl = networkParams.blockExplorerUrls[0]; const scanLink = `${explorerBaseUrl}tx/${txHash}`; const { scanName } = getItemByNetwork(networkId); const commonInit = `referrals.dialog.${type}`; const handleSubmitForm = e => { e.preventDefault(); handleSubmit(code) }; const handleChange = e => { const newValue = e.target.value; setCode(newValue); if (error) revertError() }; return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.title` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: handleClose, children:/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-close" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("main", { className: error ? "has-errors" : txHash ? "success" : "", children: [description ?/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "description", children: description }) : null,/*#__PURE__*/(0, jsx_runtime.jsxs)("form", { onSubmit: handleSubmitForm, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "code", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("label", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.input.label` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("input", { placeholder: intl.formatMessage({ id: `${commonInit}.input.placeholder` }), type: "text", required: true, name: "code", value: code, onChange: handleChange })] }) }), error ?/*#__PURE__*/(0, jsx_runtime.jsxs)("p", { className: "error", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle failed" }), intl.formatMessage({ id: error })] }) : null, txHash ?/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "successful", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "circle done" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.success` }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("a", { href: scanLink, target: "_blank", className: "ftm-link", rel: "noreferrer", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: SmallIcons.linkGrey, alt: "link icon" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(markdown_message_es/* default */.A, { id: "deposit-step-scan.link", values: { scan: scanName } }) })] })] }) : null,/*#__PURE__*/(0, jsx_runtime.jsx)("button", { type: "submit", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.button` }) }), loading ?/*#__PURE__*/(0, jsx_runtime.jsx)(Spinner_Spinner, {}) : null] }), type === "create" &&/*#__PURE__*/(0, jsx_runtime.jsx)("p", { id: "referrals-network-advice", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.advice" }) })] })] }) }
        ;// ./src/contracts/abis/AutoLayerAbis/ReferalsAbi.ts
        const referalsAbi = [{ type: "constructor", inputs: [], stateMutability: "nonpayable" }, { type: "function", name: "claimReferal", inputs: [{ name: "referalCode", type: "string", internalType: "string" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "createReferal", inputs: [{ name: "referalCode", type: "string", internalType: "string" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "getReferalCode", inputs: [{ name: "code", type: "string", internalType: "string" }], outputs: [{ name: "", type: "tuple", internalType: "struct ReferalsUtils.ReferalCode", components: [{ name: "owner", type: "address", internalType: "address" }, { name: "users", type: "address[]", internalType: "address[]" }, { name: "volumeUsd", type: "uint256", internalType: "uint256" }, { name: "usageCount", type: "uint256", internalType: "uint256" }, { name: "pointsObtained", type: "uint256", internalType: "uint256" }] }], stateMutability: "view" }, { type: "function", name: "getReferalCodes", inputs: [{ name: "wallet", type: "address", internalType: "address" }], outputs: [{ name: "", type: "string[]", internalType: "string[]" }], stateMutability: "view" }, { type: "function", name: "getUserReferal", inputs: [{ name: "user", type: "address", internalType: "address" }], outputs: [{ name: "", type: "tuple", internalType: "struct ReferalsUtils.RefereeStats", components: [{ name: "referalCode", type: "string", internalType: "string" }, { name: "volumeUsd", type: "uint256", internalType: "uint256" }, { name: "usageCount", type: "uint256", internalType: "uint256" }, { name: "pointsObtained", type: "uint256", internalType: "uint256" }] }], stateMutability: "view" }, { type: "function", name: "isAllowed", inputs: [{ name: "", type: "address", internalType: "address" }], outputs: [{ name: "", type: "bool", internalType: "bool" }], stateMutability: "view" }, { type: "function", name: "owner", inputs: [], outputs: [{ name: "", type: "address", internalType: "address" }], stateMutability: "view" }, { type: "function", name: "removeAllowed", inputs: [{ name: "notAllowedAddress_", type: "address", internalType: "address" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "renounceOwnership", inputs: [], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "setAllowed", inputs: [{ name: "allowedAddress_", type: "address", internalType: "address" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "trackTransaction", inputs: [{ name: "user", type: "address", internalType: "address" }, { name: "referalCode", type: "string", internalType: "string" }, { name: "volumeUsd", type: "uint256", internalType: "uint256" }, { name: "referalPoints", type: "uint256", internalType: "uint256" }, { name: "refereePoints", type: "uint256", internalType: "uint256" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "transferOwnership", inputs: [{ name: "newOwner", type: "address", internalType: "address" }], outputs: [], stateMutability: "nonpayable" }, { type: "function", name: "userCodes", inputs: [{ name: "", type: "address", internalType: "address" }, { name: "", type: "uint256", internalType: "uint256" }], outputs: [{ name: "", type: "string", internalType: "string" }], stateMutability: "view" }, { type: "event", name: "CodeClaimed", inputs: [{ name: "user", type: "address", indexed: false, internalType: "address" }, { name: "code", type: "string", indexed: false, internalType: "string" }], anonymous: false }, { type: "event", name: "CodeCreated", inputs: [{ name: "user", type: "address", indexed: false, internalType: "address" }, { name: "code", type: "string", indexed: false, internalType: "string" }], anonymous: false }, { type: "event", name: "OwnershipTransferred", inputs: [{ name: "previousOwner", type: "address", indexed: true, internalType: "address" }, { name: "newOwner", type: "address", indexed: true, internalType: "address" }], anonymous: false }];
        ;// ./src/utils/referals.ts
        function getTotalReferal(allCodes, key) { const total = allCodes.map(codeStats => key === "users" ? codeStats[key].length : +codeStats[key]).reduce((acc, curr) => acc + curr, 0); return total } function getValue(value, networkId) { const web3 = contracts_web3(getNetworkName(networkId)); return +Number(web3.utils.fromWei(value.toString(), "ether")).toFixed(2) } async function createReferalCode(code, wallet, networkId) { const referalsContract = new web3/* default */.A.eth.Contract(referalsAbi, REFERALS_CONTRACT[networkId]); const tx = await referalsContract.methods.createReferal(code).send({ from: wallet }); return tx.transactionHash } async function getCreatedReferalCodes(wallet, web3, networkId) { const referalsContract = new web3.eth.Contract(referalsAbi, REFERALS_CONTRACT[networkId]); const createdCodes = await referalsContract.methods.getReferalCodes(wallet).call(); return createdCodes } async function claimCode(wallet, code, networkId) { const referalsContract = new web3/* default */.A.eth.Contract(referalsAbi, REFERALS_CONTRACT[networkId]); const tx = await referalsContract.methods.claimReferal(code).send({ from: wallet }); return tx.transactionHash } async function getReferalCode(code, web3, networkId) { const referalsContract = new web3.eth.Contract(referalsAbi, REFERALS_CONTRACT[networkId]); const codeData = await referalsContract.methods.getReferalCode(code).call(); return codeData } async function getCreatedCodesData(wallet, web3, networkId) { const codes = await getCreatedReferalCodes(wallet, web3, networkId); const result = []; for (const code of codes) { const codeData = await getReferalCode(code, web3, networkId); const { volumeUsd, usageCount, pointsObtained, users } = codeData; result.push({ volumeUsd, usageCount, pointsObtained, name: code, users }) } return result } async function getUserReferal(wallet, web3, networkId) { const referalsContract = new web3.eth.Contract(referalsAbi, REFERALS_CONTRACT[networkId]); const refereeStats = await referalsContract.methods.getUserReferal(wallet).call(); return refereeStats } async function checkUserClaimedCode(wallet, web3, networkId) { const refereeStats = await getUserReferal(wallet, web3, networkId); return refereeStats.referalCode !== "" } const referalUtils = { createReferalCode, getCreatedReferalCodes, claimCode, getCreatedCodesData, checkUserClaimedCode, getUserReferal, getTotalReferal, getValue, getReferalCode };/* harmony default export */ const referals = (referalUtils);
        ;// ./src/routes/Referrals/ReferralsDialog/CreateCode.tsx
        function CreateCode({ handleClose, refresh }) { const networkId = (0, es/* useSelector */.d4)(s => s.network); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const [firstCode, setFirstCode] = (0, react.useState)(true); const [error, setError] = (0, react.useState)(null); const [loading, setLoading] = (0, react.useState)(false); const [txHash, setTxHash] = (0, react.useState)(null); const intl = (0, useIntl/* default */.A)(); (0, react.useEffect)(() => { const web3 = contracts_web3(getNetworkName(networkId)); referals.getCreatedReferalCodes(wallet?.address, web3, networkId).then(codes => setFirstCode(codes.length === 0)) }, [networkId, wallet?.address]); const handleCreate = async code => { try { setTxHash(null); setLoading(true); const codeData = await referals.getReferalCode(code, web3/* default */.A, networkId); if (parseInt(codeData.owner) !== 0) { setError(intl.formatMessage({ id: "referrals.dialog.create.error.claimed" })); return } const tx = await referals.createReferalCode(code, wallet?.address, networkId); setTxHash(tx); refresh() } catch (err) { setError(intl.formatMessage({ id: "referrals.dialog.error" })) } finally { setLoading(false) } }; const commonInit = `referrals.dialog.create`; return /*#__PURE__*/(0, jsx_runtime.jsx)(IntroduceCode, { type: "create", error: error, handleClose: handleClose, handleSubmit: handleCreate, revertError: () => setError(null), loading: loading, txHash: txHash, description: firstCode ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.description-1` }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.description-2` }) })] }) : null }) }
        ;// ./src/routes/Referrals/ReferralsDialog/InsertCode.tsx
        function InsertCode({ handleClose, refresh }) { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const networkId = (0, es/* useSelector */.d4)(s => s.network); const [txHash, setTxHash] = (0, react.useState)(null); const [error, setError] = (0, react.useState)(null); const [loading, setLoading] = (0, react.useState)(false); const intl = (0, useIntl/* default */.A)(); const startError = "referrals.dialog.insert.error"; const handleClaim = async code => { setTxHash(null); setLoading(true); try { const userReferal = await referals.getUserReferal(wallet?.address, web3/* default */.A, networkId); const codeData = await referals.getReferalCode(code, web3/* default */.A, networkId); if (userReferal.referalCode.length !== 0) { setError(`${startError}.claimed`); return } else if (parseInt(codeData.owner, 16) === 0) { setError(`${startError}.not-exists`); return } else if (codeData.owner.toLowerCase() === wallet?.address) { setError(`${startError}.same-owner`); return } const txHash = await referals.claimCode(wallet.address, code, networkId); setTxHash(txHash); refresh() } catch (err) { console.warn("Code not claimed", err); setError(intl.formatMessage({ id: "referrals.dialog.error" })) } finally { setLoading(false) } }; const commonInit = `referrals.dialog.insert`; return /*#__PURE__*/(0, jsx_runtime.jsx)(IntroduceCode, { type: "insert", error: error, loading: loading, handleClose: handleClose, handleSubmit: handleClaim, revertError: () => setError(null), txHash: txHash, description:/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: `${commonInit}.description` }) }) }) }
        ;// ./src/routes/Referrals/ReferralsDialog/ReferralsDialog.tsx
        const ReferralsDialog = ({ handleClose, type, refresh }) => { return /*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "referrals-dialog", children:/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children: "Error" }), children: type === "create" ?/*#__PURE__*/(0, jsx_runtime.jsx)(CreateCode, { handleClose: handleClose, refresh: refresh }) :/*#__PURE__*/(0, jsx_runtime.jsx)(InsertCode, { handleClose: handleClose, refresh: refresh }) }) }) };/* harmony default export */ const ReferralsDialog_ReferralsDialog = (ReferralsDialog);
        ;// ./src/static/vectors/copy.svg
        const vectors_copy_namespaceObject = __webpack_require__.p + "static/copy.18f680137021dc8c98d9.svg";
        ;// ./src/components/Referrals/AffiliatesCards/CardEntry/CardEntry.tsx
        function CardEntry({ code, points, traders, volume }) { const copyToClipboard = () => navigator.clipboard.writeText(code); return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "affiliate-card", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children: code }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: copyToClipboard, children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: vectors_copy_namespaceObject, alt: "copy icon" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("main", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "head", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.volume" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children: volume })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "head", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.trader" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children: traders })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("footer", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals-info-card.title.points-earned" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value", children: points })] })] }) }
        ;// ./src/components/Referrals/AffiliatesCards/CardEntry/CardEntryFallback.tsx
        function CardEntryFallback() { return /*#__PURE__*/(0, jsx_runtime.jsxs)("article", { className: "affiliate-card fallback", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", {}),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: vectors_copy_namespaceObject, alt: "copy icon" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("main", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "head", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.volume" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "head", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.trader" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value" })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("footer", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals-info-card.title.points-earned" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "value" })] })] }) }
        ;// ./src/components/NetworkWithLogo/NetworkWithLogo.tsx
        function NetworkWithLogo() { const networkId = (0, es/* useSelector */.d4)(s => s.network); const networkName = getNetworkName(networkId); return /*#__PURE__*/(0, jsx_runtime.jsxs)("span", { id: "network-with-logo", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: networkVectors[networkName] ?? networkVectors[DEFAULT_NETWORK_NAME], alt: `${networkChoice_namespaceObject[networkName]?.label ?? DEFAULT_NETWORK_NAME} Logo` }),/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children: networkChoice_namespaceObject[networkName]?.label ?? DEFAULT_NETWORK_NAME })] }) }
        ;// ./src/components/Referrals/AffiliatesCards/AffiliatesCards.tsx
        function AffiliatesCards({ codes, openDialog, loading }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "affiliates-cards", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: openDialog, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-plus" }),/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "start-inviting" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(NetworkWithLogo, {}) }), loading ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(CardEntryFallback, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(CardEntryFallback, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(CardEntryFallback, {})] }) : codes.map((codeData, i) =>/*#__PURE__*/(0, jsx_runtime.jsx)(CardEntry, { code: codeData.name, points: codeData.pointsObtained, traders: codeData.usageCount, volume: codeData.volumeUsd }, i))] }) }
        ;// ./src/components/Referrals/AffiliatesTable/TableRow/TableRow.tsx
        function TableRow({ code, points, traders, volume }) { const copyToClipboard = () => navigator.clipboard.writeText(code); return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "code", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: code }),/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: copyToClipboard, children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: vectors_copy_namespaceObject, alt: "copy icon" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "volume", children:/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: volume, currency: "USD", currencyDisplay: "symbol", style: "currency" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "traders", children: traders }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "points", children:/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: points, style: "decimal", maximumFractionDigits: 2 }) })] }) }
        ;// ./src/components/Referrals/AffiliatesTable/TableRow/TableRowFallback.tsx
        function TableRowFallback() { return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "row fallback", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "code" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "volume" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "traders" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "points" })] }) }
        ;// ./src/components/Referrals/AffiliatesTable/AffiliatesTable.tsx
        function AffiliatesTable({ openDialog, codes, loading }) { return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "affiliates-table", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("header", { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "title", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h3", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.title" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(NetworkWithLogo, {})] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("button", { onClick: openDialog, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "icon icon-plus" }),/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "start-inviting" })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "table-header", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.code" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.volume" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals.affiliates.header.trader" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "referrals-info-card.title.points-earned" }) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("main", { children: loading ?/*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(TableRowFallback, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(TableRowFallback, {}),/*#__PURE__*/(0, jsx_runtime.jsx)(TableRowFallback, {})] }) : codes.map((code, i) =>/*#__PURE__*/(0, jsx_runtime.jsx)(TableRow, { code: code.name, points: code.pointsObtained, traders: code.usageCount, volume: code.volumeUsd }, i)) })] }) }
        ;// ./src/routes/Referrals/Grids/AffiliatesData.tsx
        function AffiliatesData({ handleOpen, allCodes, loading }) { const { width } = hooks_useWindowDimensions(); const isMobile = width < 460; return isMobile ?/*#__PURE__*/(0, jsx_runtime.jsx)(AffiliatesCards, { codes: allCodes, loading: loading, openDialog: handleOpen }) :/*#__PURE__*/(0, jsx_runtime.jsx)(AffiliatesTable, { openDialog: handleOpen, codes: allCodes, loading: loading }) }
        ;// ./src/routes/Referrals/Grids/Affiliates.tsx
        const Affiliates = () => { const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const networkId = (0, es/* useSelector */.d4)(s => s.network); const [showDialog, setShowDialog] = (0, react.useState)(false); const [allCodes, setAllCodes] = (0, react.useState)([]); const [loading, setLoading] = (0, react.useState)(false); const [error, setError] = (0, react.useState)(false); const [refreshKey, setRefreshKey] = (0, react.useState)(0); const handleClose = () => setShowDialog(false); const handleOpen = () => setShowDialog(true); const refresh = (0, react.useCallback)(() => setRefreshKey(prev => prev + 1), []); (0, react.useEffect)(() => { if (!wallet?.address) return; setLoading(true); const web3 = contracts_web3(getNetworkName(networkId)); const getAllCodes = async () => { const codeData = await referals.getCreatedCodesData(wallet?.address, web3, networkId); const newCodeData = codeData.map(entry => ({ ...entry, pointsObtained: referals.getValue(entry.pointsObtained, networkId), volumeUsd: referals.getValue(entry.volumeUsd, networkId) })); setAllCodes(newCodeData) }; getAllCodes().catch(() => setError(true)).finally(() => setLoading(false)) }, [networkId, wallet?.address, refreshKey]); const totalValues = (0, react.useMemo)(() => ({ totalUsers: referals.getTotalReferal(allCodes, "users"), totalVolume: referals.getTotalReferal(allCodes, "volumeUsd"), totalPoints: referals.getTotalReferal(allCodes, "pointsObtained") }), [allCodes]); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "affiliates", className: "referrals-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { text: "referrals-traders", type: "affiliates", amount: totalValues.totalUsers, status: !error ? loading ? "loading" : "done" : "error" }),/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { text: "trading-volume", type: "affiliates", amount:/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: totalValues.totalVolume, currency: "USD", currencyDisplay: "narrowSymbol", style: "currency" }), status: !error ? loading ? "loading" : "done" : "error" }),/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { text: "points-earned", type: "affiliates", amount: totalValues.totalPoints, status: !error ? loading ? "loading" : "done" : "error" })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(AffiliatesData, { handleOpen: handleOpen, allCodes: allCodes, loading: loading }), showDialog &&/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsDialog_ReferralsDialog, { handleClose: handleClose, type: "create", refresh: refresh })] }) };/* harmony default export */ const Grids_Affiliates = (Affiliates);
        ;// ./src/static/vectors/edit.svg
        const edit_namespaceObject = __webpack_require__.p + "static/edit.565ad1973f708be25a6f.svg";
        ;// ./src/routes/Referrals/Grids/Traders.tsx
        const Traders = () => { const networkId = (0, es/* useSelector */.d4)(s => s.network); const wallet = (0, es/* useSelector */.d4)(s => s.wallet); const [showDialog, setShowDialog] = (0, react.useState)(false); const [refereeStats, setRefereeStats] = (0, react.useState)(null); const [error, setError] = (0, react.useState)(false); const [loading, setLoading] = (0, react.useState)(false); const firstRenderRef = (0, react.useRef)(true); const handleClose = () => setShowDialog(false); const handleOpen = () => setShowDialog(true); const [refreshKey, setRefreshKey] = (0, react.useState)(0); const refresh = (0, react.useCallback)(() => setRefreshKey(prev => prev + 1), []); (0, react.useEffect)(() => { if (!wallet?.address) return; setLoading(true); const web3 = contracts_web3(getNetworkName(networkId)); referals.getUserReferal(wallet.address, web3, networkId).then(refereeStats => { const newRefereeStats = { ...refereeStats, pointsObtained: referals.getValue(refereeStats.pointsObtained, networkId), volumeUsd: referals.getValue(refereeStats.volumeUsd, networkId) }; setRefereeStats(newRefereeStats); if (firstRenderRef.current) { setShowDialog(refereeStats.referalCode === "") } firstRenderRef.current = false }).catch(() => setError(true)).finally(() => setLoading(false)) }, [wallet?.address, networkId, refreshKey]); const status = error ? "error" : loading ? "loading" : "done"; return /*#__PURE__*/(0, jsx_runtime.jsx)(jsx_runtime.Fragment, { children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "traders", className: "referrals-grid", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { type: "traders", text: "active-code", amount: refereeStats?.referalCode, status: status, icon: !refereeStats?.referalCode ?/*#__PURE__*/(0, jsx_runtime.jsx)("button", { onClick: handleOpen, className: "icon", children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: edit_namespaceObject, alt: "edit icon", onClick: handleOpen }) }) : null }),/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { type: "traders", text: "trading-volume", status: status, amount:/*#__PURE__*/(0, jsx_runtime.jsx)(lib/* FormattedNumber */.Gr, { value: refereeStats?.volumeUsd, currency: "USD", currencyDisplay: "narrowSymbol", style: "currency" }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsCard_ReferralsCard, { type: "traders", text: "points-earned", status: status, amount: refereeStats?.pointsObtained }), showDialog &&/*#__PURE__*/(0, jsx_runtime.jsx)(ReferralsDialog_ReferralsDialog, { handleClose: handleClose, type: "insert", refresh: refresh })] }) }) };/* harmony default export */ const Grids_Traders = (Traders);
        ;// ./src/components/Meta/AuBNBMeta.tsx
        function AuBNBMeta() { const intl = (0, useIntl/* default */.A)(); const title = intl.formatMessage({ id: "meta.aubnb.title" }); const description = intl.formatMessage({ id: "meta.aubnb.description" }); const image = "https://i.imgur.com/ZHxcJU7.png"; return /*#__PURE__*/(0, jsx_runtime.jsxs)(lib_index_esm/* Helmet */.mg, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("title", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:type", content: "website" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:url", content: "https://app.autolayer.io/info/aubnb" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image", content: image }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:width", content: "1200" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:image:height", content: "630" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { property: "og:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:card", content: "summary_large_image" }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:title", content: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:description", content: description }),/*#__PURE__*/(0, jsx_runtime.jsx)("meta", { name: "twitter:image", content: image })] }) }
        ;// ./src/routes/ProductInfo/MiddleInfo/MiddleAuBnbInfo/APYs/AuBnbApy.tsx
        const AuBnbApy = ({ title, value }) => { const finalValue = value < 0 ?/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "coming-soon" }) : value + "%"; return /*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: `apy-aubnb-box`, children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: title }),/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: finalValue })] }) };/* harmony default export */ const APYs_AuBnbApy = (AuBnbApy);
        ;// ./src/utils/time.ts
        const APY = 52.1; function generateAuBnbChart() { const result = []; const startDate = new Date(2024, 10, 11, 0, 0, 0); const actual = new Date; actual.setHours(0, 0, 0, 0); const currentDate = startDate; while (currentDate <= actual) { result.push({ value: APY, timestamp: currentDate.toISOString() }); currentDate.setDate(currentDate.getDate() + 1) } return result }
        ;// ./src/routes/ProductInfo/MiddleInfo/MiddleAuBnbInfo/MiddleAuBnbInfo.tsx
        const MiddleAuBnbInfo = () => { const fallbackData = generateAuBnbChart(); const auBnb = BinanceData.auBnb; return /*#__PURE__*/(0, jsx_runtime.jsxs)("section", { id: "aubnb-middle-section", className: "middle-section", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "top-aubnb-info", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: getTokenImage("aubnb"), alt: "aubnb", className: "lrs-img" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("h3", { children: ["Au",/*#__PURE__*/(0, jsx_runtime.jsx)("strong", { children: "BNB" })] })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "tvl-info", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children: "TVL" }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "coming-soon" }) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "description", children:/*#__PURE__*/(0, jsx_runtime.jsx)("p", { children: auBnb.description }) }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "apy-boxes", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(APYs_AuBnbApy, { value: 52.1, title: "APR" }),/*#__PURE__*/(0, jsx_runtime.jsx)(APYs_AuBnbApy, { value: .1, title: "BNB Staking Rewards" }),/*#__PURE__*/(0, jsx_runtime.jsx)(APYs_AuBnbApy, { value: -1, title: "Restaking Rewards" }),/*#__PURE__*/(0, jsx_runtime.jsx)(APYs_AuBnbApy, { value: 52, title: "AutoLayer Rewards" })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)("section", { className: "chart-lrt", id: "chart-apy", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h2", { children: "APY Overtime" }),/*#__PURE__*/(0, jsx_runtime.jsx)(ErrorBoundary_ErrorBoundary, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(CompleteChart, { productName: "aubnb", fallbackData: fallbackData }) })] })] }) };/* harmony default export */ const MiddleAuBnbInfo_MiddleAuBnbInfo = (MiddleAuBnbInfo);
        ;// ./src/static/vectors/aubnb.svg
        const aubnb_namespaceObject = __webpack_require__.p + "static/aubnb.5d5a76e1b64a1a2700bb.svg";
        ;// ./src/routes/ProductInfo/AuBnbInfo.tsx
        const AuBnbInfo = () => { const auBnb = BinanceData.auBnb; const [isSwapDialogOpen, setIsSwapDialogOpen] = (0, react.useState)(false); const [isDepositDialogOpen, setIsDepositDialogOpen] = (0, react.useState)(false); const [, setRefreshKey] = (0, react.useState)(0); const handleRefreshKey = () => setRefreshKey(s => s + 1); return /*#__PURE__*/(0, jsx_runtime.jsxs)(jsx_runtime.Fragment, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(AuBNBMeta, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { id: "asset-info", className: "product-info page", children: [isDepositDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(DepositDialog_DepositDialog, { setIsDepositDialogOpen: setIsDepositDialogOpen, refreshAutoLayerPoints: handleRefreshKey }), isSwapDialogOpen &&/*#__PURE__*/(0, jsx_runtime.jsx)(SwapDialog_SwapDialog, { setIsSwapDialogOpen: setIsSwapDialogOpen, refreshAutoLayerPoints: handleRefreshKey }),/*#__PURE__*/(0, jsx_runtime.jsx)(Header_HeaderProductInfo, { productInfo: auBnb }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(AuBnbBanner, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "grid-container", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("div", { id: "left-asset-info", className: "left-product-info", children:/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "points-box aubnb-points-box", children: [/*#__PURE__*/(0, jsx_runtime.jsx)("h4", { children: "Your position" }),/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { children: [/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "position", children: "0" }),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { children:/*#__PURE__*/(0, jsx_runtime.jsx)("img", { src: aubnb_namespaceObject, alt: "aubnb" }) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)("span", { className: "position-usd", children: "(0 USD)" })] }) }),/*#__PURE__*/(0, jsx_runtime.jsx)(MiddleAuBnbInfo_MiddleAuBnbInfo, {}),/*#__PURE__*/(0, jsx_runtime.jsx)("div", { className: "product-info-buttons", children:/*#__PURE__*/(0, jsx_runtime.jsx)("a", { href: "https://autolayer.notion.site/The-AuBNB-Odyssey-Discovering-Next-Gen-LRT-12f62c8ce4be80d5b5e4e246f02fe04f", className: "button", id: "aubnb-button", target: "_blank", rel: "noopener noreferrer", children:/*#__PURE__*/(0, jsx_runtime.jsx)(message/* default */.A, { id: "how-get-whitelisted" }) }) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(Footer_Footer, {})] })] }) };/* harmony default export */ const ProductInfo_AuBnbInfo = (AuBnbInfo);
        ;// ./src/routes/index.tsx
        const App = () => { const dispatch = (0, es/* useDispatch */.wA)(); (0, react.useEffect)(() => { dispatch({ type: "@@_AFTER_RENDER" }); __webpack_require__.e(/*! import() */ 5475).then(__webpack_require__.bind(__webpack_require__, /*! src/utils/wallet */ 55475)).then(m => m.setup()) }, [dispatch]); return /*#__PURE__*/(0, jsx_runtime.jsxs)(modal_es/* ModalWrapper */.FQ, { children: [/*#__PURE__*/(0, jsx_runtime.jsx)(Meta_Meta, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)("main", { id: "app", children: [/*#__PURE__*/(0, jsx_runtime.jsxs)("div", { className: "pages-transition-group", children: [/*#__PURE__*/(0, jsx_runtime.jsx)(GoToAirdropChecker, {}),/*#__PURE__*/(0, jsx_runtime.jsxs)(dist/* Routes */.BV, { children: [/*#__PURE__*/(0, jsx_runtime.jsxs)(dist/* Route */.qh, { path: "/", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Dashboard_Dashboard, {}), children: [/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "lst", element:/*#__PURE__*/(0, jsx_runtime.jsx)(LstStrategiesGrid, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "lrt", element:/*#__PURE__*/(0, jsx_runtime.jsx)(LrstStrategiesGrid, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "defi-strategies", element:/*#__PURE__*/(0, jsx_runtime.jsx)(DefiStrategiesGrid, {}) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "/stake", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Stake, {}) }),/*#__PURE__*/(0, jsx_runtime.jsxs)(dist/* Route */.qh, { path: "info", element:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfo_ProductInfo, {}), children: [/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "aubnb", element:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfo_AuBnbInfo, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "defi-strategies/:networkName/:productAddress", element:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfo_DefiInfo, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "lst/:networkName/:productName", element:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfo_AssetInfo, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "lrt/:networkName/:productName", element:/*#__PURE__*/(0, jsx_runtime.jsx)(ProductInfo_AssetInfo, {}) })] }),/*#__PURE__*/(0, jsx_runtime.jsxs)(dist/* Route */.qh, { path: "/referrals", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Referrals_Referrals, {}), children: [/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "traders", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Grids_Traders, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "affiliates", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Grids_Affiliates, {}) })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "/airdrop", element:/*#__PURE__*/(0, jsx_runtime.jsx)(Airdrop_Airdrop, {}) }),/*#__PURE__*/(0, jsx_runtime.jsx)(dist/* Route */.qh, { path: "*", element:/*#__PURE__*/(0, jsx_runtime.jsx)(NotFound_NotFound, {}) })] })] }),/*#__PURE__*/(0, jsx_runtime.jsx)(modal_es/* Modal */.aF, {})] })] }) }; const AppWrapper = props =>/*#__PURE__*/(0, jsx_runtime.jsx)(react.Suspense, { fallback:/*#__PURE__*/(0, jsx_runtime.jsx)("div", {}), children:/*#__PURE__*/(0, jsx_runtime.jsx)(App, { ...props }) });/* harmony default export */ const routes = (AppWrapper);

        /***/
}),

/***/ 15101:
/*!*******************************************!*\
  !*** ./src/store/reducers.ts + 2 modules ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";

        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
          A: () => (/* binding */ reducers)
        });

        // UNUSED EXPORTS: reducerList

        ;// ./src/store/reducers/wallet.ts
        const initialState = null; function walletReducer(state = initialState, action) { switch (action.type) { case "wallet/connect": return action.payload; case "wallet/disconnect": return initialState; default: return state } }
        ;// ./src/store/reducers/network.ts
        const network_initialState = ""; function networkReducer(state = network_initialState, action) { switch (action.type) { case "network/set": return action.payload; default: return state } }
        ;// ./src/store/reducers.ts
        const reducerList = { wallet: walletReducer, network: networkReducer };/* harmony default export */ const reducers = (reducerList);

        /***/
}),

/***/ 32815:
/*!********************************!*\
  !*** ./src/types/RiskTypes.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ RiskType)
          /* harmony export */
});
        var RiskType; (function (RiskType) { RiskType["Collateral"] = "collateral"; RiskType["Dexes"] = "dexes" })(RiskType || (RiskType = {}));

        /***/
}),

/***/ 22648:
/*!***************************!*\
  !*** ./src/utils/web3.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
          /* harmony export */
});
/* harmony import */ var web3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web3 */ 52380);
        const web3 = new web3__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */.Ay$(null);/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (web3);

        /***/
}),

/***/ 65772:
/*!********************************************************!*\
  !*** ./src/store/ sync nonrecursive ^\.\/middlewares$ ***!
  \********************************************************/
/***/ ((module) => {

        function webpackEmptyContext(req) {
          var e = new Error("Cannot find module '" + req + "'");
          e.code = 'MODULE_NOT_FOUND';
          throw e;
        }
        webpackEmptyContext.keys = () => ([]);
        webpackEmptyContext.resolve = webpackEmptyContext;
        webpackEmptyContext.id = 65772;
        module.exports = webpackEmptyContext;

        /***/
}),

/***/ 77761:
/*!***********************************************************!*\
  !*** ./src/static/logos/autolayer/autolayerIconColor.svg ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

        "use strict";
        module.exports = __webpack_require__.p + "static/autolayerIconColor.f5098b9ef6ff87c5a582.svg";

        /***/
}),

/***/ 47790:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

        /* (ignored) */

        /***/
})

    /******/
});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
      /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
      /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
    /******/
}
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if (chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for (var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
        /******/
}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
            /******/
} else {
/******/ 						fulfilled = false;
/******/ 						if (priority < notFulfilled) notFulfilled = priority;
            /******/
}
          /******/
}
/******/ 				if (fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
          /******/
}
        /******/
}
/******/ 			return result;
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function (value, mode) {
/******/ 			if (mode & 1) value = this(value);
/******/ 			if (mode & 8) return value;
/******/ 			if (typeof value === 'object' && value) {
/******/ 				if ((mode & 4) && value.__esModule) return value;
/******/ 				if ((mode & 16) && typeof value.then === 'function') return value;
        /******/
}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for (var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
        /******/
}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for (var key in definition) {
/******/ 				if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
}
        /******/
}
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
          /******/
}, []));
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + { "439": "7853996926532ee9a6b6", "579": "cc102188cb211da81f38", "712": "bd386a1e903d86a7ffcc", "750": "91f5ba571f6b80ebf2a6", "778": "30b93583c529938aa626", "940": "586b84a17759a640a5d0", "974": "13f600971ba1d3f55922", "1234": "4497c41c70c457f6c878", "1330": "9a12028343e8bcd145e9", "1355": "646f2c6442adcb944f7a", "1452": "9f34714635306f72ab87", "1538": "a5ca90b865fd01771673", "1751": "44d4aaa3113b45460e2c", "1837": "ca056ffbcf9965500498", "1948": "4d69027ecb8e8c9400e9", "2104": "17a685a5e92782ec776f", "2131": "f77c2f0ca428a2e9ed52", "2526": "993175436a835223183e", "2687": "358dbbe793da5dee6d7e", "2848": "fdbfb079ba079b514fbd", "3045": "f15d6746aac2fac6c8d6", "3135": "6d03df8907c8acf09d8f", "3253": "143bf0e9de48460f99b2", "3430": "e180779eb797d979f9da", "3431": "52da1d73eb9767456517", "3540": "26c7f4202032e90509e8", "3824": "659fc5b55c334e2a6311", "3865": "7fcf1d1f62113d7a690d", "3940": "cdeae036914918e0613c", "4027": "1236749d68ce831a5e09", "4051": "6a0ccebc6cd2a6c34f44", "4351": "e276e72f27e27a85e24e", "4676": "13c404d2bfe43dc5a8d1", "4752": "e8372363eafc47ffd5e6", "4922": "9492f18d207b7867c157", "4954": "0e2b85b3d65eda239555", "5089": "1b751077fa6d96f0f0d6", "5114": "257834a253a78e38b6b4", "5131": "dc3fc768a81a9fc66950", "5238": "d4b071ca8b68b7c5d005", "5307": "3bbdc20009f5ef89dbcc", "5475": "4c9ed8b4dee91dea473c", "5485": "ffdb10f76365e3a277a2", "6172": "da100528408ea74b214d", "6347": "169baa450556541d2791", "6890": "0cb2842ffaa086780fa5", "6902": "86383907e0e136c8152f", "7107": "80b802130fb3b62963d4", "7402": "386518f823ec0865618d", "7509": "922a584f39d5d7b46f0d", "7546": "1e773b21b9a329827db3", "7641": "d9bdcf4784cbd631ac80", "7705": "aad1f4d8bbf1940c2b3b", "7984": "f1d44d38a1d1c5e14479", "8044": "79bbb2222a061e5264d3", "8172": "2e2403b7ccc7cb48f517", "8206": "4949a66208418bc4065b", "8437": "58b465167f26fcbd51ae", "8766": "ac32152a714037e09c46", "8786": "3ea14ffb0a179cd75423", "9262": "b39766ed8ac1b72cb536", "9336": "df23cc5e2b0b6f54eaa7", "9382": "22f5346c55f1aa95bd8f", "9469": "343c075486fce1414fe9", "9573": "2bb6dea13faa0d0690bc", "9576": "8f8fc17559cc803a329c", "9995": "1be8620d6c69adae8d9a" }[chunkId] + ".js";
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function () {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
        /******/
} catch (e) {
/******/ 				if (typeof window === 'object') return window;
        /******/
}
      /******/
})();
    /******/
})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    /******/
})();
/******/
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "autolayer-lrt-ui:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if (inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if (key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for (var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if (s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
          /******/
}
        /******/
}
/******/ 			if (!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
          /******/
}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/
/******/ 				script.src = url;
        /******/
}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if (prev) return prev(event);
        /******/
}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
    /******/
})();
/******/
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			8792: 0
      /******/
};
/******/
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if (installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 					// a Promise means "currently loading".
/******/ 					if (installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
          /******/
} else {
/******/ 						if (true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if (__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if (installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if (installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
                  /******/
}
                /******/
}
              /******/
};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
            /******/
}
          /******/
}
        /******/
}
      /******/
};
/******/
/******/ 		// no prefetching
/******/
/******/ 		// no preloaded
/******/
/******/ 		// no HMR
/******/
/******/ 		// no HMR manifest
/******/
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if (chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for (moduleId in moreModules) {
/******/ 					if (__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
            /******/
}
          /******/
}
/******/ 				if (runtime) var result = runtime(__webpack_require__);
        /******/
}
/******/ 			if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for (; i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
          /******/
}
/******/ 				installedChunks[chunkId] = 0;
        /******/
}
/******/ 			return __webpack_require__.O(result);
      /******/
}
/******/
/******/ 		var chunkLoadingGlobal = self["webpackChunkautolayer_lrt_ui"] = self["webpackChunkautolayer_lrt_ui"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
    /******/
})();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [5249, 8096], () => (__webpack_require__(67768)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
  /******/
  /******/
})()
  ;
//# sourceMappingURL=main.722e9475e482d22fdb74.js.map